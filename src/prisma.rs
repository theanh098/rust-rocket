// Code generated by Prisma Client Rust. DO NOT EDIT
#![allow(unused_imports)]
#![allow(dead_code)]

pub static DATAMODEL_STR: &'static str =
    include_str!("/home/vitaminc/rust-lang/rocket/prisma/schema.prisma");
static DATABASE_STR: &'static str = "postgresql";
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
    url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
    PrismaClient::_builder()
        .with_url(url.to_string())
        .build()
        .await
}
pub mod activities {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "activities";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod kind {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "kind";
        pub struct Set(pub self::ActivityKind);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetKind(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Kind(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::ActivityKind) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Kind(direction)
        }
        pub fn equals(value: self::ActivityKind) -> WhereParam {
            WhereParam::Kind(_prisma::read_filters::ActivityKindFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::ActivityKindFilter,
            Kind,
            {
                fn in_vec(_: Vec<super::super::ActivityKind>) -> InVec;
                fn not_in_vec(_: Vec<super::super::ActivityKind>) -> NotInVec;
                fn not(_: super::super::ActivityKind) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Kind(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Kind(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUserId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, UserId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod review_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "review_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetReviewId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ReviewId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ReviewId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ReviewId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ReviewId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementReviewId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementReviewId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyReviewId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideReviewId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ReviewId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ReviewId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod point {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "point";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPoint(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Point(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Point(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Point(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Point, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementPoint(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementPoint(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyPoint(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DividePoint(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Point(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Point(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod from_user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "from_user_id";
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFromUserId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FromUserId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::FromUserId(direction)
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::FromUserId(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            FromUserId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementFromUserId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementFromUserId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyFromUserId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideFromUserId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FromUserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FromUserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod users_activities_from_user_id_tousers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users_activities_from_user_idTousers";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::UsersActivitiesFromUserIdTousers(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsersActivitiesFromUserIdTousers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectUsersActivitiesFromUserIdTousers
        }
        pub fn is_null() -> WhereParam {
            WhereParam::UsersActivitiesFromUserIdTousersIsNull
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersActivitiesFromUserIdTousersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersActivitiesFromUserIdTousersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UsersActivitiesFromUserIdTousers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new(
                    "users_activities_from_user_idTousers",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UsersActivitiesFromUserIdTousers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new(
                    "users_activities_from_user_idTousers",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod reviews {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "reviews";
        pub struct Fetch(pub reviews::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<reviews::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Reviews(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(reviews::UniqueArgs::new())
        }
        pub struct Connect(reviews::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectReviews(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: reviews::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsIs(value)
        }
        pub fn is_not(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsIsNot(value)
        }
        pub enum Include {
            Select(Vec<reviews::SelectParam>),
            Include(Vec<reviews::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Reviews(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("reviews", None, [], selections)
            }
            pub fn select(nested_selections: Vec<reviews::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<reviews::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<reviews::SelectParam>),
            Include(Vec<reviews::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Reviews(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("reviews", None, [], selections)
            }
            pub fn select(nested_selections: Vec<reviews::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<reviews::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users_activities_user_id_tousers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users_activities_user_idTousers";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::UsersActivitiesUserIdTousers(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsersActivitiesUserIdTousers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersActivitiesUserIdTousersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersActivitiesUserIdTousersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UsersActivitiesUserIdTousers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new(
                    "users_activities_user_idTousers",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UsersActivitiesUserIdTousers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new(
                    "users_activities_user_idTousers",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        kind: super::ActivityKind,
        point: i32,
        reviews: super::reviews::UniqueWhereParam,
        users_activities_user_id_tousers: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        super::ActivityKind,
        i32,
        super::reviews::UniqueWhereParam,
        super::users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (
            kind,
            point,
            reviews,
            users_activities_user_id_tousers,
            _params,
        )
    }
    pub fn create_unchecked(
        kind: super::ActivityKind,
        user_id: i32,
        review_id: i32,
        point: i32,
        _params: Vec<SetParam>,
    ) -> (super::ActivityKind, i32, i32, i32, Vec<SetParam>) {
        (kind, user_id, review_id, point, _params)
    }
    #[macro_export]
    macro_rules ! _select_activities { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: activities :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: activities :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: activities :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: activities :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: activities :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: activities :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , kind , user_id , review_id , point , from_user_id , users_activities_from_user_id_tousers , reviews , users_activities_user_id_tousers } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: activities :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: activities :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: activities :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: activities :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: activities :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: activities :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "kind" , "user_id" , "review_id" , "point" , "from_user_id" , "users_activities_from_user_idTousers" , "reviews" , "users_activities_user_idTousers"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: activities :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; kind) => { crate :: prisma :: ActivityKind } ; (@ field_type ; user_id) => { i32 } ; (@ field_type ; review_id) => { i32 } ; (@ field_type ; point) => { i32 } ; (@ field_type ; from_user_id) => { Option < i32 > } ; (@ field_type ; users_activities_from_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < users_activities_from_user_id_tousers :: Data > } ; (@ field_type ; users_activities_from_user_id_tousers) => { Option < crate :: prisma :: users :: Data > } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { reviews :: Data } ; (@ field_type ; reviews) => { crate :: prisma :: reviews :: Data } ; (@ field_type ; users_activities_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { users_activities_user_id_tousers :: Data } ; (@ field_type ; users_activities_user_id_tousers) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Activities" , available relations are "id, created_at, kind, user_id, review_id, point, from_user_id, users_activities_from_user_id_tousers, reviews, users_activities_user_id_tousers")) } ; (@ field_module ; users_activities_from_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_activities_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: activities :: SelectParam > :: into (crate :: prisma :: activities :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: activities :: SelectParam > :: into (crate :: prisma :: activities :: created_at :: Select) } ; (@ selection_field_to_selection_param ; kind) => { Into :: < crate :: prisma :: activities :: SelectParam > :: into (crate :: prisma :: activities :: kind :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < crate :: prisma :: activities :: SelectParam > :: into (crate :: prisma :: activities :: user_id :: Select) } ; (@ selection_field_to_selection_param ; review_id) => { Into :: < crate :: prisma :: activities :: SelectParam > :: into (crate :: prisma :: activities :: review_id :: Select) } ; (@ selection_field_to_selection_param ; point) => { Into :: < crate :: prisma :: activities :: SelectParam > :: into (crate :: prisma :: activities :: point :: Select) } ; (@ selection_field_to_selection_param ; from_user_id) => { Into :: < crate :: prisma :: activities :: SelectParam > :: into (crate :: prisma :: activities :: from_user_id :: Select) } ; (@ selection_field_to_selection_param ; users_activities_from_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: activities :: SelectParam > :: into (crate :: prisma :: activities :: users_activities_from_user_id_tousers :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_activities_from_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: activities :: SelectParam > :: into (crate :: prisma :: activities :: users_activities_from_user_id_tousers :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: activities :: SelectParam > :: into (crate :: prisma :: activities :: reviews :: Select :: $ selection_mode (crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: activities :: SelectParam > :: into (crate :: prisma :: activities :: reviews :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users_activities_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: activities :: SelectParam > :: into (crate :: prisma :: activities :: users_activities_user_id_tousers :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_activities_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: activities :: SelectParam > :: into (crate :: prisma :: activities :: users_activities_user_id_tousers :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: activities :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; review_id) => { "review_id" } ; (@ field_serde_name ; point) => { "point" } ; (@ field_serde_name ; from_user_id) => { "from_user_id" } ; (@ field_serde_name ; users_activities_from_user_id_tousers) => { "users_activities_from_user_idTousers" } ; (@ field_serde_name ; reviews) => { "reviews" } ; (@ field_serde_name ; users_activities_user_id_tousers) => { "users_activities_user_idTousers" } ; }
    pub use _select_activities as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        Kind(kind::Select),
        UserId(user_id::Select),
        ReviewId(review_id::Select),
        Point(point::Select),
        FromUserId(from_user_id::Select),
        UsersActivitiesFromUserIdTousers(users_activities_from_user_id_tousers::Select),
        Reviews(reviews::Select),
        UsersActivitiesUserIdTousers(users_activities_user_id_tousers::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Kind(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::ReviewId(data) => data.to_selection(),
                Self::Point(data) => data.to_selection(),
                Self::FromUserId(data) => data.to_selection(),
                Self::UsersActivitiesFromUserIdTousers(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
                Self::UsersActivitiesUserIdTousers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_activities { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: activities :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: activities :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: activities :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: activities :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: activities :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: activities :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: activities :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: activities :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { users_activities_from_user_id_tousers , reviews , users_activities_user_id_tousers } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub kind : crate :: prisma :: ActivityKind , pub user_id : i32 , pub review_id : i32 , pub point : i32 , pub from_user_id : Option < i32 > , $ (pub $ field : crate :: prisma :: activities :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (kind) , stringify ! (user_id) , stringify ! (review_id) , stringify ! (point) , stringify ! (from_user_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: activities :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: activities :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: activities :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: activities :: kind :: NAME , & self . kind) ? ; state . serialize_field (crate :: prisma :: activities :: user_id :: NAME , & self . user_id) ? ; state . serialize_field (crate :: prisma :: activities :: review_id :: NAME , & self . review_id) ? ; state . serialize_field (crate :: prisma :: activities :: point :: NAME , & self . point) ? ; state . serialize_field (crate :: prisma :: activities :: from_user_id :: NAME , & self . from_user_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , kind , user_id , review_id , point , from_user_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: activities :: $ field :: NAME) , + , crate :: prisma :: activities :: id :: NAME , crate :: prisma :: activities :: created_at :: NAME , crate :: prisma :: activities :: kind :: NAME , crate :: prisma :: activities :: user_id :: NAME , crate :: prisma :: activities :: review_id :: NAME , crate :: prisma :: activities :: point :: NAME , crate :: prisma :: activities :: from_user_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: activities :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: activities :: id :: NAME => Ok (Field :: id) , crate :: prisma :: activities :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: activities :: kind :: NAME => Ok (Field :: kind) , crate :: prisma :: activities :: user_id :: NAME => Ok (Field :: user_id) , crate :: prisma :: activities :: review_id :: NAME => Ok (Field :: review_id) , crate :: prisma :: activities :: point :: NAME => Ok (Field :: point) , crate :: prisma :: activities :: from_user_id :: NAME => Ok (Field :: from_user_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut kind = None ; let mut user_id = None ; let mut review_id = None ; let mut point = None ; let mut from_user_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: activities :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: activities :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: kind => { if kind . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: activities :: kind :: NAME)) ; } kind = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: activities :: user_id :: NAME)) ; } user_id = Some (map . next_value () ?) ; } Field :: review_id => { if review_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: activities :: review_id :: NAME)) ; } review_id = Some (map . next_value () ?) ; } Field :: point => { if point . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: activities :: point :: NAME)) ; } point = Some (map . next_value () ?) ; } Field :: from_user_id => { if from_user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: activities :: from_user_id :: NAME)) ; } from_user_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: activities :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: activities :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: activities :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: activities :: created_at :: NAME)) ? ; let kind = kind . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: activities :: kind :: NAME)) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: activities :: user_id :: NAME)) ? ; let review_id = review_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: activities :: review_id :: NAME)) ? ; let point = point . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: activities :: point :: NAME)) ? ; let from_user_id = from_user_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: activities :: from_user_id :: NAME)) ? ; Ok (Data { id , created_at , kind , user_id , review_id , point , from_user_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "kind" , "user_id" , "review_id" , "point" , "from_user_id" , "users_activities_from_user_idTousers" , "reviews" , "users_activities_user_idTousers"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: activities :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; users_activities_from_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < users_activities_from_user_id_tousers :: Data > } ; (@ field_type ; users_activities_from_user_id_tousers) => { Option < crate :: prisma :: users :: Data > } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { reviews :: Data } ; (@ field_type ; reviews) => { crate :: prisma :: reviews :: Data } ; (@ field_type ; users_activities_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { users_activities_user_id_tousers :: Data } ; (@ field_type ; users_activities_user_id_tousers) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Activities" , available relations are "users_activities_from_user_id_tousers, reviews, users_activities_user_id_tousers")) } ; (@ field_module ; users_activities_from_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_activities_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; users_activities_from_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: activities :: IncludeParam > :: into (crate :: prisma :: activities :: users_activities_from_user_id_tousers :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_activities_from_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: activities :: IncludeParam > :: into (crate :: prisma :: activities :: users_activities_from_user_id_tousers :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: activities :: IncludeParam > :: into (crate :: prisma :: activities :: reviews :: Include :: $ selection_mode (crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: activities :: IncludeParam > :: into (crate :: prisma :: activities :: reviews :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users_activities_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: activities :: IncludeParam > :: into (crate :: prisma :: activities :: users_activities_user_id_tousers :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_activities_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: activities :: IncludeParam > :: into (crate :: prisma :: activities :: users_activities_user_id_tousers :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: activities :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; kind) => { "kind" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; review_id) => { "review_id" } ; (@ field_serde_name ; point) => { "point" } ; (@ field_serde_name ; from_user_id) => { "from_user_id" } ; (@ field_serde_name ; users_activities_from_user_id_tousers) => { "users_activities_from_user_idTousers" } ; (@ field_serde_name ; reviews) => { "reviews" } ; (@ field_serde_name ; users_activities_user_id_tousers) => { "users_activities_user_idTousers" } ; }
    pub use _include_activities as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        Kind(kind::Include),
        UserId(user_id::Include),
        ReviewId(review_id::Include),
        Point(point::Include),
        FromUserId(from_user_id::Include),
        UsersActivitiesFromUserIdTousers(users_activities_from_user_id_tousers::Include),
        Reviews(reviews::Include),
        UsersActivitiesUserIdTousers(users_activities_user_id_tousers::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Kind(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::ReviewId(data) => data.to_selection(),
                Self::Point(data) => data.to_selection(),
                Self::FromUserId(data) => data.to_selection(),
                Self::UsersActivitiesFromUserIdTousers(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
                Self::UsersActivitiesUserIdTousers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_activities { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: activities struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "kind")] pub kind : crate :: prisma :: ActivityKind , # [serde (rename = "user_id")] pub user_id : i32 , # [serde (rename = "review_id")] pub review_id : i32 , # [serde (rename = "point")] pub point : i32 , # [serde (rename = "from_user_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub from_user_id : Option < i32 > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_activities as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "kind")]
        pub kind: super::ActivityKind,
        #[serde(rename = "user_id")]
        pub user_id: i32,
        #[serde(rename = "review_id")]
        pub review_id: i32,
        #[serde(rename = "point")]
        pub point: i32,
        #[serde(rename = "from_user_id")]
        pub from_user_id: Option<i32>,
        #[serde(
            rename = "users_activities_from_user_idTousers",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub users_activities_from_user_id_tousers: Option<Option<Box<super::users::Data>>>,
        #[serde(rename = "reviews")]
        pub reviews: Option<Box<super::reviews::Data>>,
        #[serde(rename = "users_activities_user_idTousers")]
        pub users_activities_user_id_tousers: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn users_activities_from_user_id_tousers(
            &self,
        ) -> Result<Option<&super::users::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.users_activities_from_user_id_tousers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users_activities_from_user_id_tousers),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn reviews(
            &self,
        ) -> Result<&super::reviews::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.reviews
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(reviews),
                ))
                .map(|v| v.as_ref())
        }
        pub fn users_activities_user_id_tousers(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.users_activities_user_id_tousers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users_activities_user_id_tousers),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        UsersActivitiesFromUserIdTousers(super::users::UniqueArgs),
        Reviews(super::reviews::UniqueArgs),
        UsersActivitiesUserIdTousers(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UsersActivitiesFromUserIdTousers(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        users_activities_from_user_id_tousers::NAME,
                        None,
                        [],
                        selections,
                    )
                }
                Self::Reviews(args) => {
                    let mut selections = < super :: reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(reviews::NAME, None, [], selections)
                }
                Self::UsersActivitiesUserIdTousers(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        users_activities_user_id_tousers::NAME,
                        None,
                        [],
                        selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetKind(super::ActivityKind),
        SetUserId(i32),
        IncrementUserId(i32),
        DecrementUserId(i32),
        MultiplyUserId(i32),
        DivideUserId(i32),
        SetReviewId(i32),
        IncrementReviewId(i32),
        DecrementReviewId(i32),
        MultiplyReviewId(i32),
        DivideReviewId(i32),
        SetPoint(i32),
        IncrementPoint(i32),
        DecrementPoint(i32),
        MultiplyPoint(i32),
        DividePoint(i32),
        SetFromUserId(Option<i32>),
        IncrementFromUserId(i32),
        DecrementFromUserId(i32),
        MultiplyFromUserId(i32),
        DivideFromUserId(i32),
        ConnectUsersActivitiesFromUserIdTousers(super::users::UniqueWhereParam),
        DisconnectUsersActivitiesFromUserIdTousers,
        ConnectReviews(super::reviews::UniqueWhereParam),
        ConnectUsersActivitiesUserIdTousers(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetKind(value) => (
                    kind::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetPoint(value) => (
                    point::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementPoint(value) => (
                    point::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementPoint(value) => (
                    point::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyPoint(value) => (
                    point::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DividePoint(value) => (
                    point::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetFromUserId(value) => (
                    from_user_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementFromUserId(value) => (
                    from_user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementFromUserId(value) => (
                    from_user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyFromUserId(value) => (
                    from_user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideFromUserId(value) => (
                    from_user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectUsersActivitiesFromUserIdTousers(where_param) => (
                    users_activities_from_user_id_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectUsersActivitiesFromUserIdTousers => (
                    users_activities_from_user_id_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectReviews(where_param) => (
                    reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUsersActivitiesUserIdTousers(where_param) => (
                    users_activities_user_id_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        Kind(super::ActivityKind),
        UserId(i32),
        ReviewId(i32),
        Point(i32),
        FromUserId(Option<i32>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::Kind(value) => Self::SetKind(value),
                UncheckedSetParam::UserId(value) => Self::SetUserId(value),
                UncheckedSetParam::ReviewId(value) => Self::SetReviewId(value),
                UncheckedSetParam::Point(value) => Self::SetPoint(value),
                UncheckedSetParam::FromUserId(value) => Self::SetFromUserId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        Kind(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
        ReviewId(::prisma_client_rust::Direction),
        Point(::prisma_client_rust::Direction),
        FromUserId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Kind(direction) => (
                    kind::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ReviewId(direction) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Point(direction) => (
                    point::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::FromUserId(direction) => (
                    from_user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        Kind(_prisma::read_filters::ActivityKindFilter),
        UserId(_prisma::read_filters::IntFilter),
        ReviewId(_prisma::read_filters::IntFilter),
        Point(_prisma::read_filters::IntFilter),
        FromUserId(_prisma::read_filters::IntNullableFilter),
        UsersActivitiesFromUserIdTousersIsNull,
        UsersActivitiesFromUserIdTousersIs(Vec<super::users::WhereParam>),
        UsersActivitiesFromUserIdTousersIsNot(Vec<super::users::WhereParam>),
        ReviewsIs(Vec<super::reviews::WhereParam>),
        ReviewsIsNot(Vec<super::reviews::WhereParam>),
        UsersActivitiesUserIdTousersIs(Vec<super::users::WhereParam>),
        UsersActivitiesUserIdTousersIsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::Kind(value) => (kind::NAME, value.into()),
                Self::UserId(value) => (user_id::NAME, value.into()),
                Self::ReviewId(value) => (review_id::NAME, value.into()),
                Self::Point(value) => (point::NAME, value.into()),
                Self::FromUserId(value) => (from_user_id::NAME, value.into()),
                Self::UsersActivitiesFromUserIdTousersIsNull => (
                    users_activities_from_user_id_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::UsersActivitiesFromUserIdTousersIs(where_params) => (
                    users_activities_from_user_id_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersActivitiesFromUserIdTousersIsNot(where_params) => (
                    users_activities_from_user_id_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewsIs(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewsIsNot(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersActivitiesUserIdTousersIs(where_params) => (
                    users_activities_user_id_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersActivitiesUserIdTousersIsNot(where_params) => (
                    users_activities_user_id_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(kind::NAME),
                ::prisma_client_rust::sel(user_id::NAME),
                ::prisma_client_rust::sel(review_id::NAME),
                ::prisma_client_rust::sel(point::NAME),
                ::prisma_client_rust::sel(from_user_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            kind: super::ActivityKind,
            point: i32,
            reviews: super::reviews::UniqueWhereParam,
            users_activities_user_id_tousers: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                kind::set(kind),
                point::set(point),
                reviews::connect(reviews),
                users_activities_user_id_tousers::connect(users_activities_user_id_tousers),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            kind: super::ActivityKind,
            user_id: i32,
            review_id: i32,
            point: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                kind::set(kind),
                user_id::set(user_id),
                review_id::set(review_id),
                point::set(point),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(super::ActivityKind, i32, i32, i32, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(kind, user_id, review_id, point, mut _params)| {
                    _params.extend([
                        kind::set(kind),
                        user_id::set(user_id),
                        review_id::set(review_id),
                        point::set(point),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (kind, point, reviews, users_activities_user_id_tousers, mut _params): (
                super::ActivityKind,
                i32,
                super::reviews::UniqueWhereParam,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                kind::set(kind),
                point::set(point),
                reviews::connect(reviews),
                users_activities_user_id_tousers::connect(users_activities_user_id_tousers),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod banners {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "banners";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod expried_time {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "expried_time";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetExpriedTime(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ExpriedTime(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ExpriedTime(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::ExpriedTime(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            ExpriedTime,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ExpriedTime(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ExpriedTime(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "source_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSourceId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SourceId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SourceId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::SourceId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            SourceId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementSourceId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementSourceId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplySourceId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideSourceId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SourceId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SourceId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod storages {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "storages";
        pub struct Fetch(pub storages::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<storages::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Storages(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(storages::UniqueArgs::new())
        }
        pub struct Connect(storages::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectStorages(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: storages::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<storages::WhereParam>) -> WhereParam {
            WhereParam::StoragesIs(value)
        }
        pub fn is_not(value: Vec<storages::WhereParam>) -> WhereParam {
            WhereParam::StoragesIsNot(value)
        }
        pub enum Include {
            Select(Vec<storages::SelectParam>),
            Include(Vec<storages::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Storages(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < storages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <storages::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("storages", None, [], selections)
            }
            pub fn select(nested_selections: Vec<storages::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<storages::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<storages::SelectParam>),
            Include(Vec<storages::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Storages(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <storages::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("storages", None, [], selections)
            }
            pub fn select(nested_selections: Vec<storages::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<storages::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        expried_time: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        storages: super::storages::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        super::storages::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (expried_time, storages, _params)
    }
    pub fn create_unchecked(
        expried_time: ::prisma_client_rust::chrono::DateTime<
            ::prisma_client_rust::chrono::FixedOffset,
        >,
        source_id: i32,
        _params: Vec<SetParam>,
    ) -> (
        ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        i32,
        Vec<SetParam>,
    ) {
        (expried_time, source_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_banners { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: banners :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: banners :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: banners :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: banners :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: banners :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: banners :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , expried_time , source_id , storages } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: banners :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: banners :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: banners :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: banners :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: banners :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: banners :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "expried_time" , "source_id" , "storages"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: banners :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; expried_time) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; source_id) => { i32 } ; (@ field_type ; storages : $ selection_mode : ident { $ ($ selections : tt) + }) => { storages :: Data } ; (@ field_type ; storages) => { crate :: prisma :: storages :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Banners" , available relations are "id, created_at, expried_time, source_id, storages")) } ; (@ field_module ; storages : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: storages :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: banners :: SelectParam > :: into (crate :: prisma :: banners :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: banners :: SelectParam > :: into (crate :: prisma :: banners :: created_at :: Select) } ; (@ selection_field_to_selection_param ; expried_time) => { Into :: < crate :: prisma :: banners :: SelectParam > :: into (crate :: prisma :: banners :: expried_time :: Select) } ; (@ selection_field_to_selection_param ; source_id) => { Into :: < crate :: prisma :: banners :: SelectParam > :: into (crate :: prisma :: banners :: source_id :: Select) } ; (@ selection_field_to_selection_param ; storages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: banners :: SelectParam > :: into (crate :: prisma :: banners :: storages :: Select :: $ selection_mode (crate :: prisma :: storages :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; storages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: banners :: SelectParam > :: into (crate :: prisma :: banners :: storages :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: banners :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; expried_time) => { "expried_time" } ; (@ field_serde_name ; source_id) => { "source_id" } ; (@ field_serde_name ; storages) => { "storages" } ; }
    pub use _select_banners as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        ExpriedTime(expried_time::Select),
        SourceId(source_id::Select),
        Storages(storages::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::ExpriedTime(data) => data.to_selection(),
                Self::SourceId(data) => data.to_selection(),
                Self::Storages(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_banners { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: banners :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: banners :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: banners :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: banners :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: banners :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: banners :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: banners :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: banners :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { storages } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub expried_time : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub source_id : i32 , $ (pub $ field : crate :: prisma :: banners :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (expried_time) , stringify ! (source_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: banners :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: banners :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: banners :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: banners :: expried_time :: NAME , & self . expried_time) ? ; state . serialize_field (crate :: prisma :: banners :: source_id :: NAME , & self . source_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , expried_time , source_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: banners :: $ field :: NAME) , + , crate :: prisma :: banners :: id :: NAME , crate :: prisma :: banners :: created_at :: NAME , crate :: prisma :: banners :: expried_time :: NAME , crate :: prisma :: banners :: source_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: banners :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: banners :: id :: NAME => Ok (Field :: id) , crate :: prisma :: banners :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: banners :: expried_time :: NAME => Ok (Field :: expried_time) , crate :: prisma :: banners :: source_id :: NAME => Ok (Field :: source_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut expried_time = None ; let mut source_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: banners :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: banners :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: expried_time => { if expried_time . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: banners :: expried_time :: NAME)) ; } expried_time = Some (map . next_value () ?) ; } Field :: source_id => { if source_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: banners :: source_id :: NAME)) ; } source_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: banners :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: banners :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: banners :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: banners :: created_at :: NAME)) ? ; let expried_time = expried_time . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: banners :: expried_time :: NAME)) ? ; let source_id = source_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: banners :: source_id :: NAME)) ? ; Ok (Data { id , created_at , expried_time , source_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "expried_time" , "source_id" , "storages"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: banners :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; storages : $ selection_mode : ident { $ ($ selections : tt) + }) => { storages :: Data } ; (@ field_type ; storages) => { crate :: prisma :: storages :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Banners" , available relations are "storages")) } ; (@ field_module ; storages : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: storages :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; storages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: banners :: IncludeParam > :: into (crate :: prisma :: banners :: storages :: Include :: $ selection_mode (crate :: prisma :: storages :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; storages $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: banners :: IncludeParam > :: into (crate :: prisma :: banners :: storages :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: banners :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; expried_time) => { "expried_time" } ; (@ field_serde_name ; source_id) => { "source_id" } ; (@ field_serde_name ; storages) => { "storages" } ; }
    pub use _include_banners as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        ExpriedTime(expried_time::Include),
        SourceId(source_id::Include),
        Storages(storages::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::ExpriedTime(data) => data.to_selection(),
                Self::SourceId(data) => data.to_selection(),
                Self::Storages(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_banners { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: banners struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "expried_time")] pub expried_time : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "source_id")] pub source_id : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_banners as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "expried_time")]
        pub expried_time:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "source_id")]
        pub source_id: i32,
        #[serde(rename = "storages")]
        pub storages: Option<Box<super::storages::Data>>,
    }
    impl Data {
        pub fn storages(
            &self,
        ) -> Result<&super::storages::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.storages
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(storages),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Storages(super::storages::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Storages(args) => {
                    let mut selections = < super :: storages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(storages::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetExpriedTime(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetSourceId(i32),
        IncrementSourceId(i32),
        DecrementSourceId(i32),
        MultiplySourceId(i32),
        DivideSourceId(i32),
        ConnectStorages(super::storages::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetExpriedTime(value) => (
                    expried_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplySourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideSourceId(value) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectStorages(where_param) => (
                    storages::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::storages::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        ExpriedTime(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SourceId(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::ExpriedTime(value) => Self::SetExpriedTime(value),
                UncheckedSetParam::SourceId(value) => Self::SetSourceId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        ExpriedTime(::prisma_client_rust::Direction),
        SourceId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ExpriedTime(direction) => (
                    expried_time::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::SourceId(direction) => (
                    source_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        ExpriedTime(_prisma::read_filters::DateTimeFilter),
        SourceId(_prisma::read_filters::IntFilter),
        StoragesIs(Vec<super::storages::WhereParam>),
        StoragesIsNot(Vec<super::storages::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::ExpriedTime(value) => (expried_time::NAME, value.into()),
                Self::SourceId(value) => (source_id::NAME, value.into()),
                Self::StoragesIs(where_params) => (
                    storages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::StoragesIsNot(where_params) => (
                    storages::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(expried_time::NAME),
                ::prisma_client_rust::sel(source_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            expried_time: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            storages: super::storages::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([expried_time::set(expried_time), storages::connect(storages)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            expried_time: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
            source_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([expried_time::set(expried_time), source_id::set(source_id)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                i32,
                Vec<SetParam>,
            )>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(expried_time, source_id, mut _params)| {
                    _params.extend([expried_time::set(expried_time), source_id::set(source_id)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (expried_time, storages, mut _params): (
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
                super::storages::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([expried_time::set(expried_time), storages::connect(storages)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod businesses {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "businesses";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::NameEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod overview {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "overview";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetOverview(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Overview(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Overview(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Overview(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Overview,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Overview(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Overview(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod token {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "token";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetToken(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Token(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Token(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Token(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Token,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Token(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Token(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod logo {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "logo";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLogo(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Logo(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Logo(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Logo(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Logo,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Logo(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Logo(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod founder_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "founder_name";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFounderName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FounderName(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::FounderName(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::FounderName(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            FounderName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FounderName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FounderName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod start_date {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "start_date";
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetStartDate(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::StartDate(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::StartDate(direction)
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::StartDate(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeNullableFilter,
            StartDate,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: Option<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::StartDate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::StartDate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod address {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "address";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAddress(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Address(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Address(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Address(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Address,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Address(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Address(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod whitepaper_url {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "whitepaper_url";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetWhitepaperUrl(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::WhitepaperUrl(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::WhitepaperUrl(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::WhitepaperUrl(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            WhitepaperUrl,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::WhitepaperUrl(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::WhitepaperUrl(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod contract_address {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "contract_address";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetContractAddress(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ContractAddress(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ContractAddress(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ContractAddress(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            ContractAddress,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ContractAddress(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ContractAddress(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod website {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "website";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetWebsite(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Website(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Website(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Website(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Website,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Website(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Website(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod r#type {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "type";
        pub struct Set(pub Vec<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetType(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Type(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Type(direction)
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::Type(_prisma::read_filters::StringListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringListFilter,
            Type,
            {
                fn has(_: Option<String>) -> Has;
                fn has_every(_: Vec<String>) -> HasEvery;
                fn has_some(_: Vec<String>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushType(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Type(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Type(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod main_category {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "main_category";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMainCategory(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::MainCategory(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MainCategory(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::MainCategory(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            MainCategory,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MainCategory(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MainCategory(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod chains {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "chains";
        pub struct Set(pub Vec<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetChains(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Chains(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Chains(direction)
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::Chains(_prisma::read_filters::StringListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringListFilter,
            Chains,
            {
                fn has(_: Option<String>) -> Has;
                fn has_every(_: Vec<String>) -> HasEvery;
                fn has_some(_: Vec<String>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushChains(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Chains(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Chains(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod cmc_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "cmc_id";
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCmcId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CmcId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CmcId(direction)
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::CmcId(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            CmcId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementCmcId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementCmcId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyCmcId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideCmcId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CmcId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CmcId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod contract_chain {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "contract_chain";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetContractChain(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ContractChain(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ContractChain(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::ContractChain(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            ContractChain,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ContractChain(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ContractChain(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod status {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "status";
        pub struct Set(pub self::BusinessStatus);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetStatus(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Status(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::BusinessStatus) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Status(direction)
        }
        pub fn equals(value: self::BusinessStatus) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::BusinessStatusFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BusinessStatusFilter,
            Status,
            {
                fn in_vec(_: Vec<super::super::BusinessStatus>) -> InVec;
                fn not_in_vec(_: Vec<super::super::BusinessStatus>) -> NotInVec;
                fn not(_: super::super::BusinessStatus) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Status(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Status(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod tags {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "tags";
        pub struct Set(pub Vec<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTags(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Tags(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Tags(direction)
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::Tags(_prisma::read_filters::StringListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringListFilter,
            Tags,
            {
                fn has(_: Option<String>) -> Has;
                fn has_every(_: Vec<String>) -> HasEvery;
                fn has_some(_: Vec<String>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushTags(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Tags(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Tags(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod creator_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "creator_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatorId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatorId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatorId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::CreatorId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            CreatorId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementCreatorId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementCreatorId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyCreatorId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideCreatorId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatorId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatorId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod super_users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "super_users";
        pub struct Fetch(pub super_users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<super_users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::SuperUsers(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(super_users::UniqueArgs::new())
        }
        pub struct Connect(super_users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSuperUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: super_users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<super_users::WhereParam>) -> WhereParam {
            WhereParam::SuperUsersIs(value)
        }
        pub fn is_not(value: Vec<super_users::WhereParam>) -> WhereParam {
            WhereParam::SuperUsersIsNot(value)
        }
        pub enum Include {
            Select(Vec<super_users::SelectParam>),
            Include(Vec<super_users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SuperUsers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < super_users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <super_users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        )
                    }
                };
                ::prisma_client_rust::Selection::new("super_users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<super_users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<super_users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<super_users::SelectParam>),
            Include(Vec<super_users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SuperUsers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <super_users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        )
                    }
                };
                ::prisma_client_rust::Selection::new("super_users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<super_users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<super_users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod feedbacks_on_businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "feedbacks_on_businesses";
        pub struct Fetch(pub feedbacks_on_businesses::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<feedbacks_on_businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: feedbacks_on_businesses::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: feedbacks_on_businesses::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::FeedbacksOnBusinesses(v)
            }
        }
        pub fn fetch(params: Vec<feedbacks_on_businesses::WhereParam>) -> Fetch {
            Fetch(feedbacks_on_businesses::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<feedbacks_on_businesses::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectFeedbacksOnBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(
            params: Vec<feedbacks_on_businesses::UniqueWhereParam>,
        ) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<feedbacks_on_businesses::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectFeedbacksOnBusinesses(params)
        }
        pub fn set(params: Vec<feedbacks_on_businesses::UniqueWhereParam>) -> SetParam {
            SetParam::SetFeedbacksOnBusinesses(params)
        }
        pub fn some(value: Vec<feedbacks_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FeedbacksOnBusinessesSome(value)
        }
        pub fn every(value: Vec<feedbacks_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FeedbacksOnBusinessesEvery(value)
        }
        pub fn none(value: Vec<feedbacks_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FeedbacksOnBusinessesNone(value)
        }
        pub enum Include {
            Select(
                feedbacks_on_businesses::ManyArgs,
                Vec<feedbacks_on_businesses::SelectParam>,
            ),
            Include(
                feedbacks_on_businesses::ManyArgs,
                Vec<feedbacks_on_businesses::IncludeParam>,
            ),
            Fetch(feedbacks_on_businesses::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FeedbacksOnBusinesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: feedbacks_on_businesses::ManyArgs,
                nested_selections: Vec<feedbacks_on_businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: feedbacks_on_businesses::ManyArgs,
                nested_selections: Vec<feedbacks_on_businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                feedbacks_on_businesses::ManyArgs,
                Vec<feedbacks_on_businesses::SelectParam>,
            ),
            Include(
                feedbacks_on_businesses::ManyArgs,
                Vec<feedbacks_on_businesses::IncludeParam>,
            ),
            Fetch(feedbacks_on_businesses::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FeedbacksOnBusinesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: feedbacks_on_businesses::ManyArgs,
                nested_selections: Vec<feedbacks_on_businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: feedbacks_on_businesses::ManyArgs,
                nested_selections: Vec<feedbacks_on_businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod followers_on_businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "followers_on_businesses";
        pub struct Fetch(pub followers_on_businesses::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<followers_on_businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: followers_on_businesses::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: followers_on_businesses::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::FollowersOnBusinesses(v)
            }
        }
        pub fn fetch(params: Vec<followers_on_businesses::WhereParam>) -> Fetch {
            Fetch(followers_on_businesses::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<followers_on_businesses::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectFollowersOnBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(
            params: Vec<followers_on_businesses::UniqueWhereParam>,
        ) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<followers_on_businesses::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectFollowersOnBusinesses(params)
        }
        pub fn set(params: Vec<followers_on_businesses::UniqueWhereParam>) -> SetParam {
            SetParam::SetFollowersOnBusinesses(params)
        }
        pub fn some(value: Vec<followers_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FollowersOnBusinessesSome(value)
        }
        pub fn every(value: Vec<followers_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FollowersOnBusinessesEvery(value)
        }
        pub fn none(value: Vec<followers_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FollowersOnBusinessesNone(value)
        }
        pub enum Include {
            Select(
                followers_on_businesses::ManyArgs,
                Vec<followers_on_businesses::SelectParam>,
            ),
            Include(
                followers_on_businesses::ManyArgs,
                Vec<followers_on_businesses::IncludeParam>,
            ),
            Fetch(followers_on_businesses::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FollowersOnBusinesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < followers_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < followers_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: followers_on_businesses::ManyArgs,
                nested_selections: Vec<followers_on_businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: followers_on_businesses::ManyArgs,
                nested_selections: Vec<followers_on_businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                followers_on_businesses::ManyArgs,
                Vec<followers_on_businesses::SelectParam>,
            ),
            Include(
                followers_on_businesses::ManyArgs,
                Vec<followers_on_businesses::IncludeParam>,
            ),
            Fetch(followers_on_businesses::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FollowersOnBusinesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < followers_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: followers_on_businesses::ManyArgs,
                nested_selections: Vec<followers_on_businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: followers_on_businesses::ManyArgs,
                nested_selections: Vec<followers_on_businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod medias {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "medias";
        pub struct Fetch(pub medias::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<medias::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: medias::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: medias::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Medias(v)
            }
        }
        pub fn fetch(params: Vec<medias::WhereParam>) -> Fetch {
            Fetch(medias::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<medias::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectMedias(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<medias::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<medias::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectMedias(params)
        }
        pub fn set(params: Vec<medias::UniqueWhereParam>) -> SetParam {
            SetParam::SetMedias(params)
        }
        pub fn some(value: Vec<medias::WhereParam>) -> WhereParam {
            WhereParam::MediasSome(value)
        }
        pub fn every(value: Vec<medias::WhereParam>) -> WhereParam {
            WhereParam::MediasEvery(value)
        }
        pub fn none(value: Vec<medias::WhereParam>) -> WhereParam {
            WhereParam::MediasNone(value)
        }
        pub enum Include {
            Select(medias::ManyArgs, Vec<medias::SelectParam>),
            Include(medias::ManyArgs, Vec<medias::IncludeParam>),
            Fetch(medias::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Medias(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <medias::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <medias::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: medias::ManyArgs,
                nested_selections: Vec<medias::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: medias::ManyArgs,
                nested_selections: Vec<medias::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(medias::ManyArgs, Vec<medias::SelectParam>),
            Include(medias::ManyArgs, Vec<medias::IncludeParam>),
            Fetch(medias::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Medias(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <medias::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: medias::ManyArgs,
                nested_selections: Vec<medias::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: medias::ManyArgs,
                nested_selections: Vec<medias::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod notifications {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "notifications";
        pub struct Fetch(pub notifications::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<notifications::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: notifications::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: notifications::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Notifications(v)
            }
        }
        pub fn fetch(params: Vec<notifications::WhereParam>) -> Fetch {
            Fetch(notifications::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<notifications::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectNotifications(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<notifications::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<notifications::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectNotifications(params)
        }
        pub fn set(params: Vec<notifications::UniqueWhereParam>) -> SetParam {
            SetParam::SetNotifications(params)
        }
        pub fn some(value: Vec<notifications::WhereParam>) -> WhereParam {
            WhereParam::NotificationsSome(value)
        }
        pub fn every(value: Vec<notifications::WhereParam>) -> WhereParam {
            WhereParam::NotificationsEvery(value)
        }
        pub fn none(value: Vec<notifications::WhereParam>) -> WhereParam {
            WhereParam::NotificationsNone(value)
        }
        pub enum Include {
            Select(notifications::ManyArgs, Vec<notifications::SelectParam>),
            Include(notifications::ManyArgs, Vec<notifications::IncludeParam>),
            Fetch(notifications::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Notifications(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(notifications::ManyArgs, Vec<notifications::SelectParam>),
            Include(notifications::ManyArgs, Vec<notifications::IncludeParam>),
            Fetch(notifications::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Notifications(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod rates_on_businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "rates_on_businesses";
        pub struct Fetch(pub rates_on_businesses::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<rates_on_businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: rates_on_businesses::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: rates_on_businesses::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::RatesOnBusinesses(v)
            }
        }
        pub fn fetch(params: Vec<rates_on_businesses::WhereParam>) -> Fetch {
            Fetch(rates_on_businesses::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<rates_on_businesses::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectRatesOnBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<rates_on_businesses::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<rates_on_businesses::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectRatesOnBusinesses(params)
        }
        pub fn set(params: Vec<rates_on_businesses::UniqueWhereParam>) -> SetParam {
            SetParam::SetRatesOnBusinesses(params)
        }
        pub fn some(value: Vec<rates_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::RatesOnBusinessesSome(value)
        }
        pub fn every(value: Vec<rates_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::RatesOnBusinessesEvery(value)
        }
        pub fn none(value: Vec<rates_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::RatesOnBusinessesNone(value)
        }
        pub enum Include {
            Select(
                rates_on_businesses::ManyArgs,
                Vec<rates_on_businesses::SelectParam>,
            ),
            Include(
                rates_on_businesses::ManyArgs,
                Vec<rates_on_businesses::IncludeParam>,
            ),
            Fetch(rates_on_businesses::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RatesOnBusinesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < rates_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < rates_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: rates_on_businesses::ManyArgs,
                nested_selections: Vec<rates_on_businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: rates_on_businesses::ManyArgs,
                nested_selections: Vec<rates_on_businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                rates_on_businesses::ManyArgs,
                Vec<rates_on_businesses::SelectParam>,
            ),
            Include(
                rates_on_businesses::ManyArgs,
                Vec<rates_on_businesses::IncludeParam>,
            ),
            Fetch(rates_on_businesses::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RatesOnBusinesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < rates_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: rates_on_businesses::ManyArgs,
                nested_selections: Vec<rates_on_businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: rates_on_businesses::ManyArgs,
                nested_selections: Vec<rates_on_businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod reviews {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "reviews";
        pub struct Fetch(pub reviews::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<reviews::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: reviews::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: reviews::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Reviews(v)
            }
        }
        pub fn fetch(params: Vec<reviews::WhereParam>) -> Fetch {
            Fetch(reviews::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<reviews::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectReviews(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<reviews::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<reviews::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectReviews(params)
        }
        pub fn set(params: Vec<reviews::UniqueWhereParam>) -> SetParam {
            SetParam::SetReviews(params)
        }
        pub fn some(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsSome(value)
        }
        pub fn every(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsEvery(value)
        }
        pub fn none(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsNone(value)
        }
        pub enum Include {
            Select(reviews::ManyArgs, Vec<reviews::SelectParam>),
            Include(reviews::ManyArgs, Vec<reviews::IncludeParam>),
            Fetch(reviews::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Reviews(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: reviews::ManyArgs,
                nested_selections: Vec<reviews::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: reviews::ManyArgs,
                nested_selections: Vec<reviews::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(reviews::ManyArgs, Vec<reviews::SelectParam>),
            Include(reviews::ManyArgs, Vec<reviews::IncludeParam>),
            Fetch(reviews::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Reviews(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: reviews::ManyArgs,
                nested_selections: Vec<reviews::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: reviews::ManyArgs,
                nested_selections: Vec<reviews::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        name: String,
        overview: String,
        main_category: String,
        super_users: super::super_users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        String,
        String,
        super::super_users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (name, overview, main_category, super_users, _params)
    }
    pub fn create_unchecked(
        name: String,
        overview: String,
        main_category: String,
        creator_id: i32,
        _params: Vec<SetParam>,
    ) -> (String, String, String, i32, Vec<SetParam>) {
        (name, overview, main_category, creator_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_businesses { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: businesses :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: businesses :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: businesses :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: businesses :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , name , overview , token , logo , founder_name , start_date , address , whitepaper_url , contract_address , website , r#type , main_category , chains , cmc_id , contract_chain , status , tags , creator_id , super_users , feedbacks_on_businesses , followers_on_businesses , medias , notifications , rates_on_businesses , reviews } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: businesses :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: businesses :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: businesses :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: businesses :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "name" , "overview" , "token" , "logo" , "founder_name" , "start_date" , "address" , "whitepaper_url" , "contract_address" , "website" , "type" , "main_category" , "chains" , "cmc_id" , "contract_chain" , "status" , "tags" , "creator_id" , "super_users" , "feedbacks_on_businesses" , "followers_on_businesses" , "medias" , "notifications" , "rates_on_businesses" , "reviews"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: businesses :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; name) => { String } ; (@ field_type ; overview) => { String } ; (@ field_type ; token) => { Option < String > } ; (@ field_type ; logo) => { Option < String > } ; (@ field_type ; founder_name) => { Option < String > } ; (@ field_type ; start_date) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; address) => { Option < String > } ; (@ field_type ; whitepaper_url) => { Option < String > } ; (@ field_type ; contract_address) => { Option < String > } ; (@ field_type ; website) => { Option < String > } ; (@ field_type ; r#type) => { Vec < String > } ; (@ field_type ; main_category) => { String } ; (@ field_type ; chains) => { Vec < String > } ; (@ field_type ; cmc_id) => { Option < i32 > } ; (@ field_type ; contract_chain) => { Option < String > } ; (@ field_type ; status) => { crate :: prisma :: BusinessStatus } ; (@ field_type ; tags) => { Vec < String > } ; (@ field_type ; creator_id) => { i32 } ; (@ field_type ; super_users : $ selection_mode : ident { $ ($ selections : tt) + }) => { super_users :: Data } ; (@ field_type ; super_users) => { crate :: prisma :: super_users :: Data } ; (@ field_type ; feedbacks_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < feedbacks_on_businesses :: Data > } ; (@ field_type ; feedbacks_on_businesses) => { Vec < crate :: prisma :: feedbacks_on_businesses :: Data > } ; (@ field_type ; followers_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < followers_on_businesses :: Data > } ; (@ field_type ; followers_on_businesses) => { Vec < crate :: prisma :: followers_on_businesses :: Data > } ; (@ field_type ; medias : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < medias :: Data > } ; (@ field_type ; medias) => { Vec < crate :: prisma :: medias :: Data > } ; (@ field_type ; notifications : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < notifications :: Data > } ; (@ field_type ; notifications) => { Vec < crate :: prisma :: notifications :: Data > } ; (@ field_type ; rates_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < rates_on_businesses :: Data > } ; (@ field_type ; rates_on_businesses) => { Vec < crate :: prisma :: rates_on_businesses :: Data > } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < reviews :: Data > } ; (@ field_type ; reviews) => { Vec < crate :: prisma :: reviews :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Businesses" , available relations are "id, created_at, name, overview, token, logo, founder_name, start_date, address, whitepaper_url, contract_address, website, r#type, main_category, chains, cmc_id, contract_chain, status, tags, creator_id, super_users, feedbacks_on_businesses, followers_on_businesses, medias, notifications, rates_on_businesses, reviews")) } ; (@ field_module ; super_users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: super_users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; feedbacks_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: feedbacks_on_businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; followers_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: followers_on_businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; medias : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: medias :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; notifications : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: notifications :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; rates_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: rates_on_businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: created_at :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: name :: Select) } ; (@ selection_field_to_selection_param ; overview) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: overview :: Select) } ; (@ selection_field_to_selection_param ; token) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: token :: Select) } ; (@ selection_field_to_selection_param ; logo) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: logo :: Select) } ; (@ selection_field_to_selection_param ; founder_name) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: founder_name :: Select) } ; (@ selection_field_to_selection_param ; start_date) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: start_date :: Select) } ; (@ selection_field_to_selection_param ; address) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: address :: Select) } ; (@ selection_field_to_selection_param ; whitepaper_url) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: whitepaper_url :: Select) } ; (@ selection_field_to_selection_param ; contract_address) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: contract_address :: Select) } ; (@ selection_field_to_selection_param ; website) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: website :: Select) } ; (@ selection_field_to_selection_param ; r#type) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: r#type :: Select) } ; (@ selection_field_to_selection_param ; main_category) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: main_category :: Select) } ; (@ selection_field_to_selection_param ; chains) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: chains :: Select) } ; (@ selection_field_to_selection_param ; cmc_id) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: cmc_id :: Select) } ; (@ selection_field_to_selection_param ; contract_chain) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: contract_chain :: Select) } ; (@ selection_field_to_selection_param ; status) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: status :: Select) } ; (@ selection_field_to_selection_param ; tags) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: tags :: Select) } ; (@ selection_field_to_selection_param ; creator_id) => { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: creator_id :: Select) } ; (@ selection_field_to_selection_param ; super_users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: super_users :: Select :: $ selection_mode (crate :: prisma :: super_users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; super_users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: super_users :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; feedbacks_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: feedbacks_on_businesses :: Select :: $ selection_mode (crate :: prisma :: feedbacks_on_businesses :: ManyArgs :: new (crate :: prisma :: feedbacks_on_businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: feedbacks_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; feedbacks_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: feedbacks_on_businesses :: Select :: Fetch (crate :: prisma :: feedbacks_on_businesses :: ManyArgs :: new (crate :: prisma :: feedbacks_on_businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; followers_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: followers_on_businesses :: Select :: $ selection_mode (crate :: prisma :: followers_on_businesses :: ManyArgs :: new (crate :: prisma :: followers_on_businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: followers_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; followers_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: followers_on_businesses :: Select :: Fetch (crate :: prisma :: followers_on_businesses :: ManyArgs :: new (crate :: prisma :: followers_on_businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; medias $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: medias :: Select :: $ selection_mode (crate :: prisma :: medias :: ManyArgs :: new (crate :: prisma :: medias :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: medias :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; medias $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: medias :: Select :: Fetch (crate :: prisma :: medias :: ManyArgs :: new (crate :: prisma :: medias :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; notifications $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: notifications :: Select :: $ selection_mode (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: notifications :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; notifications $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: notifications :: Select :: Fetch (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; rates_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: rates_on_businesses :: Select :: $ selection_mode (crate :: prisma :: rates_on_businesses :: ManyArgs :: new (crate :: prisma :: rates_on_businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: rates_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; rates_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: rates_on_businesses :: Select :: Fetch (crate :: prisma :: rates_on_businesses :: ManyArgs :: new (crate :: prisma :: rates_on_businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: reviews :: Select :: $ selection_mode (crate :: prisma :: reviews :: ManyArgs :: new (crate :: prisma :: reviews :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: SelectParam > :: into (crate :: prisma :: businesses :: reviews :: Select :: Fetch (crate :: prisma :: reviews :: ManyArgs :: new (crate :: prisma :: reviews :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: businesses :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; overview) => { "overview" } ; (@ field_serde_name ; token) => { "token" } ; (@ field_serde_name ; logo) => { "logo" } ; (@ field_serde_name ; founder_name) => { "founder_name" } ; (@ field_serde_name ; start_date) => { "start_date" } ; (@ field_serde_name ; address) => { "address" } ; (@ field_serde_name ; whitepaper_url) => { "whitepaper_url" } ; (@ field_serde_name ; contract_address) => { "contract_address" } ; (@ field_serde_name ; website) => { "website" } ; (@ field_serde_name ; r#type) => { "type" } ; (@ field_serde_name ; main_category) => { "main_category" } ; (@ field_serde_name ; chains) => { "chains" } ; (@ field_serde_name ; cmc_id) => { "cmc_id" } ; (@ field_serde_name ; contract_chain) => { "contract_chain" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; tags) => { "tags" } ; (@ field_serde_name ; creator_id) => { "creator_id" } ; (@ field_serde_name ; super_users) => { "super_users" } ; (@ field_serde_name ; feedbacks_on_businesses) => { "feedbacks_on_businesses" } ; (@ field_serde_name ; followers_on_businesses) => { "followers_on_businesses" } ; (@ field_serde_name ; medias) => { "medias" } ; (@ field_serde_name ; notifications) => { "notifications" } ; (@ field_serde_name ; rates_on_businesses) => { "rates_on_businesses" } ; (@ field_serde_name ; reviews) => { "reviews" } ; }
    pub use _select_businesses as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        Name(name::Select),
        Overview(overview::Select),
        Token(token::Select),
        Logo(logo::Select),
        FounderName(founder_name::Select),
        StartDate(start_date::Select),
        Address(address::Select),
        WhitepaperUrl(whitepaper_url::Select),
        ContractAddress(contract_address::Select),
        Website(website::Select),
        Type(r#type::Select),
        MainCategory(main_category::Select),
        Chains(chains::Select),
        CmcId(cmc_id::Select),
        ContractChain(contract_chain::Select),
        Status(status::Select),
        Tags(tags::Select),
        CreatorId(creator_id::Select),
        SuperUsers(super_users::Select),
        FeedbacksOnBusinesses(feedbacks_on_businesses::Select),
        FollowersOnBusinesses(followers_on_businesses::Select),
        Medias(medias::Select),
        Notifications(notifications::Select),
        RatesOnBusinesses(rates_on_businesses::Select),
        Reviews(reviews::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Overview(data) => data.to_selection(),
                Self::Token(data) => data.to_selection(),
                Self::Logo(data) => data.to_selection(),
                Self::FounderName(data) => data.to_selection(),
                Self::StartDate(data) => data.to_selection(),
                Self::Address(data) => data.to_selection(),
                Self::WhitepaperUrl(data) => data.to_selection(),
                Self::ContractAddress(data) => data.to_selection(),
                Self::Website(data) => data.to_selection(),
                Self::Type(data) => data.to_selection(),
                Self::MainCategory(data) => data.to_selection(),
                Self::Chains(data) => data.to_selection(),
                Self::CmcId(data) => data.to_selection(),
                Self::ContractChain(data) => data.to_selection(),
                Self::Status(data) => data.to_selection(),
                Self::Tags(data) => data.to_selection(),
                Self::CreatorId(data) => data.to_selection(),
                Self::SuperUsers(data) => data.to_selection(),
                Self::FeedbacksOnBusinesses(data) => data.to_selection(),
                Self::FollowersOnBusinesses(data) => data.to_selection(),
                Self::Medias(data) => data.to_selection(),
                Self::Notifications(data) => data.to_selection(),
                Self::RatesOnBusinesses(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_businesses { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: businesses :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: businesses :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: businesses :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: businesses :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { super_users , feedbacks_on_businesses , followers_on_businesses , medias , notifications , rates_on_businesses , reviews } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub name : String , pub overview : String , pub token : Option < String > , pub logo : Option < String > , pub founder_name : Option < String > , pub start_date : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , pub address : Option < String > , pub whitepaper_url : Option < String > , pub contract_address : Option < String > , pub website : Option < String > , pub r#type : Vec < String > , pub main_category : String , pub chains : Vec < String > , pub cmc_id : Option < i32 > , pub contract_chain : Option < String > , pub status : crate :: prisma :: BusinessStatus , pub tags : Vec < String > , pub creator_id : i32 , $ (pub $ field : crate :: prisma :: businesses :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (name) , stringify ! (overview) , stringify ! (token) , stringify ! (logo) , stringify ! (founder_name) , stringify ! (start_date) , stringify ! (address) , stringify ! (whitepaper_url) , stringify ! (contract_address) , stringify ! (website) , stringify ! (r#type) , stringify ! (main_category) , stringify ! (chains) , stringify ! (cmc_id) , stringify ! (contract_chain) , stringify ! (status) , stringify ! (tags) , stringify ! (creator_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: businesses :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: businesses :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: businesses :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: businesses :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: businesses :: overview :: NAME , & self . overview) ? ; state . serialize_field (crate :: prisma :: businesses :: token :: NAME , & self . token) ? ; state . serialize_field (crate :: prisma :: businesses :: logo :: NAME , & self . logo) ? ; state . serialize_field (crate :: prisma :: businesses :: founder_name :: NAME , & self . founder_name) ? ; state . serialize_field (crate :: prisma :: businesses :: start_date :: NAME , & self . start_date) ? ; state . serialize_field (crate :: prisma :: businesses :: address :: NAME , & self . address) ? ; state . serialize_field (crate :: prisma :: businesses :: whitepaper_url :: NAME , & self . whitepaper_url) ? ; state . serialize_field (crate :: prisma :: businesses :: contract_address :: NAME , & self . contract_address) ? ; state . serialize_field (crate :: prisma :: businesses :: website :: NAME , & self . website) ? ; state . serialize_field (crate :: prisma :: businesses :: r#type :: NAME , & self . r#type) ? ; state . serialize_field (crate :: prisma :: businesses :: main_category :: NAME , & self . main_category) ? ; state . serialize_field (crate :: prisma :: businesses :: chains :: NAME , & self . chains) ? ; state . serialize_field (crate :: prisma :: businesses :: cmc_id :: NAME , & self . cmc_id) ? ; state . serialize_field (crate :: prisma :: businesses :: contract_chain :: NAME , & self . contract_chain) ? ; state . serialize_field (crate :: prisma :: businesses :: status :: NAME , & self . status) ? ; state . serialize_field (crate :: prisma :: businesses :: tags :: NAME , & self . tags) ? ; state . serialize_field (crate :: prisma :: businesses :: creator_id :: NAME , & self . creator_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , name , overview , token , logo , founder_name , start_date , address , whitepaper_url , contract_address , website , r#type , main_category , chains , cmc_id , contract_chain , status , tags , creator_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: businesses :: $ field :: NAME) , + , crate :: prisma :: businesses :: id :: NAME , crate :: prisma :: businesses :: created_at :: NAME , crate :: prisma :: businesses :: name :: NAME , crate :: prisma :: businesses :: overview :: NAME , crate :: prisma :: businesses :: token :: NAME , crate :: prisma :: businesses :: logo :: NAME , crate :: prisma :: businesses :: founder_name :: NAME , crate :: prisma :: businesses :: start_date :: NAME , crate :: prisma :: businesses :: address :: NAME , crate :: prisma :: businesses :: whitepaper_url :: NAME , crate :: prisma :: businesses :: contract_address :: NAME , crate :: prisma :: businesses :: website :: NAME , crate :: prisma :: businesses :: r#type :: NAME , crate :: prisma :: businesses :: main_category :: NAME , crate :: prisma :: businesses :: chains :: NAME , crate :: prisma :: businesses :: cmc_id :: NAME , crate :: prisma :: businesses :: contract_chain :: NAME , crate :: prisma :: businesses :: status :: NAME , crate :: prisma :: businesses :: tags :: NAME , crate :: prisma :: businesses :: creator_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: businesses :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: businesses :: id :: NAME => Ok (Field :: id) , crate :: prisma :: businesses :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: businesses :: name :: NAME => Ok (Field :: name) , crate :: prisma :: businesses :: overview :: NAME => Ok (Field :: overview) , crate :: prisma :: businesses :: token :: NAME => Ok (Field :: token) , crate :: prisma :: businesses :: logo :: NAME => Ok (Field :: logo) , crate :: prisma :: businesses :: founder_name :: NAME => Ok (Field :: founder_name) , crate :: prisma :: businesses :: start_date :: NAME => Ok (Field :: start_date) , crate :: prisma :: businesses :: address :: NAME => Ok (Field :: address) , crate :: prisma :: businesses :: whitepaper_url :: NAME => Ok (Field :: whitepaper_url) , crate :: prisma :: businesses :: contract_address :: NAME => Ok (Field :: contract_address) , crate :: prisma :: businesses :: website :: NAME => Ok (Field :: website) , crate :: prisma :: businesses :: r#type :: NAME => Ok (Field :: r#type) , crate :: prisma :: businesses :: main_category :: NAME => Ok (Field :: main_category) , crate :: prisma :: businesses :: chains :: NAME => Ok (Field :: chains) , crate :: prisma :: businesses :: cmc_id :: NAME => Ok (Field :: cmc_id) , crate :: prisma :: businesses :: contract_chain :: NAME => Ok (Field :: contract_chain) , crate :: prisma :: businesses :: status :: NAME => Ok (Field :: status) , crate :: prisma :: businesses :: tags :: NAME => Ok (Field :: tags) , crate :: prisma :: businesses :: creator_id :: NAME => Ok (Field :: creator_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut name = None ; let mut overview = None ; let mut token = None ; let mut logo = None ; let mut founder_name = None ; let mut start_date = None ; let mut address = None ; let mut whitepaper_url = None ; let mut contract_address = None ; let mut website = None ; let mut r#type = None ; let mut main_category = None ; let mut chains = None ; let mut cmc_id = None ; let mut contract_chain = None ; let mut status = None ; let mut tags = None ; let mut creator_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: overview => { if overview . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: overview :: NAME)) ; } overview = Some (map . next_value () ?) ; } Field :: token => { if token . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: token :: NAME)) ; } token = Some (map . next_value () ?) ; } Field :: logo => { if logo . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: logo :: NAME)) ; } logo = Some (map . next_value () ?) ; } Field :: founder_name => { if founder_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: founder_name :: NAME)) ; } founder_name = Some (map . next_value () ?) ; } Field :: start_date => { if start_date . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: start_date :: NAME)) ; } start_date = Some (map . next_value () ?) ; } Field :: address => { if address . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: address :: NAME)) ; } address = Some (map . next_value () ?) ; } Field :: whitepaper_url => { if whitepaper_url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: whitepaper_url :: NAME)) ; } whitepaper_url = Some (map . next_value () ?) ; } Field :: contract_address => { if contract_address . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: contract_address :: NAME)) ; } contract_address = Some (map . next_value () ?) ; } Field :: website => { if website . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: website :: NAME)) ; } website = Some (map . next_value () ?) ; } Field :: r#type => { if r#type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: r#type :: NAME)) ; } r#type = Some (map . next_value () ?) ; } Field :: main_category => { if main_category . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: main_category :: NAME)) ; } main_category = Some (map . next_value () ?) ; } Field :: chains => { if chains . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: chains :: NAME)) ; } chains = Some (map . next_value () ?) ; } Field :: cmc_id => { if cmc_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: cmc_id :: NAME)) ; } cmc_id = Some (map . next_value () ?) ; } Field :: contract_chain => { if contract_chain . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: contract_chain :: NAME)) ; } contract_chain = Some (map . next_value () ?) ; } Field :: status => { if status . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: status :: NAME)) ; } status = Some (map . next_value () ?) ; } Field :: tags => { if tags . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: tags :: NAME)) ; } tags = Some (map . next_value () ?) ; } Field :: creator_id => { if creator_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: creator_id :: NAME)) ; } creator_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: businesses :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: created_at :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: name :: NAME)) ? ; let overview = overview . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: overview :: NAME)) ? ; let token = token . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: token :: NAME)) ? ; let logo = logo . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: logo :: NAME)) ? ; let founder_name = founder_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: founder_name :: NAME)) ? ; let start_date = start_date . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: start_date :: NAME)) ? ; let address = address . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: address :: NAME)) ? ; let whitepaper_url = whitepaper_url . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: whitepaper_url :: NAME)) ? ; let contract_address = contract_address . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: contract_address :: NAME)) ? ; let website = website . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: website :: NAME)) ? ; let r#type = r#type . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: r#type :: NAME)) ? ; let main_category = main_category . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: main_category :: NAME)) ? ; let chains = chains . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: chains :: NAME)) ? ; let cmc_id = cmc_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: cmc_id :: NAME)) ? ; let contract_chain = contract_chain . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: contract_chain :: NAME)) ? ; let status = status . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: status :: NAME)) ? ; let tags = tags . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: tags :: NAME)) ? ; let creator_id = creator_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: businesses :: creator_id :: NAME)) ? ; Ok (Data { id , created_at , name , overview , token , logo , founder_name , start_date , address , whitepaper_url , contract_address , website , r#type , main_category , chains , cmc_id , contract_chain , status , tags , creator_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "name" , "overview" , "token" , "logo" , "founder_name" , "start_date" , "address" , "whitepaper_url" , "contract_address" , "website" , "type" , "main_category" , "chains" , "cmc_id" , "contract_chain" , "status" , "tags" , "creator_id" , "super_users" , "feedbacks_on_businesses" , "followers_on_businesses" , "medias" , "notifications" , "rates_on_businesses" , "reviews"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: businesses :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; super_users : $ selection_mode : ident { $ ($ selections : tt) + }) => { super_users :: Data } ; (@ field_type ; super_users) => { crate :: prisma :: super_users :: Data } ; (@ field_type ; feedbacks_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < feedbacks_on_businesses :: Data > } ; (@ field_type ; feedbacks_on_businesses) => { Vec < crate :: prisma :: feedbacks_on_businesses :: Data > } ; (@ field_type ; followers_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < followers_on_businesses :: Data > } ; (@ field_type ; followers_on_businesses) => { Vec < crate :: prisma :: followers_on_businesses :: Data > } ; (@ field_type ; medias : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < medias :: Data > } ; (@ field_type ; medias) => { Vec < crate :: prisma :: medias :: Data > } ; (@ field_type ; notifications : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < notifications :: Data > } ; (@ field_type ; notifications) => { Vec < crate :: prisma :: notifications :: Data > } ; (@ field_type ; rates_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < rates_on_businesses :: Data > } ; (@ field_type ; rates_on_businesses) => { Vec < crate :: prisma :: rates_on_businesses :: Data > } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < reviews :: Data > } ; (@ field_type ; reviews) => { Vec < crate :: prisma :: reviews :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Businesses" , available relations are "super_users, feedbacks_on_businesses, followers_on_businesses, medias, notifications, rates_on_businesses, reviews")) } ; (@ field_module ; super_users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: super_users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; feedbacks_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: feedbacks_on_businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; followers_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: followers_on_businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; medias : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: medias :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; notifications : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: notifications :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; rates_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: rates_on_businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; super_users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: super_users :: Include :: $ selection_mode (crate :: prisma :: super_users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; super_users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: super_users :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; feedbacks_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: feedbacks_on_businesses :: Include :: $ selection_mode (crate :: prisma :: feedbacks_on_businesses :: ManyArgs :: new (crate :: prisma :: feedbacks_on_businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: feedbacks_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; feedbacks_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: feedbacks_on_businesses :: Include :: Fetch (crate :: prisma :: feedbacks_on_businesses :: ManyArgs :: new (crate :: prisma :: feedbacks_on_businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; followers_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: followers_on_businesses :: Include :: $ selection_mode (crate :: prisma :: followers_on_businesses :: ManyArgs :: new (crate :: prisma :: followers_on_businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: followers_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; followers_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: followers_on_businesses :: Include :: Fetch (crate :: prisma :: followers_on_businesses :: ManyArgs :: new (crate :: prisma :: followers_on_businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; medias $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: medias :: Include :: $ selection_mode (crate :: prisma :: medias :: ManyArgs :: new (crate :: prisma :: medias :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: medias :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; medias $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: medias :: Include :: Fetch (crate :: prisma :: medias :: ManyArgs :: new (crate :: prisma :: medias :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; notifications $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: notifications :: Include :: $ selection_mode (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: notifications :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; notifications $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: notifications :: Include :: Fetch (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; rates_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: rates_on_businesses :: Include :: $ selection_mode (crate :: prisma :: rates_on_businesses :: ManyArgs :: new (crate :: prisma :: rates_on_businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: rates_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; rates_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: rates_on_businesses :: Include :: Fetch (crate :: prisma :: rates_on_businesses :: ManyArgs :: new (crate :: prisma :: rates_on_businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: reviews :: Include :: $ selection_mode (crate :: prisma :: reviews :: ManyArgs :: new (crate :: prisma :: reviews :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: businesses :: IncludeParam > :: into (crate :: prisma :: businesses :: reviews :: Include :: Fetch (crate :: prisma :: reviews :: ManyArgs :: new (crate :: prisma :: reviews :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: businesses :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; overview) => { "overview" } ; (@ field_serde_name ; token) => { "token" } ; (@ field_serde_name ; logo) => { "logo" } ; (@ field_serde_name ; founder_name) => { "founder_name" } ; (@ field_serde_name ; start_date) => { "start_date" } ; (@ field_serde_name ; address) => { "address" } ; (@ field_serde_name ; whitepaper_url) => { "whitepaper_url" } ; (@ field_serde_name ; contract_address) => { "contract_address" } ; (@ field_serde_name ; website) => { "website" } ; (@ field_serde_name ; r#type) => { "type" } ; (@ field_serde_name ; main_category) => { "main_category" } ; (@ field_serde_name ; chains) => { "chains" } ; (@ field_serde_name ; cmc_id) => { "cmc_id" } ; (@ field_serde_name ; contract_chain) => { "contract_chain" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; tags) => { "tags" } ; (@ field_serde_name ; creator_id) => { "creator_id" } ; (@ field_serde_name ; super_users) => { "super_users" } ; (@ field_serde_name ; feedbacks_on_businesses) => { "feedbacks_on_businesses" } ; (@ field_serde_name ; followers_on_businesses) => { "followers_on_businesses" } ; (@ field_serde_name ; medias) => { "medias" } ; (@ field_serde_name ; notifications) => { "notifications" } ; (@ field_serde_name ; rates_on_businesses) => { "rates_on_businesses" } ; (@ field_serde_name ; reviews) => { "reviews" } ; }
    pub use _include_businesses as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        Name(name::Include),
        Overview(overview::Include),
        Token(token::Include),
        Logo(logo::Include),
        FounderName(founder_name::Include),
        StartDate(start_date::Include),
        Address(address::Include),
        WhitepaperUrl(whitepaper_url::Include),
        ContractAddress(contract_address::Include),
        Website(website::Include),
        Type(r#type::Include),
        MainCategory(main_category::Include),
        Chains(chains::Include),
        CmcId(cmc_id::Include),
        ContractChain(contract_chain::Include),
        Status(status::Include),
        Tags(tags::Include),
        CreatorId(creator_id::Include),
        SuperUsers(super_users::Include),
        FeedbacksOnBusinesses(feedbacks_on_businesses::Include),
        FollowersOnBusinesses(followers_on_businesses::Include),
        Medias(medias::Include),
        Notifications(notifications::Include),
        RatesOnBusinesses(rates_on_businesses::Include),
        Reviews(reviews::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Overview(data) => data.to_selection(),
                Self::Token(data) => data.to_selection(),
                Self::Logo(data) => data.to_selection(),
                Self::FounderName(data) => data.to_selection(),
                Self::StartDate(data) => data.to_selection(),
                Self::Address(data) => data.to_selection(),
                Self::WhitepaperUrl(data) => data.to_selection(),
                Self::ContractAddress(data) => data.to_selection(),
                Self::Website(data) => data.to_selection(),
                Self::Type(data) => data.to_selection(),
                Self::MainCategory(data) => data.to_selection(),
                Self::Chains(data) => data.to_selection(),
                Self::CmcId(data) => data.to_selection(),
                Self::ContractChain(data) => data.to_selection(),
                Self::Status(data) => data.to_selection(),
                Self::Tags(data) => data.to_selection(),
                Self::CreatorId(data) => data.to_selection(),
                Self::SuperUsers(data) => data.to_selection(),
                Self::FeedbacksOnBusinesses(data) => data.to_selection(),
                Self::FollowersOnBusinesses(data) => data.to_selection(),
                Self::Medias(data) => data.to_selection(),
                Self::Notifications(data) => data.to_selection(),
                Self::RatesOnBusinesses(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_businesses { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: businesses struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "name")] pub name : String , # [serde (rename = "overview")] pub overview : String , # [serde (rename = "token")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub token : Option < String > , # [serde (rename = "logo")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub logo : Option < String > , # [serde (rename = "founder_name")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub founder_name : Option < String > , # [serde (rename = "start_date")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub start_date : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "address")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub address : Option < String > , # [serde (rename = "whitepaper_url")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub whitepaper_url : Option < String > , # [serde (rename = "contract_address")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub contract_address : Option < String > , # [serde (rename = "website")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub website : Option < String > , # [serde (rename = "type")] pub r#type : Vec < String > , # [serde (rename = "main_category")] pub main_category : String , # [serde (rename = "chains")] pub chains : Vec < String > , # [serde (rename = "cmc_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub cmc_id : Option < i32 > , # [serde (rename = "contract_chain")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub contract_chain : Option < String > , # [serde (rename = "status")] pub status : crate :: prisma :: BusinessStatus , # [serde (rename = "tags")] pub tags : Vec < String > , # [serde (rename = "creator_id")] pub creator_id : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_businesses as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "overview")]
        pub overview: String,
        #[serde(rename = "token")]
        pub token: Option<String>,
        #[serde(rename = "logo")]
        pub logo: Option<String>,
        #[serde(rename = "founder_name")]
        pub founder_name: Option<String>,
        #[serde(rename = "start_date")]
        pub start_date: Option<
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        >,
        #[serde(rename = "address")]
        pub address: Option<String>,
        #[serde(rename = "whitepaper_url")]
        pub whitepaper_url: Option<String>,
        #[serde(rename = "contract_address")]
        pub contract_address: Option<String>,
        #[serde(rename = "website")]
        pub website: Option<String>,
        #[serde(rename = "type")]
        pub r#type: Vec<String>,
        #[serde(rename = "main_category")]
        pub main_category: String,
        #[serde(rename = "chains")]
        pub chains: Vec<String>,
        #[serde(rename = "cmc_id")]
        pub cmc_id: Option<i32>,
        #[serde(rename = "contract_chain")]
        pub contract_chain: Option<String>,
        #[serde(rename = "status")]
        pub status: super::BusinessStatus,
        #[serde(rename = "tags")]
        pub tags: Vec<String>,
        #[serde(rename = "creator_id")]
        pub creator_id: i32,
        #[serde(rename = "super_users")]
        pub super_users: Option<Box<super::super_users::Data>>,
        #[serde(rename = "feedbacks_on_businesses")]
        pub feedbacks_on_businesses: Option<Vec<super::feedbacks_on_businesses::Data>>,
        #[serde(rename = "followers_on_businesses")]
        pub followers_on_businesses: Option<Vec<super::followers_on_businesses::Data>>,
        #[serde(rename = "medias")]
        pub medias: Option<Vec<super::medias::Data>>,
        #[serde(rename = "notifications")]
        pub notifications: Option<Vec<super::notifications::Data>>,
        #[serde(rename = "rates_on_businesses")]
        pub rates_on_businesses: Option<Vec<super::rates_on_businesses::Data>>,
        #[serde(rename = "reviews")]
        pub reviews: Option<Vec<super::reviews::Data>>,
    }
    impl Data {
        pub fn super_users(
            &self,
        ) -> Result<&super::super_users::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.super_users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(super_users),
                ))
                .map(|v| v.as_ref())
        }
        pub fn feedbacks_on_businesses(
            &self,
        ) -> Result<
            &Vec<super::feedbacks_on_businesses::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.feedbacks_on_businesses.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    feedbacks_on_businesses
                )),
            )
        }
        pub fn followers_on_businesses(
            &self,
        ) -> Result<
            &Vec<super::followers_on_businesses::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.followers_on_businesses.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    followers_on_businesses
                )),
            )
        }
        pub fn medias(
            &self,
        ) -> Result<&Vec<super::medias::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.medias
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(medias),
                ))
        }
        pub fn notifications(
            &self,
        ) -> Result<&Vec<super::notifications::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.notifications
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(notifications),
                ))
        }
        pub fn rates_on_businesses(
            &self,
        ) -> Result<
            &Vec<super::rates_on_businesses::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.rates_on_businesses.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(rates_on_businesses)),
            )
        }
        pub fn reviews(
            &self,
        ) -> Result<&Vec<super::reviews::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.reviews
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(reviews),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        SuperUsers(super::super_users::UniqueArgs),
        FeedbacksOnBusinesses(super::feedbacks_on_businesses::ManyArgs),
        FollowersOnBusinesses(super::followers_on_businesses::ManyArgs),
        Medias(super::medias::ManyArgs),
        Notifications(super::notifications::ManyArgs),
        RatesOnBusinesses(super::rates_on_businesses::ManyArgs),
        Reviews(super::reviews::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::SuperUsers(args) => {
                    let mut selections = < super :: super_users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(super_users::NAME, None, [], selections)
                }
                Self::FeedbacksOnBusinesses(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        feedbacks_on_businesses::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::FollowersOnBusinesses(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: followers_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        followers_on_businesses::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Medias(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: medias :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        medias::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Notifications(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        notifications::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::RatesOnBusinesses(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: rates_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        rates_on_businesses::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Reviews(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        reviews::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetName(String),
        SetOverview(String),
        SetToken(Option<String>),
        SetLogo(Option<String>),
        SetFounderName(Option<String>),
        SetStartDate(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        SetAddress(Option<String>),
        SetWhitepaperUrl(Option<String>),
        SetContractAddress(Option<String>),
        SetWebsite(Option<String>),
        SetType(Vec<String>),
        PushType(Vec<String>),
        SetMainCategory(String),
        SetChains(Vec<String>),
        PushChains(Vec<String>),
        SetCmcId(Option<i32>),
        IncrementCmcId(i32),
        DecrementCmcId(i32),
        MultiplyCmcId(i32),
        DivideCmcId(i32),
        SetContractChain(Option<String>),
        SetStatus(super::BusinessStatus),
        SetTags(Vec<String>),
        PushTags(Vec<String>),
        SetCreatorId(i32),
        IncrementCreatorId(i32),
        DecrementCreatorId(i32),
        MultiplyCreatorId(i32),
        DivideCreatorId(i32),
        ConnectSuperUsers(super::super_users::UniqueWhereParam),
        ConnectFeedbacksOnBusinesses(Vec<super::feedbacks_on_businesses::UniqueWhereParam>),
        DisconnectFeedbacksOnBusinesses(Vec<super::feedbacks_on_businesses::UniqueWhereParam>),
        SetFeedbacksOnBusinesses(Vec<super::feedbacks_on_businesses::UniqueWhereParam>),
        ConnectFollowersOnBusinesses(Vec<super::followers_on_businesses::UniqueWhereParam>),
        DisconnectFollowersOnBusinesses(Vec<super::followers_on_businesses::UniqueWhereParam>),
        SetFollowersOnBusinesses(Vec<super::followers_on_businesses::UniqueWhereParam>),
        ConnectMedias(Vec<super::medias::UniqueWhereParam>),
        DisconnectMedias(Vec<super::medias::UniqueWhereParam>),
        SetMedias(Vec<super::medias::UniqueWhereParam>),
        ConnectNotifications(Vec<super::notifications::UniqueWhereParam>),
        DisconnectNotifications(Vec<super::notifications::UniqueWhereParam>),
        SetNotifications(Vec<super::notifications::UniqueWhereParam>),
        ConnectRatesOnBusinesses(Vec<super::rates_on_businesses::UniqueWhereParam>),
        DisconnectRatesOnBusinesses(Vec<super::rates_on_businesses::UniqueWhereParam>),
        SetRatesOnBusinesses(Vec<super::rates_on_businesses::UniqueWhereParam>),
        ConnectReviews(Vec<super::reviews::UniqueWhereParam>),
        DisconnectReviews(Vec<super::reviews::UniqueWhereParam>),
        SetReviews(Vec<super::reviews::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetOverview(value) => (
                    overview::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetToken(value) => (
                    token::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetLogo(value) => (
                    logo::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetFounderName(value) => (
                    founder_name::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetStartDate(value) => (
                    start_date::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetAddress(value) => (
                    address::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetWhitepaperUrl(value) => (
                    whitepaper_url::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetContractAddress(value) => (
                    contract_address::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetWebsite(value) => (
                    website::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetType(value) => (
                    r#type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .collect(),
                    ),
                ),
                SetParam::PushType(value) => (
                    r#type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetMainCategory(value) => (
                    main_category::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetChains(value) => (
                    chains::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .collect(),
                    ),
                ),
                SetParam::PushChains(value) => (
                    chains::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetCmcId(value) => (
                    cmc_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementCmcId(value) => (
                    cmc_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementCmcId(value) => (
                    cmc_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyCmcId(value) => (
                    cmc_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideCmcId(value) => (
                    cmc_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetContractChain(value) => (
                    contract_chain::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetStatus(value) => (
                    status::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetTags(value) => (
                    tags::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .collect(),
                    ),
                ),
                SetParam::PushTags(value) => (
                    tags::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetCreatorId(value) => (
                    creator_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementCreatorId(value) => (
                    creator_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementCreatorId(value) => (
                    creator_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyCreatorId(value) => (
                    creator_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideCreatorId(value) => (
                    creator_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectSuperUsers(where_param) => (
                    super_users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::super_users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectFeedbacksOnBusinesses(where_params) => (
                    feedbacks_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::feedbacks_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectFeedbacksOnBusinesses(where_params) => (
                    feedbacks_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::feedbacks_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetFeedbacksOnBusinesses(where_params) => (
                    feedbacks_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::feedbacks_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectFollowersOnBusinesses(where_params) => (
                    followers_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::followers_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectFollowersOnBusinesses(where_params) => (
                    followers_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::followers_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetFollowersOnBusinesses(where_params) => (
                    followers_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::followers_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectMedias(where_params) => (
                    medias::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::medias::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectMedias(where_params) => (
                    medias::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::medias::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetMedias(where_params) => (
                    medias::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::medias::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectNotifications(where_params) => (
                    notifications::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::notifications::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectNotifications(where_params) => (
                    notifications::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::notifications::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetNotifications(where_params) => (
                    notifications::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::notifications::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectRatesOnBusinesses(where_params) => (
                    rates_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::rates_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectRatesOnBusinesses(where_params) => (
                    rates_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::rates_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetRatesOnBusinesses(where_params) => (
                    rates_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::rates_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectReviews(where_params) => (
                    reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectReviews(where_params) => (
                    reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetReviews(where_params) => (
                    reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        Name(String),
        Overview(String),
        Token(Option<String>),
        Logo(Option<String>),
        FounderName(Option<String>),
        StartDate(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        Address(Option<String>),
        WhitepaperUrl(Option<String>),
        ContractAddress(Option<String>),
        Website(Option<String>),
        Type(Vec<String>),
        MainCategory(String),
        Chains(Vec<String>),
        CmcId(Option<i32>),
        ContractChain(Option<String>),
        Status(super::BusinessStatus),
        Tags(Vec<String>),
        CreatorId(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::Overview(value) => Self::SetOverview(value),
                UncheckedSetParam::Token(value) => Self::SetToken(value),
                UncheckedSetParam::Logo(value) => Self::SetLogo(value),
                UncheckedSetParam::FounderName(value) => Self::SetFounderName(value),
                UncheckedSetParam::StartDate(value) => Self::SetStartDate(value),
                UncheckedSetParam::Address(value) => Self::SetAddress(value),
                UncheckedSetParam::WhitepaperUrl(value) => Self::SetWhitepaperUrl(value),
                UncheckedSetParam::ContractAddress(value) => Self::SetContractAddress(value),
                UncheckedSetParam::Website(value) => Self::SetWebsite(value),
                UncheckedSetParam::Type(value) => Self::SetType(value),
                UncheckedSetParam::MainCategory(value) => Self::SetMainCategory(value),
                UncheckedSetParam::Chains(value) => Self::SetChains(value),
                UncheckedSetParam::CmcId(value) => Self::SetCmcId(value),
                UncheckedSetParam::ContractChain(value) => Self::SetContractChain(value),
                UncheckedSetParam::Status(value) => Self::SetStatus(value),
                UncheckedSetParam::Tags(value) => Self::SetTags(value),
                UncheckedSetParam::CreatorId(value) => Self::SetCreatorId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Overview(::prisma_client_rust::Direction),
        Token(::prisma_client_rust::Direction),
        Logo(::prisma_client_rust::Direction),
        FounderName(::prisma_client_rust::Direction),
        StartDate(::prisma_client_rust::Direction),
        Address(::prisma_client_rust::Direction),
        WhitepaperUrl(::prisma_client_rust::Direction),
        ContractAddress(::prisma_client_rust::Direction),
        Website(::prisma_client_rust::Direction),
        Type(::prisma_client_rust::Direction),
        MainCategory(::prisma_client_rust::Direction),
        Chains(::prisma_client_rust::Direction),
        CmcId(::prisma_client_rust::Direction),
        ContractChain(::prisma_client_rust::Direction),
        Status(::prisma_client_rust::Direction),
        Tags(::prisma_client_rust::Direction),
        CreatorId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Overview(direction) => (
                    overview::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Token(direction) => (
                    token::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Logo(direction) => (
                    logo::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::FounderName(direction) => (
                    founder_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::StartDate(direction) => (
                    start_date::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Address(direction) => (
                    address::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::WhitepaperUrl(direction) => (
                    whitepaper_url::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ContractAddress(direction) => (
                    contract_address::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Website(direction) => (
                    website::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Type(direction) => (
                    r#type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MainCategory(direction) => (
                    main_category::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Chains(direction) => (
                    chains::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CmcId(direction) => (
                    cmc_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ContractChain(direction) => (
                    contract_chain::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Status(direction) => (
                    status::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Tags(direction) => (
                    tags::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatorId(direction) => (
                    creator_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        Name(_prisma::read_filters::StringFilter),
        Overview(_prisma::read_filters::StringFilter),
        Token(_prisma::read_filters::StringNullableFilter),
        Logo(_prisma::read_filters::StringNullableFilter),
        FounderName(_prisma::read_filters::StringNullableFilter),
        StartDate(_prisma::read_filters::DateTimeNullableFilter),
        Address(_prisma::read_filters::StringNullableFilter),
        WhitepaperUrl(_prisma::read_filters::StringNullableFilter),
        ContractAddress(_prisma::read_filters::StringNullableFilter),
        Website(_prisma::read_filters::StringNullableFilter),
        Type(_prisma::read_filters::StringListFilter),
        MainCategory(_prisma::read_filters::StringFilter),
        Chains(_prisma::read_filters::StringListFilter),
        CmcId(_prisma::read_filters::IntNullableFilter),
        ContractChain(_prisma::read_filters::StringNullableFilter),
        Status(_prisma::read_filters::BusinessStatusFilter),
        Tags(_prisma::read_filters::StringListFilter),
        CreatorId(_prisma::read_filters::IntFilter),
        SuperUsersIs(Vec<super::super_users::WhereParam>),
        SuperUsersIsNot(Vec<super::super_users::WhereParam>),
        FeedbacksOnBusinessesSome(Vec<super::feedbacks_on_businesses::WhereParam>),
        FeedbacksOnBusinessesEvery(Vec<super::feedbacks_on_businesses::WhereParam>),
        FeedbacksOnBusinessesNone(Vec<super::feedbacks_on_businesses::WhereParam>),
        FollowersOnBusinessesSome(Vec<super::followers_on_businesses::WhereParam>),
        FollowersOnBusinessesEvery(Vec<super::followers_on_businesses::WhereParam>),
        FollowersOnBusinessesNone(Vec<super::followers_on_businesses::WhereParam>),
        MediasSome(Vec<super::medias::WhereParam>),
        MediasEvery(Vec<super::medias::WhereParam>),
        MediasNone(Vec<super::medias::WhereParam>),
        NotificationsSome(Vec<super::notifications::WhereParam>),
        NotificationsEvery(Vec<super::notifications::WhereParam>),
        NotificationsNone(Vec<super::notifications::WhereParam>),
        RatesOnBusinessesSome(Vec<super::rates_on_businesses::WhereParam>),
        RatesOnBusinessesEvery(Vec<super::rates_on_businesses::WhereParam>),
        RatesOnBusinessesNone(Vec<super::rates_on_businesses::WhereParam>),
        ReviewsSome(Vec<super::reviews::WhereParam>),
        ReviewsEvery(Vec<super::reviews::WhereParam>),
        ReviewsNone(Vec<super::reviews::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Overview(value) => (overview::NAME, value.into()),
                Self::Token(value) => (token::NAME, value.into()),
                Self::Logo(value) => (logo::NAME, value.into()),
                Self::FounderName(value) => (founder_name::NAME, value.into()),
                Self::StartDate(value) => (start_date::NAME, value.into()),
                Self::Address(value) => (address::NAME, value.into()),
                Self::WhitepaperUrl(value) => (whitepaper_url::NAME, value.into()),
                Self::ContractAddress(value) => (contract_address::NAME, value.into()),
                Self::Website(value) => (website::NAME, value.into()),
                Self::Type(value) => (r#type::NAME, value.into()),
                Self::MainCategory(value) => (main_category::NAME, value.into()),
                Self::Chains(value) => (chains::NAME, value.into()),
                Self::CmcId(value) => (cmc_id::NAME, value.into()),
                Self::ContractChain(value) => (contract_chain::NAME, value.into()),
                Self::Status(value) => (status::NAME, value.into()),
                Self::Tags(value) => (tags::NAME, value.into()),
                Self::CreatorId(value) => (creator_id::NAME, value.into()),
                Self::SuperUsersIs(where_params) => (
                    super_users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SuperUsersIsNot(where_params) => (
                    super_users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FeedbacksOnBusinessesSome(where_params) => (
                    feedbacks_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FeedbacksOnBusinessesEvery(where_params) => (
                    feedbacks_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FeedbacksOnBusinessesNone(where_params) => (
                    feedbacks_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FollowersOnBusinessesSome(where_params) => (
                    followers_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FollowersOnBusinessesEvery(where_params) => (
                    followers_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FollowersOnBusinessesNone(where_params) => (
                    followers_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MediasSome(where_params) => (
                    medias::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MediasEvery(where_params) => (
                    medias::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::MediasNone(where_params) => (
                    medias::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotificationsSome(where_params) => (
                    notifications::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotificationsEvery(where_params) => (
                    notifications::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotificationsNone(where_params) => (
                    notifications::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RatesOnBusinessesSome(where_params) => (
                    rates_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RatesOnBusinessesEvery(where_params) => (
                    rates_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RatesOnBusinessesNone(where_params) => (
                    rates_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewsSome(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewsEvery(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewsNone(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        NameEquals(String),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::NameEquals(value) => {
                    Self::Name(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(overview::NAME),
                ::prisma_client_rust::sel(token::NAME),
                ::prisma_client_rust::sel(logo::NAME),
                ::prisma_client_rust::sel(founder_name::NAME),
                ::prisma_client_rust::sel(start_date::NAME),
                ::prisma_client_rust::sel(address::NAME),
                ::prisma_client_rust::sel(whitepaper_url::NAME),
                ::prisma_client_rust::sel(contract_address::NAME),
                ::prisma_client_rust::sel(website::NAME),
                ::prisma_client_rust::sel(r#type::NAME),
                ::prisma_client_rust::sel(main_category::NAME),
                ::prisma_client_rust::sel(chains::NAME),
                ::prisma_client_rust::sel(cmc_id::NAME),
                ::prisma_client_rust::sel(contract_chain::NAME),
                ::prisma_client_rust::sel(status::NAME),
                ::prisma_client_rust::sel(tags::NAME),
                ::prisma_client_rust::sel(creator_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            name: String,
            overview: String,
            main_category: String,
            super_users: super::super_users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                name::set(name),
                overview::set(overview),
                main_category::set(main_category),
                super_users::connect(super_users),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            name: String,
            overview: String,
            main_category: String,
            creator_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                name::set(name),
                overview::set(overview),
                main_category::set(main_category),
                creator_id::set(creator_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, String, String, i32, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(name, overview, main_category, creator_id, mut _params)| {
                    _params.extend([
                        name::set(name),
                        overview::set(overview),
                        main_category::set(main_category),
                        creator_id::set(creator_id),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (name, overview, main_category, super_users, mut _params): (
                String,
                String,
                String,
                super::super_users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                name::set(name),
                overview::set(overview),
                main_category::set(main_category),
                super_users::connect(super_users),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod campaigns {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "campaigns";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod title {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "title";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTitle(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Title(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Title(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Title(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Title,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Title(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Title(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod description {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "description";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDescription(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Description(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Description(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Description(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Description,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Description(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Description(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod metadata {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "metadata";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMetadata(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Metadata(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Metadata(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Metadata(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Metadata,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Metadata(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Metadata(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod users_on_campaigns {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users_on_campaigns";
        pub struct Fetch(pub users_on_campaigns::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users_on_campaigns::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: users_on_campaigns::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: users_on_campaigns::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::UsersOnCampaigns(v)
            }
        }
        pub fn fetch(params: Vec<users_on_campaigns::WhereParam>) -> Fetch {
            Fetch(users_on_campaigns::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<users_on_campaigns::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsersOnCampaigns(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<users_on_campaigns::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<users_on_campaigns::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectUsersOnCampaigns(params)
        }
        pub fn set(params: Vec<users_on_campaigns::UniqueWhereParam>) -> SetParam {
            SetParam::SetUsersOnCampaigns(params)
        }
        pub fn some(value: Vec<users_on_campaigns::WhereParam>) -> WhereParam {
            WhereParam::UsersOnCampaignsSome(value)
        }
        pub fn every(value: Vec<users_on_campaigns::WhereParam>) -> WhereParam {
            WhereParam::UsersOnCampaignsEvery(value)
        }
        pub fn none(value: Vec<users_on_campaigns::WhereParam>) -> WhereParam {
            WhereParam::UsersOnCampaignsNone(value)
        }
        pub enum Include {
            Select(
                users_on_campaigns::ManyArgs,
                Vec<users_on_campaigns::SelectParam>,
            ),
            Include(
                users_on_campaigns::ManyArgs,
                Vec<users_on_campaigns::IncludeParam>,
            ),
            Fetch(users_on_campaigns::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UsersOnCampaigns(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < users_on_campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < users_on_campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: users_on_campaigns::ManyArgs,
                nested_selections: Vec<users_on_campaigns::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: users_on_campaigns::ManyArgs,
                nested_selections: Vec<users_on_campaigns::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                users_on_campaigns::ManyArgs,
                Vec<users_on_campaigns::SelectParam>,
            ),
            Include(
                users_on_campaigns::ManyArgs,
                Vec<users_on_campaigns::IncludeParam>,
            ),
            Fetch(users_on_campaigns::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UsersOnCampaigns(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < users_on_campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: users_on_campaigns::ManyArgs,
                nested_selections: Vec<users_on_campaigns::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: users_on_campaigns::ManyArgs,
                nested_selections: Vec<users_on_campaigns::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        title: String,
        description: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (title, description, _params)
    }
    pub fn create_unchecked(
        title: String,
        description: String,
        _params: Vec<SetParam>,
    ) -> (String, String, Vec<SetParam>) {
        (title, description, _params)
    }
    #[macro_export]
    macro_rules ! _select_campaigns { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: campaigns :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: campaigns :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: campaigns :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: campaigns :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: campaigns :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: campaigns :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , title , description , metadata , users_on_campaigns } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: campaigns :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: campaigns :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: campaigns :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: campaigns :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: campaigns :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: campaigns :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "title" , "description" , "metadata" , "users_on_campaigns"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: campaigns :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; title) => { String } ; (@ field_type ; description) => { String } ; (@ field_type ; metadata) => { Option < String > } ; (@ field_type ; users_on_campaigns : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < users_on_campaigns :: Data > } ; (@ field_type ; users_on_campaigns) => { Vec < crate :: prisma :: users_on_campaigns :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Campaigns" , available relations are "id, created_at, title, description, metadata, users_on_campaigns")) } ; (@ field_module ; users_on_campaigns : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users_on_campaigns :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: campaigns :: SelectParam > :: into (crate :: prisma :: campaigns :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: campaigns :: SelectParam > :: into (crate :: prisma :: campaigns :: created_at :: Select) } ; (@ selection_field_to_selection_param ; title) => { Into :: < crate :: prisma :: campaigns :: SelectParam > :: into (crate :: prisma :: campaigns :: title :: Select) } ; (@ selection_field_to_selection_param ; description) => { Into :: < crate :: prisma :: campaigns :: SelectParam > :: into (crate :: prisma :: campaigns :: description :: Select) } ; (@ selection_field_to_selection_param ; metadata) => { Into :: < crate :: prisma :: campaigns :: SelectParam > :: into (crate :: prisma :: campaigns :: metadata :: Select) } ; (@ selection_field_to_selection_param ; users_on_campaigns $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: campaigns :: SelectParam > :: into (crate :: prisma :: campaigns :: users_on_campaigns :: Select :: $ selection_mode (crate :: prisma :: users_on_campaigns :: ManyArgs :: new (crate :: prisma :: users_on_campaigns :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: users_on_campaigns :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_on_campaigns $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: campaigns :: SelectParam > :: into (crate :: prisma :: campaigns :: users_on_campaigns :: Select :: Fetch (crate :: prisma :: users_on_campaigns :: ManyArgs :: new (crate :: prisma :: users_on_campaigns :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: campaigns :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; metadata) => { "metadata" } ; (@ field_serde_name ; users_on_campaigns) => { "users_on_campaigns" } ; }
    pub use _select_campaigns as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        Title(title::Select),
        Description(description::Select),
        Metadata(metadata::Select),
        UsersOnCampaigns(users_on_campaigns::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::Metadata(data) => data.to_selection(),
                Self::UsersOnCampaigns(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_campaigns { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: campaigns :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: campaigns :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: campaigns :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: campaigns :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: campaigns :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: campaigns :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { users_on_campaigns } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub title : String , pub description : String , pub metadata : Option < String > , $ (pub $ field : crate :: prisma :: campaigns :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (title) , stringify ! (description) , stringify ! (metadata)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: campaigns :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: campaigns :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: campaigns :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: campaigns :: title :: NAME , & self . title) ? ; state . serialize_field (crate :: prisma :: campaigns :: description :: NAME , & self . description) ? ; state . serialize_field (crate :: prisma :: campaigns :: metadata :: NAME , & self . metadata) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , title , description , metadata } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: campaigns :: $ field :: NAME) , + , crate :: prisma :: campaigns :: id :: NAME , crate :: prisma :: campaigns :: created_at :: NAME , crate :: prisma :: campaigns :: title :: NAME , crate :: prisma :: campaigns :: description :: NAME , crate :: prisma :: campaigns :: metadata :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: campaigns :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: campaigns :: id :: NAME => Ok (Field :: id) , crate :: prisma :: campaigns :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: campaigns :: title :: NAME => Ok (Field :: title) , crate :: prisma :: campaigns :: description :: NAME => Ok (Field :: description) , crate :: prisma :: campaigns :: metadata :: NAME => Ok (Field :: metadata) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut title = None ; let mut description = None ; let mut metadata = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: campaigns :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: campaigns :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: title => { if title . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: campaigns :: title :: NAME)) ; } title = Some (map . next_value () ?) ; } Field :: description => { if description . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: campaigns :: description :: NAME)) ; } description = Some (map . next_value () ?) ; } Field :: metadata => { if metadata . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: campaigns :: metadata :: NAME)) ; } metadata = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: campaigns :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: campaigns :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: campaigns :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: campaigns :: created_at :: NAME)) ? ; let title = title . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: campaigns :: title :: NAME)) ? ; let description = description . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: campaigns :: description :: NAME)) ? ; let metadata = metadata . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: campaigns :: metadata :: NAME)) ? ; Ok (Data { id , created_at , title , description , metadata , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "title" , "description" , "metadata" , "users_on_campaigns"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: campaigns :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; users_on_campaigns : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < users_on_campaigns :: Data > } ; (@ field_type ; users_on_campaigns) => { Vec < crate :: prisma :: users_on_campaigns :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Campaigns" , available relations are "users_on_campaigns")) } ; (@ field_module ; users_on_campaigns : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users_on_campaigns :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; users_on_campaigns $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: campaigns :: IncludeParam > :: into (crate :: prisma :: campaigns :: users_on_campaigns :: Include :: $ selection_mode (crate :: prisma :: users_on_campaigns :: ManyArgs :: new (crate :: prisma :: users_on_campaigns :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: users_on_campaigns :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_on_campaigns $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: campaigns :: IncludeParam > :: into (crate :: prisma :: campaigns :: users_on_campaigns :: Include :: Fetch (crate :: prisma :: users_on_campaigns :: ManyArgs :: new (crate :: prisma :: users_on_campaigns :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: campaigns :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; title) => { "title" } ; (@ field_serde_name ; description) => { "description" } ; (@ field_serde_name ; metadata) => { "metadata" } ; (@ field_serde_name ; users_on_campaigns) => { "users_on_campaigns" } ; }
    pub use _include_campaigns as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        Title(title::Include),
        Description(description::Include),
        Metadata(metadata::Include),
        UsersOnCampaigns(users_on_campaigns::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Title(data) => data.to_selection(),
                Self::Description(data) => data.to_selection(),
                Self::Metadata(data) => data.to_selection(),
                Self::UsersOnCampaigns(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_campaigns { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: campaigns struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "title")] pub title : String , # [serde (rename = "description")] pub description : String , # [serde (rename = "metadata")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub metadata : Option < String > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_campaigns as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "title")]
        pub title: String,
        #[serde(rename = "description")]
        pub description: String,
        #[serde(rename = "metadata")]
        pub metadata: Option<String>,
        #[serde(rename = "users_on_campaigns")]
        pub users_on_campaigns: Option<Vec<super::users_on_campaigns::Data>>,
    }
    impl Data {
        pub fn users_on_campaigns(
            &self,
        ) -> Result<
            &Vec<super::users_on_campaigns::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.users_on_campaigns.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(users_on_campaigns)),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        UsersOnCampaigns(super::users_on_campaigns::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UsersOnCampaigns(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: users_on_campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        users_on_campaigns::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetTitle(String),
        SetDescription(String),
        SetMetadata(Option<String>),
        ConnectUsersOnCampaigns(Vec<super::users_on_campaigns::UniqueWhereParam>),
        DisconnectUsersOnCampaigns(Vec<super::users_on_campaigns::UniqueWhereParam>),
        SetUsersOnCampaigns(Vec<super::users_on_campaigns::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetTitle(value) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetDescription(value) => (
                    description::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetMetadata(value) => (
                    metadata::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectUsersOnCampaigns(where_params) => (
                    users_on_campaigns::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users_on_campaigns::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectUsersOnCampaigns(where_params) => (
                    users_on_campaigns::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users_on_campaigns::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetUsersOnCampaigns(where_params) => (
                    users_on_campaigns::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users_on_campaigns::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        Title(String),
        Description(String),
        Metadata(Option<String>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::Title(value) => Self::SetTitle(value),
                UncheckedSetParam::Description(value) => Self::SetDescription(value),
                UncheckedSetParam::Metadata(value) => Self::SetMetadata(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        Title(::prisma_client_rust::Direction),
        Description(::prisma_client_rust::Direction),
        Metadata(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Title(direction) => (
                    title::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Description(direction) => (
                    description::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Metadata(direction) => (
                    metadata::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        Title(_prisma::read_filters::StringFilter),
        Description(_prisma::read_filters::StringFilter),
        Metadata(_prisma::read_filters::StringNullableFilter),
        UsersOnCampaignsSome(Vec<super::users_on_campaigns::WhereParam>),
        UsersOnCampaignsEvery(Vec<super::users_on_campaigns::WhereParam>),
        UsersOnCampaignsNone(Vec<super::users_on_campaigns::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::Title(value) => (title::NAME, value.into()),
                Self::Description(value) => (description::NAME, value.into()),
                Self::Metadata(value) => (metadata::NAME, value.into()),
                Self::UsersOnCampaignsSome(where_params) => (
                    users_on_campaigns::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersOnCampaignsEvery(where_params) => (
                    users_on_campaigns::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersOnCampaignsNone(where_params) => (
                    users_on_campaigns::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(title::NAME),
                ::prisma_client_rust::sel(description::NAME),
                ::prisma_client_rust::sel(metadata::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            title: String,
            description: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([title::set(title), description::set(description)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            title: String,
            description: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([title::set(title), description::set(description)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(title, description, mut _params)| {
                    _params.extend([title::set(title), description::set(description)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (title, description, mut _params): (String, String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([title::set(title), description::set(description)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod criteria_reviews {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "criteria_reviews";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Name(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Name, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Name(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Name(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod value {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "value";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetValue(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Value(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Value(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Value(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Value, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementValue(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementValue(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyValue(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideValue(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Value(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Value(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod review_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "review_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetReviewId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ReviewId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ReviewId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ReviewId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ReviewId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementReviewId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementReviewId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyReviewId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideReviewId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ReviewId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ReviewId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod reviews {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "reviews";
        pub struct Fetch(pub reviews::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<reviews::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Reviews(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(reviews::UniqueArgs::new())
        }
        pub struct Connect(reviews::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectReviews(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: reviews::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsIs(value)
        }
        pub fn is_not(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsIsNot(value)
        }
        pub enum Include {
            Select(Vec<reviews::SelectParam>),
            Include(Vec<reviews::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Reviews(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("reviews", None, [], selections)
            }
            pub fn select(nested_selections: Vec<reviews::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<reviews::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<reviews::SelectParam>),
            Include(Vec<reviews::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Reviews(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("reviews", None, [], selections)
            }
            pub fn select(nested_selections: Vec<reviews::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<reviews::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        name: String,
        value: i32,
        reviews: super::reviews::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (String, i32, super::reviews::UniqueWhereParam, Vec<SetParam>) {
        (name, value, reviews, _params)
    }
    pub fn create_unchecked(
        name: String,
        value: i32,
        review_id: i32,
        _params: Vec<SetParam>,
    ) -> (String, i32, i32, Vec<SetParam>) {
        (name, value, review_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_criteria_reviews { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: criteria_reviews :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: criteria_reviews :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: criteria_reviews :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: criteria_reviews :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: criteria_reviews :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: criteria_reviews :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , value , review_id , reviews } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: criteria_reviews :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: criteria_reviews :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: criteria_reviews :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: criteria_reviews :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: criteria_reviews :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: criteria_reviews :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "value" , "review_id" , "reviews"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: criteria_reviews :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; name) => { String } ; (@ field_type ; value) => { i32 } ; (@ field_type ; review_id) => { i32 } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { reviews :: Data } ; (@ field_type ; reviews) => { crate :: prisma :: reviews :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "CriteriaReviews" , available relations are "id, name, value, review_id, reviews")) } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: criteria_reviews :: SelectParam > :: into (crate :: prisma :: criteria_reviews :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: prisma :: criteria_reviews :: SelectParam > :: into (crate :: prisma :: criteria_reviews :: name :: Select) } ; (@ selection_field_to_selection_param ; value) => { Into :: < crate :: prisma :: criteria_reviews :: SelectParam > :: into (crate :: prisma :: criteria_reviews :: value :: Select) } ; (@ selection_field_to_selection_param ; review_id) => { Into :: < crate :: prisma :: criteria_reviews :: SelectParam > :: into (crate :: prisma :: criteria_reviews :: review_id :: Select) } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: criteria_reviews :: SelectParam > :: into (crate :: prisma :: criteria_reviews :: reviews :: Select :: $ selection_mode (crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: criteria_reviews :: SelectParam > :: into (crate :: prisma :: criteria_reviews :: reviews :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: criteria_reviews :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; value) => { "value" } ; (@ field_serde_name ; review_id) => { "review_id" } ; (@ field_serde_name ; reviews) => { "reviews" } ; }
    pub use _select_criteria_reviews as select;
    pub enum SelectParam {
        Id(id::Select),
        Name(name::Select),
        Value(value::Select),
        ReviewId(review_id::Select),
        Reviews(reviews::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Value(data) => data.to_selection(),
                Self::ReviewId(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_criteria_reviews { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: criteria_reviews :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: criteria_reviews :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: criteria_reviews :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: criteria_reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: criteria_reviews :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: criteria_reviews :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: criteria_reviews :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: criteria_reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { reviews } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub name : String , pub value : i32 , pub review_id : i32 , $ (pub $ field : crate :: prisma :: criteria_reviews :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (value) , stringify ! (review_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: criteria_reviews :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: criteria_reviews :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: criteria_reviews :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: prisma :: criteria_reviews :: value :: NAME , & self . value) ? ; state . serialize_field (crate :: prisma :: criteria_reviews :: review_id :: NAME , & self . review_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , value , review_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: criteria_reviews :: $ field :: NAME) , + , crate :: prisma :: criteria_reviews :: id :: NAME , crate :: prisma :: criteria_reviews :: name :: NAME , crate :: prisma :: criteria_reviews :: value :: NAME , crate :: prisma :: criteria_reviews :: review_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: criteria_reviews :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: criteria_reviews :: id :: NAME => Ok (Field :: id) , crate :: prisma :: criteria_reviews :: name :: NAME => Ok (Field :: name) , crate :: prisma :: criteria_reviews :: value :: NAME => Ok (Field :: value) , crate :: prisma :: criteria_reviews :: review_id :: NAME => Ok (Field :: review_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut value = None ; let mut review_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: criteria_reviews :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: criteria_reviews :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: value => { if value . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: criteria_reviews :: value :: NAME)) ; } value = Some (map . next_value () ?) ; } Field :: review_id => { if review_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: criteria_reviews :: review_id :: NAME)) ; } review_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: criteria_reviews :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: criteria_reviews :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: criteria_reviews :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: criteria_reviews :: name :: NAME)) ? ; let value = value . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: criteria_reviews :: value :: NAME)) ? ; let review_id = review_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: criteria_reviews :: review_id :: NAME)) ? ; Ok (Data { id , name , value , review_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "value" , "review_id" , "reviews"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: criteria_reviews :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { reviews :: Data } ; (@ field_type ; reviews) => { crate :: prisma :: reviews :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "CriteriaReviews" , available relations are "reviews")) } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: criteria_reviews :: IncludeParam > :: into (crate :: prisma :: criteria_reviews :: reviews :: Include :: $ selection_mode (crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: criteria_reviews :: IncludeParam > :: into (crate :: prisma :: criteria_reviews :: reviews :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: criteria_reviews :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; value) => { "value" } ; (@ field_serde_name ; review_id) => { "review_id" } ; (@ field_serde_name ; reviews) => { "reviews" } ; }
    pub use _include_criteria_reviews as include;
    pub enum IncludeParam {
        Id(id::Include),
        Name(name::Include),
        Value(value::Include),
        ReviewId(review_id::Include),
        Reviews(reviews::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Name(data) => data.to_selection(),
                Self::Value(data) => data.to_selection(),
                Self::ReviewId(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_criteria_reviews { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: criteria_reviews struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "name")] pub name : String , # [serde (rename = "value")] pub value : i32 , # [serde (rename = "review_id")] pub review_id : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_criteria_reviews as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "value")]
        pub value: i32,
        #[serde(rename = "review_id")]
        pub review_id: i32,
        #[serde(rename = "reviews")]
        pub reviews: Option<Box<super::reviews::Data>>,
    }
    impl Data {
        pub fn reviews(
            &self,
        ) -> Result<&super::reviews::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.reviews
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(reviews),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Reviews(super::reviews::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Reviews(args) => {
                    let mut selections = < super :: reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(reviews::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetName(String),
        SetValue(i32),
        IncrementValue(i32),
        DecrementValue(i32),
        MultiplyValue(i32),
        DivideValue(i32),
        SetReviewId(i32),
        IncrementReviewId(i32),
        DecrementReviewId(i32),
        MultiplyReviewId(i32),
        DivideReviewId(i32),
        ConnectReviews(super::reviews::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetName(value) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetValue(value) => (
                    value::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementValue(value) => (
                    value::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementValue(value) => (
                    value::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyValue(value) => (
                    value::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideValue(value) => (
                    value::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectReviews(where_param) => (
                    reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        Name(String),
        Value(i32),
        ReviewId(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Name(value) => Self::SetName(value),
                UncheckedSetParam::Value(value) => Self::SetValue(value),
                UncheckedSetParam::ReviewId(value) => Self::SetReviewId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Name(::prisma_client_rust::Direction),
        Value(::prisma_client_rust::Direction),
        ReviewId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Value(direction) => (
                    value::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ReviewId(direction) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        Name(_prisma::read_filters::StringFilter),
        Value(_prisma::read_filters::IntFilter),
        ReviewId(_prisma::read_filters::IntFilter),
        ReviewsIs(Vec<super::reviews::WhereParam>),
        ReviewsIsNot(Vec<super::reviews::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Name(value) => (name::NAME, value.into()),
                Self::Value(value) => (value::NAME, value.into()),
                Self::ReviewId(value) => (review_id::NAME, value.into()),
                Self::ReviewsIs(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewsIsNot(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(name::NAME),
                ::prisma_client_rust::sel(value::NAME),
                ::prisma_client_rust::sel(review_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            name: String,
            value: i32,
            reviews: super::reviews::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                name::set(name),
                value::set(value),
                reviews::connect(reviews),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            name: String,
            value: i32,
            review_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                name::set(name),
                value::set(value),
                review_id::set(review_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, i32, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(name, value, review_id, mut _params)| {
                    _params.extend([
                        name::set(name),
                        value::set(value),
                        review_id::set(review_id),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (name, value, reviews, mut _params): (
                String,
                i32,
                super::reviews::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                name::set(name),
                value::set(value),
                reviews::connect(reviews),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod dids {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "dids";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod controller {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "controller";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetController(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Controller(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Controller(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::ControllerEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Controller,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Controller(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Controller(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "email";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetEmail(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Email(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Email,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Email(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Email(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod username {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "username";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUsername(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Username(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Username(direction)
        }
        pub fn equals<A, T: ::prisma_client_rust::FromOptionalUniqueArg<Set, Arg = A>>(
            value: A,
        ) -> T {
            T::from_arg(value)
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Username,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Username(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Username(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users";
        pub struct Fetch(pub users::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: users::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: users::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Users(v)
            }
        }
        pub fn fetch(params: Vec<users::WhereParam>) -> Fetch {
            Fetch(users::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<users::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<users::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<users::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectUsers(params)
        }
        pub fn set(params: Vec<users::UniqueWhereParam>) -> SetParam {
            SetParam::SetUsers(params)
        }
        pub fn some(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersSome(value)
        }
        pub fn every(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersEvery(value)
        }
        pub fn none(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersNone(value)
        }
        pub enum Include {
            Select(users::ManyArgs, Vec<users::SelectParam>),
            Include(users::ManyArgs, Vec<users::IncludeParam>),
            Fetch(users::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Users(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: users::ManyArgs,
                nested_selections: Vec<users::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: users::ManyArgs,
                nested_selections: Vec<users::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(users::ManyArgs, Vec<users::SelectParam>),
            Include(users::ManyArgs, Vec<users::IncludeParam>),
            Fetch(users::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Users(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: users::ManyArgs,
                nested_selections: Vec<users::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: users::ManyArgs,
                nested_selections: Vec<users::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(controller: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (controller, _params)
    }
    pub fn create_unchecked(controller: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (controller, _params)
    }
    #[macro_export]
    macro_rules ! _select_dids { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: dids :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: dids :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: dids :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: dids :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: dids :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: dids :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , controller , email , username , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: dids :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: dids :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: dids :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: dids :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: dids :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: dids :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "controller" , "email" , "username" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: dids :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; controller) => { String } ; (@ field_type ; email) => { Option < String > } ; (@ field_type ; username) => { Option < String > } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < users :: Data > } ; (@ field_type ; users) => { Vec < crate :: prisma :: users :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Dids" , available relations are "id, controller, email, username, users")) } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: dids :: SelectParam > :: into (crate :: prisma :: dids :: id :: Select) } ; (@ selection_field_to_selection_param ; controller) => { Into :: < crate :: prisma :: dids :: SelectParam > :: into (crate :: prisma :: dids :: controller :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < crate :: prisma :: dids :: SelectParam > :: into (crate :: prisma :: dids :: email :: Select) } ; (@ selection_field_to_selection_param ; username) => { Into :: < crate :: prisma :: dids :: SelectParam > :: into (crate :: prisma :: dids :: username :: Select) } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: dids :: SelectParam > :: into (crate :: prisma :: dids :: users :: Select :: $ selection_mode (crate :: prisma :: users :: ManyArgs :: new (crate :: prisma :: users :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: dids :: SelectParam > :: into (crate :: prisma :: dids :: users :: Select :: Fetch (crate :: prisma :: users :: ManyArgs :: new (crate :: prisma :: users :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: dids :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; controller) => { "controller" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; username) => { "username" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _select_dids as select;
    pub enum SelectParam {
        Id(id::Select),
        Controller(controller::Select),
        Email(email::Select),
        Username(username::Select),
        Users(users::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Controller(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::Username(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_dids { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: dids :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: dids :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: dids :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: dids :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: dids :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: dids :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: dids :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: dids :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub controller : String , pub email : Option < String > , pub username : Option < String > , $ (pub $ field : crate :: prisma :: dids :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (controller) , stringify ! (email) , stringify ! (username)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: dids :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: dids :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: dids :: controller :: NAME , & self . controller) ? ; state . serialize_field (crate :: prisma :: dids :: email :: NAME , & self . email) ? ; state . serialize_field (crate :: prisma :: dids :: username :: NAME , & self . username) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , controller , email , username } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: dids :: $ field :: NAME) , + , crate :: prisma :: dids :: id :: NAME , crate :: prisma :: dids :: controller :: NAME , crate :: prisma :: dids :: email :: NAME , crate :: prisma :: dids :: username :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: dids :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: dids :: id :: NAME => Ok (Field :: id) , crate :: prisma :: dids :: controller :: NAME => Ok (Field :: controller) , crate :: prisma :: dids :: email :: NAME => Ok (Field :: email) , crate :: prisma :: dids :: username :: NAME => Ok (Field :: username) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut controller = None ; let mut email = None ; let mut username = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: dids :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: controller => { if controller . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: dids :: controller :: NAME)) ; } controller = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: dids :: email :: NAME)) ; } email = Some (map . next_value () ?) ; } Field :: username => { if username . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: dids :: username :: NAME)) ; } username = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: dids :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: dids :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: dids :: id :: NAME)) ? ; let controller = controller . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: dids :: controller :: NAME)) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: dids :: email :: NAME)) ? ; let username = username . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: dids :: username :: NAME)) ? ; Ok (Data { id , controller , email , username , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "controller" , "email" , "username" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: dids :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < users :: Data > } ; (@ field_type ; users) => { Vec < crate :: prisma :: users :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Dids" , available relations are "users")) } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: dids :: IncludeParam > :: into (crate :: prisma :: dids :: users :: Include :: $ selection_mode (crate :: prisma :: users :: ManyArgs :: new (crate :: prisma :: users :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: dids :: IncludeParam > :: into (crate :: prisma :: dids :: users :: Include :: Fetch (crate :: prisma :: users :: ManyArgs :: new (crate :: prisma :: users :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: dids :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; controller) => { "controller" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; username) => { "username" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _include_dids as include;
    pub enum IncludeParam {
        Id(id::Include),
        Controller(controller::Include),
        Email(email::Include),
        Username(username::Include),
        Users(users::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Controller(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::Username(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_dids { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: dids struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "controller")] pub controller : String , # [serde (rename = "email")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub email : Option < String > , # [serde (rename = "username")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub username : Option < String > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_dids as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "controller")]
        pub controller: String,
        #[serde(rename = "email")]
        pub email: Option<String>,
        #[serde(rename = "username")]
        pub username: Option<String>,
        #[serde(rename = "users")]
        pub users: Option<Vec<super::users::Data>>,
    }
    impl Data {
        pub fn users(
            &self,
        ) -> Result<&Vec<super::users::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Users(super::users::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Users(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        users::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetController(String),
        SetEmail(Option<String>),
        SetUsername(Option<String>),
        ConnectUsers(Vec<super::users::UniqueWhereParam>),
        DisconnectUsers(Vec<super::users::UniqueWhereParam>),
        SetUsers(Vec<super::users::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetController(value) => (
                    controller::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetEmail(value) => (
                    email::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetUsername(value) => (
                    username::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectUsers(where_params) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectUsers(where_params) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetUsers(where_params) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        Controller(String),
        Email(Option<String>),
        Username(Option<String>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Controller(value) => Self::SetController(value),
                UncheckedSetParam::Email(value) => Self::SetEmail(value),
                UncheckedSetParam::Username(value) => Self::SetUsername(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Controller(::prisma_client_rust::Direction),
        Email(::prisma_client_rust::Direction),
        Username(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Controller(direction) => (
                    controller::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Email(direction) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Username(direction) => (
                    username::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        Controller(_prisma::read_filters::StringFilter),
        Email(_prisma::read_filters::StringNullableFilter),
        Username(_prisma::read_filters::StringNullableFilter),
        UsersSome(Vec<super::users::WhereParam>),
        UsersEvery(Vec<super::users::WhereParam>),
        UsersNone(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Controller(value) => (controller::NAME, value.into()),
                Self::Email(value) => (email::NAME, value.into()),
                Self::Username(value) => (username::NAME, value.into()),
                Self::UsersSome(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersEvery(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersNone(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        ControllerEquals(String),
        UsernameEquals(String),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::ControllerEquals(value) => {
                    Self::Controller(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::UsernameEquals(value) => Self::Username(
                    _prisma::read_filters::StringNullableFilter::Equals(Some(value)),
                ),
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl ::prisma_client_rust::FromOptionalUniqueArg<username::Set> for WhereParam {
        type Arg = Option<String>;
        fn from_arg(arg: Self::Arg) -> Self
        where
            Self: Sized,
        {
            Self::Username(_prisma::read_filters::StringNullableFilter::Equals(arg))
        }
    }
    impl ::prisma_client_rust::FromOptionalUniqueArg<username::Set> for UniqueWhereParam {
        type Arg = String;
        fn from_arg(arg: Self::Arg) -> Self
        where
            Self: Sized,
        {
            Self::UsernameEquals(arg)
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(controller::NAME),
                ::prisma_client_rust::sel(email::NAME),
                ::prisma_client_rust::sel(username::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, controller: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.extend([controller::set(controller)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            controller: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([controller::set(controller)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(controller, mut _params)| {
                    _params.extend([controller::set(controller)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (controller, mut _params): (String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([controller::set(controller)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod emails {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "emails";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "email";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetEmail(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Email(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::EmailEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Email,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Email(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Email(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(email: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (email, _params)
    }
    pub fn create_unchecked(email: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (email, _params)
    }
    #[macro_export]
    macro_rules ! _select_emails { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: emails :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: emails :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: emails :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: emails :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: emails :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: emails :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , email } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: emails :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: emails :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: emails :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: emails :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: emails :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: emails :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "email"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: emails :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; email) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Emails" , available relations are "id, created_at, email")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: emails :: SelectParam > :: into (crate :: prisma :: emails :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: emails :: SelectParam > :: into (crate :: prisma :: emails :: created_at :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < crate :: prisma :: emails :: SelectParam > :: into (crate :: prisma :: emails :: email :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: emails :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; email) => { "email" } ; }
    pub use _select_emails as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        Email(email::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_emails { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: emails :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: emails :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: emails :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: emails :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: emails :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: emails :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: emails :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: emails :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub email : String , $ (pub $ field : crate :: prisma :: emails :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (email)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: emails :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: emails :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: emails :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: emails :: email :: NAME , & self . email) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , email } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: emails :: $ field :: NAME) , + , crate :: prisma :: emails :: id :: NAME , crate :: prisma :: emails :: created_at :: NAME , crate :: prisma :: emails :: email :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: emails :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: emails :: id :: NAME => Ok (Field :: id) , crate :: prisma :: emails :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: emails :: email :: NAME => Ok (Field :: email) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut email = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: emails :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: emails :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: emails :: email :: NAME)) ; } email = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: emails :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: emails :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: emails :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: emails :: created_at :: NAME)) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: emails :: email :: NAME)) ? ; Ok (Data { id , created_at , email , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "email"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: emails :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Emails" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: emails :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; email) => { "email" } ; }
    pub use _include_emails as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        Email(email::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_emails { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: emails struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "email")] pub email : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_emails as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "email")]
        pub email: String,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetEmail(String),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetEmail(value) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        Email(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::Email(value) => Self::SetEmail(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        Email(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Email(direction) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        Email(_prisma::read_filters::StringFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::Email(value) => (email::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        EmailEquals(String),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::EmailEquals(value) => {
                    Self::Email(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(email::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, email: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.extend([email::set(email)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            email: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([email::set(email)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(email, mut _params)| {
                    _params.extend([email::set(email)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (email, mut _params): (String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([email::set(email)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod feedbacks_on_businesses {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "feedbacks_on_businesses";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod business_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "business_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBusinessId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BusinessId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BusinessId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::BusinessId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            BusinessId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementBusinessId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementBusinessId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyBusinessId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideBusinessId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BusinessId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BusinessId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUserId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, UserId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod text {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "text";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetText(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Text(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Text(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Text(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Text, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Text(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Text(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod urls {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "urls";
        pub struct Set(pub Vec<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUrls(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Urls(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Urls(direction)
        }
        pub fn equals(value: Vec<String>) -> WhereParam {
            WhereParam::Urls(_prisma::read_filters::StringListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringListFilter,
            Urls,
            {
                fn has(_: Option<String>) -> Has;
                fn has_every(_: Vec<String>) -> HasEvery;
                fn has_some(_: Vec<String>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<String>) -> SetParam {
            SetParam::PushUrls(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Urls(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Urls(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod dislikes {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "dislikes";
        pub struct Set(pub Vec<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDislikes(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Dislikes(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Dislikes(direction)
        }
        pub fn equals(value: Vec<i32>) -> WhereParam {
            WhereParam::Dislikes(_prisma::read_filters::IntListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntListFilter,
            Dislikes,
            {
                fn has(_: Option<i32>) -> Has;
                fn has_every(_: Vec<i32>) -> HasEvery;
                fn has_some(_: Vec<i32>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<i32>) -> SetParam {
            SetParam::PushDislikes(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Dislikes(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Dislikes(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod likes {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "likes";
        pub struct Set(pub Vec<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLikes(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Likes(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Likes(direction)
        }
        pub fn equals(value: Vec<i32>) -> WhereParam {
            WhereParam::Likes(_prisma::read_filters::IntListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntListFilter,
            Likes,
            {
                fn has(_: Option<i32>) -> Has;
                fn has_every(_: Vec<i32>) -> HasEvery;
                fn has_some(_: Vec<i32>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<i32>) -> SetParam {
            SetParam::PushLikes(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Likes(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Likes(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "businesses";
        pub struct Fetch(pub businesses::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Businesses(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(businesses::UniqueArgs::new())
        }
        pub struct Connect(businesses::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: businesses::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesIs(value)
        }
        pub fn is_not(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesIsNot(value)
        }
        pub enum Include {
            Select(Vec<businesses::SelectParam>),
            Include(Vec<businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Businesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("businesses", None, [], selections)
            }
            pub fn select(nested_selections: Vec<businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<businesses::SelectParam>),
            Include(Vec<businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Businesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("businesses", None, [], selections)
            }
            pub fn select(nested_selections: Vec<businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Users(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Users(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Users(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod replies_on_feedbacks {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "replies_on_feedbacks";
        pub struct Fetch(pub replies_on_feedbacks::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<replies_on_feedbacks::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: replies_on_feedbacks::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: replies_on_feedbacks::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::RepliesOnFeedbacks(v)
            }
        }
        pub fn fetch(params: Vec<replies_on_feedbacks::WhereParam>) -> Fetch {
            Fetch(replies_on_feedbacks::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<replies_on_feedbacks::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectRepliesOnFeedbacks(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<replies_on_feedbacks::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<replies_on_feedbacks::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectRepliesOnFeedbacks(params)
        }
        pub fn set(params: Vec<replies_on_feedbacks::UniqueWhereParam>) -> SetParam {
            SetParam::SetRepliesOnFeedbacks(params)
        }
        pub fn some(value: Vec<replies_on_feedbacks::WhereParam>) -> WhereParam {
            WhereParam::RepliesOnFeedbacksSome(value)
        }
        pub fn every(value: Vec<replies_on_feedbacks::WhereParam>) -> WhereParam {
            WhereParam::RepliesOnFeedbacksEvery(value)
        }
        pub fn none(value: Vec<replies_on_feedbacks::WhereParam>) -> WhereParam {
            WhereParam::RepliesOnFeedbacksNone(value)
        }
        pub enum Include {
            Select(
                replies_on_feedbacks::ManyArgs,
                Vec<replies_on_feedbacks::SelectParam>,
            ),
            Include(
                replies_on_feedbacks::ManyArgs,
                Vec<replies_on_feedbacks::IncludeParam>,
            ),
            Fetch(replies_on_feedbacks::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RepliesOnFeedbacks(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < replies_on_feedbacks :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < replies_on_feedbacks :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: replies_on_feedbacks::ManyArgs,
                nested_selections: Vec<replies_on_feedbacks::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: replies_on_feedbacks::ManyArgs,
                nested_selections: Vec<replies_on_feedbacks::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                replies_on_feedbacks::ManyArgs,
                Vec<replies_on_feedbacks::SelectParam>,
            ),
            Include(
                replies_on_feedbacks::ManyArgs,
                Vec<replies_on_feedbacks::IncludeParam>,
            ),
            Fetch(replies_on_feedbacks::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RepliesOnFeedbacks(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < replies_on_feedbacks :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: replies_on_feedbacks::ManyArgs,
                nested_selections: Vec<replies_on_feedbacks::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: replies_on_feedbacks::ManyArgs,
                nested_selections: Vec<replies_on_feedbacks::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        text: String,
        businesses: super::businesses::UniqueWhereParam,
        users: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        super::businesses::UniqueWhereParam,
        super::users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (text, businesses, users, _params)
    }
    pub fn create_unchecked(
        business_id: i32,
        user_id: i32,
        text: String,
        _params: Vec<SetParam>,
    ) -> (i32, i32, String, Vec<SetParam>) {
        (business_id, user_id, text, _params)
    }
    #[macro_export]
    macro_rules ! _select_feedbacks_on_businesses { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: feedbacks_on_businesses :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: feedbacks_on_businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: feedbacks_on_businesses :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: feedbacks_on_businesses :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: feedbacks_on_businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: feedbacks_on_businesses :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , business_id , user_id , text , urls , dislikes , likes , businesses , users , replies_on_feedbacks } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: feedbacks_on_businesses :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: feedbacks_on_businesses :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: feedbacks_on_businesses :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: feedbacks_on_businesses :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: feedbacks_on_businesses :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: feedbacks_on_businesses :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "business_id" , "user_id" , "text" , "urls" , "dislikes" , "likes" , "businesses" , "users" , "replies_on_feedbacks"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: feedbacks_on_businesses :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; business_id) => { i32 } ; (@ field_type ; user_id) => { i32 } ; (@ field_type ; text) => { String } ; (@ field_type ; urls) => { Vec < String > } ; (@ field_type ; dislikes) => { Vec < i32 > } ; (@ field_type ; likes) => { Vec < i32 > } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { businesses :: Data } ; (@ field_type ; businesses) => { crate :: prisma :: businesses :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; replies_on_feedbacks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < replies_on_feedbacks :: Data > } ; (@ field_type ; replies_on_feedbacks) => { Vec < crate :: prisma :: replies_on_feedbacks :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "FeedbacksOnBusinesses" , available relations are "id, created_at, business_id, user_id, text, urls, dislikes, likes, businesses, users, replies_on_feedbacks")) } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; replies_on_feedbacks : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: replies_on_feedbacks :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: created_at :: Select) } ; (@ selection_field_to_selection_param ; business_id) => { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: business_id :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: user_id :: Select) } ; (@ selection_field_to_selection_param ; text) => { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: text :: Select) } ; (@ selection_field_to_selection_param ; urls) => { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: urls :: Select) } ; (@ selection_field_to_selection_param ; dislikes) => { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: dislikes :: Select) } ; (@ selection_field_to_selection_param ; likes) => { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: likes :: Select) } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: businesses :: Select :: $ selection_mode (crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: businesses :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: users :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: users :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; replies_on_feedbacks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: replies_on_feedbacks :: Select :: $ selection_mode (crate :: prisma :: replies_on_feedbacks :: ManyArgs :: new (crate :: prisma :: replies_on_feedbacks :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: replies_on_feedbacks :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; replies_on_feedbacks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: feedbacks_on_businesses :: SelectParam > :: into (crate :: prisma :: feedbacks_on_businesses :: replies_on_feedbacks :: Select :: Fetch (crate :: prisma :: replies_on_feedbacks :: ManyArgs :: new (crate :: prisma :: replies_on_feedbacks :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: feedbacks_on_businesses :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; business_id) => { "business_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; text) => { "text" } ; (@ field_serde_name ; urls) => { "urls" } ; (@ field_serde_name ; dislikes) => { "dislikes" } ; (@ field_serde_name ; likes) => { "likes" } ; (@ field_serde_name ; businesses) => { "businesses" } ; (@ field_serde_name ; users) => { "users" } ; (@ field_serde_name ; replies_on_feedbacks) => { "replies_on_feedbacks" } ; }
    pub use _select_feedbacks_on_businesses as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        BusinessId(business_id::Select),
        UserId(user_id::Select),
        Text(text::Select),
        Urls(urls::Select),
        Dislikes(dislikes::Select),
        Likes(likes::Select),
        Businesses(businesses::Select),
        Users(users::Select),
        RepliesOnFeedbacks(replies_on_feedbacks::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::BusinessId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::Text(data) => data.to_selection(),
                Self::Urls(data) => data.to_selection(),
                Self::Dislikes(data) => data.to_selection(),
                Self::Likes(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
                Self::RepliesOnFeedbacks(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_feedbacks_on_businesses { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: feedbacks_on_businesses :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: feedbacks_on_businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: feedbacks_on_businesses :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: feedbacks_on_businesses :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: feedbacks_on_businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: feedbacks_on_businesses :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { businesses , users , replies_on_feedbacks } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub business_id : i32 , pub user_id : i32 , pub text : String , pub urls : Vec < String > , pub dislikes : Vec < i32 > , pub likes : Vec < i32 > , $ (pub $ field : crate :: prisma :: feedbacks_on_businesses :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (business_id) , stringify ! (user_id) , stringify ! (text) , stringify ! (urls) , stringify ! (dislikes) , stringify ! (likes)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: feedbacks_on_businesses :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: feedbacks_on_businesses :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: feedbacks_on_businesses :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: feedbacks_on_businesses :: business_id :: NAME , & self . business_id) ? ; state . serialize_field (crate :: prisma :: feedbacks_on_businesses :: user_id :: NAME , & self . user_id) ? ; state . serialize_field (crate :: prisma :: feedbacks_on_businesses :: text :: NAME , & self . text) ? ; state . serialize_field (crate :: prisma :: feedbacks_on_businesses :: urls :: NAME , & self . urls) ? ; state . serialize_field (crate :: prisma :: feedbacks_on_businesses :: dislikes :: NAME , & self . dislikes) ? ; state . serialize_field (crate :: prisma :: feedbacks_on_businesses :: likes :: NAME , & self . likes) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , business_id , user_id , text , urls , dislikes , likes } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: feedbacks_on_businesses :: $ field :: NAME) , + , crate :: prisma :: feedbacks_on_businesses :: id :: NAME , crate :: prisma :: feedbacks_on_businesses :: created_at :: NAME , crate :: prisma :: feedbacks_on_businesses :: business_id :: NAME , crate :: prisma :: feedbacks_on_businesses :: user_id :: NAME , crate :: prisma :: feedbacks_on_businesses :: text :: NAME , crate :: prisma :: feedbacks_on_businesses :: urls :: NAME , crate :: prisma :: feedbacks_on_businesses :: dislikes :: NAME , crate :: prisma :: feedbacks_on_businesses :: likes :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: feedbacks_on_businesses :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: feedbacks_on_businesses :: id :: NAME => Ok (Field :: id) , crate :: prisma :: feedbacks_on_businesses :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: feedbacks_on_businesses :: business_id :: NAME => Ok (Field :: business_id) , crate :: prisma :: feedbacks_on_businesses :: user_id :: NAME => Ok (Field :: user_id) , crate :: prisma :: feedbacks_on_businesses :: text :: NAME => Ok (Field :: text) , crate :: prisma :: feedbacks_on_businesses :: urls :: NAME => Ok (Field :: urls) , crate :: prisma :: feedbacks_on_businesses :: dislikes :: NAME => Ok (Field :: dislikes) , crate :: prisma :: feedbacks_on_businesses :: likes :: NAME => Ok (Field :: likes) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut business_id = None ; let mut user_id = None ; let mut text = None ; let mut urls = None ; let mut dislikes = None ; let mut likes = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: feedbacks_on_businesses :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: feedbacks_on_businesses :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: business_id => { if business_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: feedbacks_on_businesses :: business_id :: NAME)) ; } business_id = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: feedbacks_on_businesses :: user_id :: NAME)) ; } user_id = Some (map . next_value () ?) ; } Field :: text => { if text . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: feedbacks_on_businesses :: text :: NAME)) ; } text = Some (map . next_value () ?) ; } Field :: urls => { if urls . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: feedbacks_on_businesses :: urls :: NAME)) ; } urls = Some (map . next_value () ?) ; } Field :: dislikes => { if dislikes . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: feedbacks_on_businesses :: dislikes :: NAME)) ; } dislikes = Some (map . next_value () ?) ; } Field :: likes => { if likes . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: feedbacks_on_businesses :: likes :: NAME)) ; } likes = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: feedbacks_on_businesses :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: feedbacks_on_businesses :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: feedbacks_on_businesses :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: feedbacks_on_businesses :: created_at :: NAME)) ? ; let business_id = business_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: feedbacks_on_businesses :: business_id :: NAME)) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: feedbacks_on_businesses :: user_id :: NAME)) ? ; let text = text . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: feedbacks_on_businesses :: text :: NAME)) ? ; let urls = urls . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: feedbacks_on_businesses :: urls :: NAME)) ? ; let dislikes = dislikes . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: feedbacks_on_businesses :: dislikes :: NAME)) ? ; let likes = likes . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: feedbacks_on_businesses :: likes :: NAME)) ? ; Ok (Data { id , created_at , business_id , user_id , text , urls , dislikes , likes , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "business_id" , "user_id" , "text" , "urls" , "dislikes" , "likes" , "businesses" , "users" , "replies_on_feedbacks"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: feedbacks_on_businesses :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { businesses :: Data } ; (@ field_type ; businesses) => { crate :: prisma :: businesses :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; replies_on_feedbacks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < replies_on_feedbacks :: Data > } ; (@ field_type ; replies_on_feedbacks) => { Vec < crate :: prisma :: replies_on_feedbacks :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "FeedbacksOnBusinesses" , available relations are "businesses, users, replies_on_feedbacks")) } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; replies_on_feedbacks : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: replies_on_feedbacks :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: feedbacks_on_businesses :: IncludeParam > :: into (crate :: prisma :: feedbacks_on_businesses :: businesses :: Include :: $ selection_mode (crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: feedbacks_on_businesses :: IncludeParam > :: into (crate :: prisma :: feedbacks_on_businesses :: businesses :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: feedbacks_on_businesses :: IncludeParam > :: into (crate :: prisma :: feedbacks_on_businesses :: users :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: feedbacks_on_businesses :: IncludeParam > :: into (crate :: prisma :: feedbacks_on_businesses :: users :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; replies_on_feedbacks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: feedbacks_on_businesses :: IncludeParam > :: into (crate :: prisma :: feedbacks_on_businesses :: replies_on_feedbacks :: Include :: $ selection_mode (crate :: prisma :: replies_on_feedbacks :: ManyArgs :: new (crate :: prisma :: replies_on_feedbacks :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: replies_on_feedbacks :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; replies_on_feedbacks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: feedbacks_on_businesses :: IncludeParam > :: into (crate :: prisma :: feedbacks_on_businesses :: replies_on_feedbacks :: Include :: Fetch (crate :: prisma :: replies_on_feedbacks :: ManyArgs :: new (crate :: prisma :: replies_on_feedbacks :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: feedbacks_on_businesses :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; business_id) => { "business_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; text) => { "text" } ; (@ field_serde_name ; urls) => { "urls" } ; (@ field_serde_name ; dislikes) => { "dislikes" } ; (@ field_serde_name ; likes) => { "likes" } ; (@ field_serde_name ; businesses) => { "businesses" } ; (@ field_serde_name ; users) => { "users" } ; (@ field_serde_name ; replies_on_feedbacks) => { "replies_on_feedbacks" } ; }
    pub use _include_feedbacks_on_businesses as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        BusinessId(business_id::Include),
        UserId(user_id::Include),
        Text(text::Include),
        Urls(urls::Include),
        Dislikes(dislikes::Include),
        Likes(likes::Include),
        Businesses(businesses::Include),
        Users(users::Include),
        RepliesOnFeedbacks(replies_on_feedbacks::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::BusinessId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::Text(data) => data.to_selection(),
                Self::Urls(data) => data.to_selection(),
                Self::Dislikes(data) => data.to_selection(),
                Self::Likes(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
                Self::RepliesOnFeedbacks(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_feedbacks_on_businesses { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: feedbacks_on_businesses struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "business_id")] pub business_id : i32 , # [serde (rename = "user_id")] pub user_id : i32 , # [serde (rename = "text")] pub text : String , # [serde (rename = "urls")] pub urls : Vec < String > , # [serde (rename = "dislikes")] pub dislikes : Vec < i32 > , # [serde (rename = "likes")] pub likes : Vec < i32 > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_feedbacks_on_businesses as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "business_id")]
        pub business_id: i32,
        #[serde(rename = "user_id")]
        pub user_id: i32,
        #[serde(rename = "text")]
        pub text: String,
        #[serde(rename = "urls")]
        pub urls: Vec<String>,
        #[serde(rename = "dislikes")]
        pub dislikes: Vec<i32>,
        #[serde(rename = "likes")]
        pub likes: Vec<i32>,
        #[serde(rename = "businesses")]
        pub businesses: Option<Box<super::businesses::Data>>,
        #[serde(rename = "users")]
        pub users: Option<Box<super::users::Data>>,
        #[serde(rename = "replies_on_feedbacks")]
        pub replies_on_feedbacks: Option<Vec<super::replies_on_feedbacks::Data>>,
    }
    impl Data {
        pub fn businesses(
            &self,
        ) -> Result<&super::businesses::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.businesses
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(businesses),
                ))
                .map(|v| v.as_ref())
        }
        pub fn users(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users),
                ))
                .map(|v| v.as_ref())
        }
        pub fn replies_on_feedbacks(
            &self,
        ) -> Result<
            &Vec<super::replies_on_feedbacks::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.replies_on_feedbacks.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    replies_on_feedbacks
                )),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Businesses(super::businesses::UniqueArgs),
        Users(super::users::UniqueArgs),
        RepliesOnFeedbacks(super::replies_on_feedbacks::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Businesses(args) => {
                    let mut selections = < super :: businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(businesses::NAME, None, [], selections)
                }
                Self::Users(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(users::NAME, None, [], selections)
                }
                Self::RepliesOnFeedbacks(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: replies_on_feedbacks :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        replies_on_feedbacks::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetBusinessId(i32),
        IncrementBusinessId(i32),
        DecrementBusinessId(i32),
        MultiplyBusinessId(i32),
        DivideBusinessId(i32),
        SetUserId(i32),
        IncrementUserId(i32),
        DecrementUserId(i32),
        MultiplyUserId(i32),
        DivideUserId(i32),
        SetText(String),
        SetUrls(Vec<String>),
        PushUrls(Vec<String>),
        SetDislikes(Vec<i32>),
        PushDislikes(Vec<i32>),
        SetLikes(Vec<i32>),
        PushLikes(Vec<i32>),
        ConnectBusinesses(super::businesses::UniqueWhereParam),
        ConnectUsers(super::users::UniqueWhereParam),
        ConnectRepliesOnFeedbacks(Vec<super::replies_on_feedbacks::UniqueWhereParam>),
        DisconnectRepliesOnFeedbacks(Vec<super::replies_on_feedbacks::UniqueWhereParam>),
        SetRepliesOnFeedbacks(Vec<super::replies_on_feedbacks::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetText(value) => (
                    text::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetUrls(value) => (
                    urls::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .collect(),
                    ),
                ),
                SetParam::PushUrls(value) => (
                    urls::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetDislikes(value) => (
                    dislikes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .collect(),
                    ),
                ),
                SetParam::PushDislikes(value) => (
                    dislikes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetLikes(value) => (
                    likes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .collect(),
                    ),
                ),
                SetParam::PushLikes(value) => (
                    likes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectBusinesses(where_param) => (
                    businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUsers(where_param) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectRepliesOnFeedbacks(where_params) => (
                    replies_on_feedbacks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::replies_on_feedbacks::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectRepliesOnFeedbacks(where_params) => (
                    replies_on_feedbacks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::replies_on_feedbacks::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetRepliesOnFeedbacks(where_params) => (
                    replies_on_feedbacks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::replies_on_feedbacks::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        BusinessId(i32),
        UserId(i32),
        Text(String),
        Urls(Vec<String>),
        Dislikes(Vec<i32>),
        Likes(Vec<i32>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::BusinessId(value) => Self::SetBusinessId(value),
                UncheckedSetParam::UserId(value) => Self::SetUserId(value),
                UncheckedSetParam::Text(value) => Self::SetText(value),
                UncheckedSetParam::Urls(value) => Self::SetUrls(value),
                UncheckedSetParam::Dislikes(value) => Self::SetDislikes(value),
                UncheckedSetParam::Likes(value) => Self::SetLikes(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        BusinessId(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
        Text(::prisma_client_rust::Direction),
        Urls(::prisma_client_rust::Direction),
        Dislikes(::prisma_client_rust::Direction),
        Likes(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::BusinessId(direction) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Text(direction) => (
                    text::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Urls(direction) => (
                    urls::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Dislikes(direction) => (
                    dislikes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Likes(direction) => (
                    likes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        BusinessId(_prisma::read_filters::IntFilter),
        UserId(_prisma::read_filters::IntFilter),
        Text(_prisma::read_filters::StringFilter),
        Urls(_prisma::read_filters::StringListFilter),
        Dislikes(_prisma::read_filters::IntListFilter),
        Likes(_prisma::read_filters::IntListFilter),
        BusinessesIs(Vec<super::businesses::WhereParam>),
        BusinessesIsNot(Vec<super::businesses::WhereParam>),
        UsersIs(Vec<super::users::WhereParam>),
        UsersIsNot(Vec<super::users::WhereParam>),
        RepliesOnFeedbacksSome(Vec<super::replies_on_feedbacks::WhereParam>),
        RepliesOnFeedbacksEvery(Vec<super::replies_on_feedbacks::WhereParam>),
        RepliesOnFeedbacksNone(Vec<super::replies_on_feedbacks::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::BusinessId(value) => (business_id::NAME, value.into()),
                Self::UserId(value) => (user_id::NAME, value.into()),
                Self::Text(value) => (text::NAME, value.into()),
                Self::Urls(value) => (urls::NAME, value.into()),
                Self::Dislikes(value) => (dislikes::NAME, value.into()),
                Self::Likes(value) => (likes::NAME, value.into()),
                Self::BusinessesIs(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BusinessesIsNot(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIs(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIsNot(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepliesOnFeedbacksSome(where_params) => (
                    replies_on_feedbacks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepliesOnFeedbacksEvery(where_params) => (
                    replies_on_feedbacks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepliesOnFeedbacksNone(where_params) => (
                    replies_on_feedbacks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(business_id::NAME),
                ::prisma_client_rust::sel(user_id::NAME),
                ::prisma_client_rust::sel(text::NAME),
                ::prisma_client_rust::sel(urls::NAME),
                ::prisma_client_rust::sel(dislikes::NAME),
                ::prisma_client_rust::sel(likes::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            text: String,
            businesses: super::businesses::UniqueWhereParam,
            users: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                text::set(text),
                businesses::connect(businesses),
                users::connect(users),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            business_id: i32,
            user_id: i32,
            text: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                business_id::set(business_id),
                user_id::set(user_id),
                text::set(text),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(business_id, user_id, text, mut _params)| {
                    _params.extend([
                        business_id::set(business_id),
                        user_id::set(user_id),
                        text::set(text),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (text, businesses, users, mut _params): (
                String,
                super::businesses::UniqueWhereParam,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                text::set(text),
                businesses::connect(businesses),
                users::connect(users),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod followers_on_businesses {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "followers_on_businesses";
    pub mod follower_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "follower_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFollowerId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FollowerId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::FollowerId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::FollowerId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            FollowerId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementFollowerId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementFollowerId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyFollowerId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideFollowerId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FollowerId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FollowerId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod business_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "business_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBusinessId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BusinessId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BusinessId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::BusinessId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            BusinessId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementBusinessId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementBusinessId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyBusinessId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideBusinessId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BusinessId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BusinessId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "businesses";
        pub struct Fetch(pub businesses::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Businesses(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(businesses::UniqueArgs::new())
        }
        pub struct Connect(businesses::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: businesses::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesIs(value)
        }
        pub fn is_not(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesIsNot(value)
        }
        pub enum Include {
            Select(Vec<businesses::SelectParam>),
            Include(Vec<businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Businesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("businesses", None, [], selections)
            }
            pub fn select(nested_selections: Vec<businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<businesses::SelectParam>),
            Include(Vec<businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Businesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("businesses", None, [], selections)
            }
            pub fn select(nested_selections: Vec<businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Users(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Users(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Users(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn follower_id_business_id<T: From<UniqueWhereParam>>(
        follower_id: i32,
        business_id: i32,
    ) -> T {
        UniqueWhereParam::FollowerIdBusinessIdEquals(follower_id, business_id).into()
    }
    pub fn create(
        businesses: super::businesses::UniqueWhereParam,
        users: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        super::businesses::UniqueWhereParam,
        super::users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (businesses, users, _params)
    }
    pub fn create_unchecked(
        follower_id: i32,
        business_id: i32,
        _params: Vec<SetParam>,
    ) -> (i32, i32, Vec<SetParam>) {
        (follower_id, business_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_followers_on_businesses { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: followers_on_businesses :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: followers_on_businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: followers_on_businesses :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: followers_on_businesses :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: followers_on_businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: followers_on_businesses :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { follower_id , business_id , businesses , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: followers_on_businesses :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: followers_on_businesses :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: followers_on_businesses :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: followers_on_businesses :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: followers_on_businesses :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: followers_on_businesses :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["follower_id" , "business_id" , "businesses" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: followers_on_businesses :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; follower_id) => { i32 } ; (@ field_type ; business_id) => { i32 } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { businesses :: Data } ; (@ field_type ; businesses) => { crate :: prisma :: businesses :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "FollowersOnBusinesses" , available relations are "follower_id, business_id, businesses, users")) } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; follower_id) => { Into :: < crate :: prisma :: followers_on_businesses :: SelectParam > :: into (crate :: prisma :: followers_on_businesses :: follower_id :: Select) } ; (@ selection_field_to_selection_param ; business_id) => { Into :: < crate :: prisma :: followers_on_businesses :: SelectParam > :: into (crate :: prisma :: followers_on_businesses :: business_id :: Select) } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: followers_on_businesses :: SelectParam > :: into (crate :: prisma :: followers_on_businesses :: businesses :: Select :: $ selection_mode (crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: followers_on_businesses :: SelectParam > :: into (crate :: prisma :: followers_on_businesses :: businesses :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: followers_on_businesses :: SelectParam > :: into (crate :: prisma :: followers_on_businesses :: users :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: followers_on_businesses :: SelectParam > :: into (crate :: prisma :: followers_on_businesses :: users :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: followers_on_businesses :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; follower_id) => { "follower_id" } ; (@ field_serde_name ; business_id) => { "business_id" } ; (@ field_serde_name ; businesses) => { "businesses" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _select_followers_on_businesses as select;
    pub enum SelectParam {
        FollowerId(follower_id::Select),
        BusinessId(business_id::Select),
        Businesses(businesses::Select),
        Users(users::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::FollowerId(data) => data.to_selection(),
                Self::BusinessId(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_followers_on_businesses { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: followers_on_businesses :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: followers_on_businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: followers_on_businesses :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: followers_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: followers_on_businesses :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: followers_on_businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: followers_on_businesses :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: followers_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { businesses , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub follower_id : i32 , pub business_id : i32 , $ (pub $ field : crate :: prisma :: followers_on_businesses :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (follower_id) , stringify ! (business_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: followers_on_businesses :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: followers_on_businesses :: follower_id :: NAME , & self . follower_id) ? ; state . serialize_field (crate :: prisma :: followers_on_businesses :: business_id :: NAME , & self . business_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , follower_id , business_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: followers_on_businesses :: $ field :: NAME) , + , crate :: prisma :: followers_on_businesses :: follower_id :: NAME , crate :: prisma :: followers_on_businesses :: business_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: followers_on_businesses :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: followers_on_businesses :: follower_id :: NAME => Ok (Field :: follower_id) , crate :: prisma :: followers_on_businesses :: business_id :: NAME => Ok (Field :: business_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut follower_id = None ; let mut business_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: follower_id => { if follower_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: followers_on_businesses :: follower_id :: NAME)) ; } follower_id = Some (map . next_value () ?) ; } Field :: business_id => { if business_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: followers_on_businesses :: business_id :: NAME)) ; } business_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: followers_on_businesses :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: followers_on_businesses :: $ field :: NAME)) ? ;) * let follower_id = follower_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: followers_on_businesses :: follower_id :: NAME)) ? ; let business_id = business_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: followers_on_businesses :: business_id :: NAME)) ? ; Ok (Data { follower_id , business_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["follower_id" , "business_id" , "businesses" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: followers_on_businesses :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { businesses :: Data } ; (@ field_type ; businesses) => { crate :: prisma :: businesses :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "FollowersOnBusinesses" , available relations are "businesses, users")) } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: followers_on_businesses :: IncludeParam > :: into (crate :: prisma :: followers_on_businesses :: businesses :: Include :: $ selection_mode (crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: followers_on_businesses :: IncludeParam > :: into (crate :: prisma :: followers_on_businesses :: businesses :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: followers_on_businesses :: IncludeParam > :: into (crate :: prisma :: followers_on_businesses :: users :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: followers_on_businesses :: IncludeParam > :: into (crate :: prisma :: followers_on_businesses :: users :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: followers_on_businesses :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; follower_id) => { "follower_id" } ; (@ field_serde_name ; business_id) => { "business_id" } ; (@ field_serde_name ; businesses) => { "businesses" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _include_followers_on_businesses as include;
    pub enum IncludeParam {
        FollowerId(follower_id::Include),
        BusinessId(business_id::Include),
        Businesses(businesses::Include),
        Users(users::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::FollowerId(data) => data.to_selection(),
                Self::BusinessId(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_followers_on_businesses { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: followers_on_businesses struct $ struct_name { # [serde (rename = "follower_id")] pub follower_id : i32 , # [serde (rename = "business_id")] pub business_id : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_followers_on_businesses as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "follower_id")]
        pub follower_id: i32,
        #[serde(rename = "business_id")]
        pub business_id: i32,
        #[serde(rename = "businesses")]
        pub businesses: Option<Box<super::businesses::Data>>,
        #[serde(rename = "users")]
        pub users: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn businesses(
            &self,
        ) -> Result<&super::businesses::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.businesses
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(businesses),
                ))
                .map(|v| v.as_ref())
        }
        pub fn users(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Businesses(super::businesses::UniqueArgs),
        Users(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Businesses(args) => {
                    let mut selections = < super :: businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(businesses::NAME, None, [], selections)
                }
                Self::Users(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(users::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetFollowerId(i32),
        IncrementFollowerId(i32),
        DecrementFollowerId(i32),
        MultiplyFollowerId(i32),
        DivideFollowerId(i32),
        SetBusinessId(i32),
        IncrementBusinessId(i32),
        DecrementBusinessId(i32),
        MultiplyBusinessId(i32),
        DivideBusinessId(i32),
        ConnectBusinesses(super::businesses::UniqueWhereParam),
        ConnectUsers(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetFollowerId(value) => (
                    follower_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementFollowerId(value) => (
                    follower_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementFollowerId(value) => (
                    follower_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyFollowerId(value) => (
                    follower_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideFollowerId(value) => (
                    follower_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectBusinesses(where_param) => (
                    businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUsers(where_param) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        FollowerId(i32),
        BusinessId(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::FollowerId(value) => Self::SetFollowerId(value),
                UncheckedSetParam::BusinessId(value) => Self::SetBusinessId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        FollowerId(::prisma_client_rust::Direction),
        BusinessId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::FollowerId(direction) => (
                    follower_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::BusinessId(direction) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        FollowerIdBusinessIdEquals(i32, i32),
        FollowerId(_prisma::read_filters::IntFilter),
        BusinessId(_prisma::read_filters::IntFilter),
        BusinessesIs(Vec<super::businesses::WhereParam>),
        BusinessesIsNot(Vec<super::businesses::WhereParam>),
        UsersIs(Vec<super::users::WhereParam>),
        UsersIsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::FollowerIdBusinessIdEquals(follower_id, business_id) => (
                    "follower_id_business_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            follower_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(follower_id as i64),
                        ),
                        (
                            business_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(business_id as i64),
                        ),
                    ]),
                ),
                Self::FollowerId(value) => (follower_id::NAME, value.into()),
                Self::BusinessId(value) => (business_id::NAME, value.into()),
                Self::BusinessesIs(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BusinessesIsNot(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIs(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIsNot(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        FollowerIdBusinessIdEquals(i32, i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::FollowerIdBusinessIdEquals(follower_id, business_id) => {
                    Self::FollowerIdBusinessIdEquals(follower_id, business_id)
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(follower_id::NAME),
                ::prisma_client_rust::sel(business_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            businesses: super::businesses::UniqueWhereParam,
            users: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([businesses::connect(businesses), users::connect(users)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            follower_id: i32,
            business_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([follower_id::set(follower_id), business_id::set(business_id)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(follower_id, business_id, mut _params)| {
                    _params.extend([follower_id::set(follower_id), business_id::set(business_id)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (businesses, users, mut _params): (
                super::businesses::UniqueWhereParam,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([businesses::connect(businesses), users::connect(users)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod medias {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "medias";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod url {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "url";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUrl(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Url(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Url(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Url, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Url(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Url(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod business_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "business_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBusinessId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BusinessId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BusinessId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::BusinessId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            BusinessId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementBusinessId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementBusinessId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyBusinessId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideBusinessId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BusinessId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BusinessId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod path {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "path";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPath(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Path(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Path(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Path(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Path,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Path(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Path(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod source {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "source";
        pub struct Set(pub self::MediaSoucres);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSource(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Source(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::MediaSoucres) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Source(direction)
        }
        pub fn equals(value: self::MediaSoucres) -> WhereParam {
            WhereParam::Source(_prisma::read_filters::MediaSoucresFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::MediaSoucresFilter,
            Source,
            {
                fn in_vec(_: Vec<super::super::MediaSoucres>) -> InVec;
                fn not_in_vec(_: Vec<super::super::MediaSoucres>) -> NotInVec;
                fn not(_: super::super::MediaSoucres) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Source(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Source(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "businesses";
        pub struct Fetch(pub businesses::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Businesses(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(businesses::UniqueArgs::new())
        }
        pub struct Connect(businesses::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: businesses::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesIs(value)
        }
        pub fn is_not(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesIsNot(value)
        }
        pub enum Include {
            Select(Vec<businesses::SelectParam>),
            Include(Vec<businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Businesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("businesses", None, [], selections)
            }
            pub fn select(nested_selections: Vec<businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<businesses::SelectParam>),
            Include(Vec<businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Businesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("businesses", None, [], selections)
            }
            pub fn select(nested_selections: Vec<businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        url: String,
        source: super::MediaSoucres,
        businesses: super::businesses::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        super::MediaSoucres,
        super::businesses::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (url, source, businesses, _params)
    }
    pub fn create_unchecked(
        url: String,
        business_id: i32,
        source: super::MediaSoucres,
        _params: Vec<SetParam>,
    ) -> (String, i32, super::MediaSoucres, Vec<SetParam>) {
        (url, business_id, source, _params)
    }
    #[macro_export]
    macro_rules ! _select_medias { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: medias :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: medias :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: medias :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: medias :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: medias :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: medias :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , url , business_id , path , source , businesses } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: medias :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: medias :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: medias :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: medias :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: medias :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: medias :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "url" , "business_id" , "path" , "source" , "businesses"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: medias :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; url) => { String } ; (@ field_type ; business_id) => { i32 } ; (@ field_type ; path) => { Option < String > } ; (@ field_type ; source) => { crate :: prisma :: MediaSoucres } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { businesses :: Data } ; (@ field_type ; businesses) => { crate :: prisma :: businesses :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Medias" , available relations are "id, created_at, url, business_id, path, source, businesses")) } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: medias :: SelectParam > :: into (crate :: prisma :: medias :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: medias :: SelectParam > :: into (crate :: prisma :: medias :: created_at :: Select) } ; (@ selection_field_to_selection_param ; url) => { Into :: < crate :: prisma :: medias :: SelectParam > :: into (crate :: prisma :: medias :: url :: Select) } ; (@ selection_field_to_selection_param ; business_id) => { Into :: < crate :: prisma :: medias :: SelectParam > :: into (crate :: prisma :: medias :: business_id :: Select) } ; (@ selection_field_to_selection_param ; path) => { Into :: < crate :: prisma :: medias :: SelectParam > :: into (crate :: prisma :: medias :: path :: Select) } ; (@ selection_field_to_selection_param ; source) => { Into :: < crate :: prisma :: medias :: SelectParam > :: into (crate :: prisma :: medias :: source :: Select) } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: medias :: SelectParam > :: into (crate :: prisma :: medias :: businesses :: Select :: $ selection_mode (crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: medias :: SelectParam > :: into (crate :: prisma :: medias :: businesses :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: medias :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; business_id) => { "business_id" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; businesses) => { "businesses" } ; }
    pub use _select_medias as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        Url(url::Select),
        BusinessId(business_id::Select),
        Path(path::Select),
        Source(source::Select),
        Businesses(businesses::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Url(data) => data.to_selection(),
                Self::BusinessId(data) => data.to_selection(),
                Self::Path(data) => data.to_selection(),
                Self::Source(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_medias { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: medias :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: medias :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: medias :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: medias :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: medias :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: medias :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: medias :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: medias :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { businesses } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub url : String , pub business_id : i32 , pub path : Option < String > , pub source : crate :: prisma :: MediaSoucres , $ (pub $ field : crate :: prisma :: medias :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (url) , stringify ! (business_id) , stringify ! (path) , stringify ! (source)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: medias :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: medias :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: medias :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: medias :: url :: NAME , & self . url) ? ; state . serialize_field (crate :: prisma :: medias :: business_id :: NAME , & self . business_id) ? ; state . serialize_field (crate :: prisma :: medias :: path :: NAME , & self . path) ? ; state . serialize_field (crate :: prisma :: medias :: source :: NAME , & self . source) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , url , business_id , path , source } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: medias :: $ field :: NAME) , + , crate :: prisma :: medias :: id :: NAME , crate :: prisma :: medias :: created_at :: NAME , crate :: prisma :: medias :: url :: NAME , crate :: prisma :: medias :: business_id :: NAME , crate :: prisma :: medias :: path :: NAME , crate :: prisma :: medias :: source :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: medias :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: medias :: id :: NAME => Ok (Field :: id) , crate :: prisma :: medias :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: medias :: url :: NAME => Ok (Field :: url) , crate :: prisma :: medias :: business_id :: NAME => Ok (Field :: business_id) , crate :: prisma :: medias :: path :: NAME => Ok (Field :: path) , crate :: prisma :: medias :: source :: NAME => Ok (Field :: source) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut url = None ; let mut business_id = None ; let mut path = None ; let mut source = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: medias :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: medias :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: url => { if url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: medias :: url :: NAME)) ; } url = Some (map . next_value () ?) ; } Field :: business_id => { if business_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: medias :: business_id :: NAME)) ; } business_id = Some (map . next_value () ?) ; } Field :: path => { if path . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: medias :: path :: NAME)) ; } path = Some (map . next_value () ?) ; } Field :: source => { if source . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: medias :: source :: NAME)) ; } source = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: medias :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: medias :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: medias :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: medias :: created_at :: NAME)) ? ; let url = url . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: medias :: url :: NAME)) ? ; let business_id = business_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: medias :: business_id :: NAME)) ? ; let path = path . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: medias :: path :: NAME)) ? ; let source = source . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: medias :: source :: NAME)) ? ; Ok (Data { id , created_at , url , business_id , path , source , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "url" , "business_id" , "path" , "source" , "businesses"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: medias :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { businesses :: Data } ; (@ field_type ; businesses) => { crate :: prisma :: businesses :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Medias" , available relations are "businesses")) } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: medias :: IncludeParam > :: into (crate :: prisma :: medias :: businesses :: Include :: $ selection_mode (crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: medias :: IncludeParam > :: into (crate :: prisma :: medias :: businesses :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: medias :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; business_id) => { "business_id" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; source) => { "source" } ; (@ field_serde_name ; businesses) => { "businesses" } ; }
    pub use _include_medias as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        Url(url::Include),
        BusinessId(business_id::Include),
        Path(path::Include),
        Source(source::Include),
        Businesses(businesses::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Url(data) => data.to_selection(),
                Self::BusinessId(data) => data.to_selection(),
                Self::Path(data) => data.to_selection(),
                Self::Source(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_medias { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: medias struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "url")] pub url : String , # [serde (rename = "business_id")] pub business_id : i32 , # [serde (rename = "path")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub path : Option < String > , # [serde (rename = "source")] pub source : crate :: prisma :: MediaSoucres } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_medias as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "url")]
        pub url: String,
        #[serde(rename = "business_id")]
        pub business_id: i32,
        #[serde(rename = "path")]
        pub path: Option<String>,
        #[serde(rename = "source")]
        pub source: super::MediaSoucres,
        #[serde(rename = "businesses")]
        pub businesses: Option<Box<super::businesses::Data>>,
    }
    impl Data {
        pub fn businesses(
            &self,
        ) -> Result<&super::businesses::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.businesses
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(businesses),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Businesses(super::businesses::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Businesses(args) => {
                    let mut selections = < super :: businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(businesses::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetUrl(String),
        SetBusinessId(i32),
        IncrementBusinessId(i32),
        DecrementBusinessId(i32),
        MultiplyBusinessId(i32),
        DivideBusinessId(i32),
        SetPath(Option<String>),
        SetSource(super::MediaSoucres),
        ConnectBusinesses(super::businesses::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetUrl(value) => (
                    url::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetPath(value) => (
                    path::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetSource(value) => (
                    source::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::ConnectBusinesses(where_param) => (
                    businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        Url(String),
        BusinessId(i32),
        Path(Option<String>),
        Source(super::MediaSoucres),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::Url(value) => Self::SetUrl(value),
                UncheckedSetParam::BusinessId(value) => Self::SetBusinessId(value),
                UncheckedSetParam::Path(value) => Self::SetPath(value),
                UncheckedSetParam::Source(value) => Self::SetSource(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        Url(::prisma_client_rust::Direction),
        BusinessId(::prisma_client_rust::Direction),
        Path(::prisma_client_rust::Direction),
        Source(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Url(direction) => (
                    url::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::BusinessId(direction) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Path(direction) => (
                    path::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Source(direction) => (
                    source::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        Url(_prisma::read_filters::StringFilter),
        BusinessId(_prisma::read_filters::IntFilter),
        Path(_prisma::read_filters::StringNullableFilter),
        Source(_prisma::read_filters::MediaSoucresFilter),
        BusinessesIs(Vec<super::businesses::WhereParam>),
        BusinessesIsNot(Vec<super::businesses::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::Url(value) => (url::NAME, value.into()),
                Self::BusinessId(value) => (business_id::NAME, value.into()),
                Self::Path(value) => (path::NAME, value.into()),
                Self::Source(value) => (source::NAME, value.into()),
                Self::BusinessesIs(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BusinessesIsNot(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(url::NAME),
                ::prisma_client_rust::sel(business_id::NAME),
                ::prisma_client_rust::sel(path::NAME),
                ::prisma_client_rust::sel(source::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            url: String,
            source: super::MediaSoucres,
            businesses: super::businesses::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                url::set(url),
                source::set(source),
                businesses::connect(businesses),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            url: String,
            business_id: i32,
            source: super::MediaSoucres,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                url::set(url),
                business_id::set(business_id),
                source::set(source),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(String, i32, super::MediaSoucres, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(url, business_id, source, mut _params)| {
                    _params.extend([
                        url::set(url),
                        business_id::set(business_id),
                        source::set(source),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (url, source, businesses, mut _params): (
                String,
                super::MediaSoucres,
                super::businesses::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                url::set(url),
                source::set(source),
                businesses::connect(businesses),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod notifications {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "notifications";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod business_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "business_id";
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBusinessId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BusinessId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BusinessId(direction)
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::BusinessId(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            BusinessId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementBusinessId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementBusinessId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyBusinessId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideBusinessId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BusinessId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BusinessId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod review_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "review_id";
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetReviewId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ReviewId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ReviewId(direction)
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::ReviewId(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            ReviewId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementReviewId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementReviewId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyReviewId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideReviewId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ReviewId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ReviewId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod seen {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "seen";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSeen(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Seen(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Seen(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::Seen(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::BoolFilter, Seen, {
            fn not(_: bool) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Seen(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Seen(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod to {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "to";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTo(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::To(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::To(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::To(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, To, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementTo(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementTo(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyTo(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideTo(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::To(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::To(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod from {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "from";
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFrom(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::From(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::From(direction)
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::From(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            From,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementFrom(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementFrom(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyFrom(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideFrom(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::From(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::From(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod meta_data {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "meta_data";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetMetaData(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::MetaData(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::MetaData(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::MetaData(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            MetaData,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::MetaData(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::MetaData(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod r#type {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "type";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetType(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Type(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Type(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Type(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Type, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Type(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Type(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "businesses";
        pub struct Fetch(pub businesses::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Businesses(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(businesses::UniqueArgs::new())
        }
        pub struct Connect(businesses::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: businesses::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectBusinesses
        }
        pub fn is_null() -> WhereParam {
            WhereParam::BusinessesIsNull
        }
        pub fn is(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesIs(value)
        }
        pub fn is_not(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesIsNot(value)
        }
        pub enum Include {
            Select(Vec<businesses::SelectParam>),
            Include(Vec<businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Businesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("businesses", None, [], selections)
            }
            pub fn select(nested_selections: Vec<businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<businesses::SelectParam>),
            Include(Vec<businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Businesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("businesses", None, [], selections)
            }
            pub fn select(nested_selections: Vec<businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users_notifications_from_tousers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users_notifications_fromTousers";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::UsersNotificationsFromTousers(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsersNotificationsFromTousers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectUsersNotificationsFromTousers
        }
        pub fn is_null() -> WhereParam {
            WhereParam::UsersNotificationsFromTousersIsNull
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersNotificationsFromTousersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersNotificationsFromTousersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UsersNotificationsFromTousers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new(
                    "users_notifications_fromTousers",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UsersNotificationsFromTousers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new(
                    "users_notifications_fromTousers",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod reviews {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "reviews";
        pub struct Fetch(pub reviews::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<reviews::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Reviews(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(reviews::UniqueArgs::new())
        }
        pub struct Connect(reviews::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectReviews(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: reviews::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectReviews
        }
        pub fn is_null() -> WhereParam {
            WhereParam::ReviewsIsNull
        }
        pub fn is(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsIs(value)
        }
        pub fn is_not(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsIsNot(value)
        }
        pub enum Include {
            Select(Vec<reviews::SelectParam>),
            Include(Vec<reviews::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Reviews(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("reviews", None, [], selections)
            }
            pub fn select(nested_selections: Vec<reviews::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<reviews::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<reviews::SelectParam>),
            Include(Vec<reviews::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Reviews(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("reviews", None, [], selections)
            }
            pub fn select(nested_selections: Vec<reviews::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<reviews::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users_notifications_to_tousers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users_notifications_toTousers";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::UsersNotificationsToTousers(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsersNotificationsToTousers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersNotificationsToTousersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersNotificationsToTousersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UsersNotificationsToTousers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new(
                    "users_notifications_toTousers",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UsersNotificationsToTousers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new(
                    "users_notifications_toTousers",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        r#type: String,
        users_notifications_to_tousers: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (String, super::users::UniqueWhereParam, Vec<SetParam>) {
        (r#type, users_notifications_to_tousers, _params)
    }
    pub fn create_unchecked(
        to: i32,
        r#type: String,
        _params: Vec<SetParam>,
    ) -> (i32, String, Vec<SetParam>) {
        (to, r#type, _params)
    }
    #[macro_export]
    macro_rules ! _select_notifications { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: notifications :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: notifications :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: notifications :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: notifications :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: notifications :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: notifications :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , business_id , review_id , seen , to , from , meta_data , r#type , businesses , users_notifications_from_tousers , reviews , users_notifications_to_tousers } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: notifications :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: notifications :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: notifications :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: notifications :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: notifications :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: notifications :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "business_id" , "review_id" , "seen" , "to" , "from" , "meta_data" , "type" , "businesses" , "users_notifications_fromTousers" , "reviews" , "users_notifications_toTousers"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: notifications :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; business_id) => { Option < i32 > } ; (@ field_type ; review_id) => { Option < i32 > } ; (@ field_type ; seen) => { bool } ; (@ field_type ; to) => { i32 } ; (@ field_type ; from) => { Option < i32 > } ; (@ field_type ; meta_data) => { Option < String > } ; (@ field_type ; r#type) => { String } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < businesses :: Data > } ; (@ field_type ; businesses) => { Option < crate :: prisma :: businesses :: Data > } ; (@ field_type ; users_notifications_from_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < users_notifications_from_tousers :: Data > } ; (@ field_type ; users_notifications_from_tousers) => { Option < crate :: prisma :: users :: Data > } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < reviews :: Data > } ; (@ field_type ; reviews) => { Option < crate :: prisma :: reviews :: Data > } ; (@ field_type ; users_notifications_to_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { users_notifications_to_tousers :: Data } ; (@ field_type ; users_notifications_to_tousers) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Notifications" , available relations are "id, created_at, business_id, review_id, seen, to, from, meta_data, r#type, businesses, users_notifications_from_tousers, reviews, users_notifications_to_tousers")) } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_notifications_from_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_notifications_to_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: created_at :: Select) } ; (@ selection_field_to_selection_param ; business_id) => { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: business_id :: Select) } ; (@ selection_field_to_selection_param ; review_id) => { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: review_id :: Select) } ; (@ selection_field_to_selection_param ; seen) => { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: seen :: Select) } ; (@ selection_field_to_selection_param ; to) => { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: to :: Select) } ; (@ selection_field_to_selection_param ; from) => { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: from :: Select) } ; (@ selection_field_to_selection_param ; meta_data) => { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: meta_data :: Select) } ; (@ selection_field_to_selection_param ; r#type) => { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: r#type :: Select) } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: businesses :: Select :: $ selection_mode (crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: businesses :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users_notifications_from_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: users_notifications_from_tousers :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_notifications_from_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: users_notifications_from_tousers :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: reviews :: Select :: $ selection_mode (crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: reviews :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users_notifications_to_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: users_notifications_to_tousers :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_notifications_to_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: notifications :: SelectParam > :: into (crate :: prisma :: notifications :: users_notifications_to_tousers :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: notifications :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; business_id) => { "business_id" } ; (@ field_serde_name ; review_id) => { "review_id" } ; (@ field_serde_name ; seen) => { "seen" } ; (@ field_serde_name ; to) => { "to" } ; (@ field_serde_name ; from) => { "from" } ; (@ field_serde_name ; meta_data) => { "meta_data" } ; (@ field_serde_name ; r#type) => { "type" } ; (@ field_serde_name ; businesses) => { "businesses" } ; (@ field_serde_name ; users_notifications_from_tousers) => { "users_notifications_fromTousers" } ; (@ field_serde_name ; reviews) => { "reviews" } ; (@ field_serde_name ; users_notifications_to_tousers) => { "users_notifications_toTousers" } ; }
    pub use _select_notifications as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        BusinessId(business_id::Select),
        ReviewId(review_id::Select),
        Seen(seen::Select),
        To(to::Select),
        From(from::Select),
        MetaData(meta_data::Select),
        Type(r#type::Select),
        Businesses(businesses::Select),
        UsersNotificationsFromTousers(users_notifications_from_tousers::Select),
        Reviews(reviews::Select),
        UsersNotificationsToTousers(users_notifications_to_tousers::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::BusinessId(data) => data.to_selection(),
                Self::ReviewId(data) => data.to_selection(),
                Self::Seen(data) => data.to_selection(),
                Self::To(data) => data.to_selection(),
                Self::From(data) => data.to_selection(),
                Self::MetaData(data) => data.to_selection(),
                Self::Type(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
                Self::UsersNotificationsFromTousers(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
                Self::UsersNotificationsToTousers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_notifications { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: notifications :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: notifications :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: notifications :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: notifications :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: notifications :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: notifications :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { businesses , users_notifications_from_tousers , reviews , users_notifications_to_tousers } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub business_id : Option < i32 > , pub review_id : Option < i32 > , pub seen : bool , pub to : i32 , pub from : Option < i32 > , pub meta_data : Option < String > , pub r#type : String , $ (pub $ field : crate :: prisma :: notifications :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (business_id) , stringify ! (review_id) , stringify ! (seen) , stringify ! (to) , stringify ! (from) , stringify ! (meta_data) , stringify ! (r#type)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: notifications :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: notifications :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: notifications :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: notifications :: business_id :: NAME , & self . business_id) ? ; state . serialize_field (crate :: prisma :: notifications :: review_id :: NAME , & self . review_id) ? ; state . serialize_field (crate :: prisma :: notifications :: seen :: NAME , & self . seen) ? ; state . serialize_field (crate :: prisma :: notifications :: to :: NAME , & self . to) ? ; state . serialize_field (crate :: prisma :: notifications :: from :: NAME , & self . from) ? ; state . serialize_field (crate :: prisma :: notifications :: meta_data :: NAME , & self . meta_data) ? ; state . serialize_field (crate :: prisma :: notifications :: r#type :: NAME , & self . r#type) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , business_id , review_id , seen , to , from , meta_data , r#type } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: notifications :: $ field :: NAME) , + , crate :: prisma :: notifications :: id :: NAME , crate :: prisma :: notifications :: created_at :: NAME , crate :: prisma :: notifications :: business_id :: NAME , crate :: prisma :: notifications :: review_id :: NAME , crate :: prisma :: notifications :: seen :: NAME , crate :: prisma :: notifications :: to :: NAME , crate :: prisma :: notifications :: from :: NAME , crate :: prisma :: notifications :: meta_data :: NAME , crate :: prisma :: notifications :: r#type :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: notifications :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: notifications :: id :: NAME => Ok (Field :: id) , crate :: prisma :: notifications :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: notifications :: business_id :: NAME => Ok (Field :: business_id) , crate :: prisma :: notifications :: review_id :: NAME => Ok (Field :: review_id) , crate :: prisma :: notifications :: seen :: NAME => Ok (Field :: seen) , crate :: prisma :: notifications :: to :: NAME => Ok (Field :: to) , crate :: prisma :: notifications :: from :: NAME => Ok (Field :: from) , crate :: prisma :: notifications :: meta_data :: NAME => Ok (Field :: meta_data) , crate :: prisma :: notifications :: r#type :: NAME => Ok (Field :: r#type) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut business_id = None ; let mut review_id = None ; let mut seen = None ; let mut to = None ; let mut from = None ; let mut meta_data = None ; let mut r#type = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: notifications :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: notifications :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: business_id => { if business_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: notifications :: business_id :: NAME)) ; } business_id = Some (map . next_value () ?) ; } Field :: review_id => { if review_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: notifications :: review_id :: NAME)) ; } review_id = Some (map . next_value () ?) ; } Field :: seen => { if seen . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: notifications :: seen :: NAME)) ; } seen = Some (map . next_value () ?) ; } Field :: to => { if to . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: notifications :: to :: NAME)) ; } to = Some (map . next_value () ?) ; } Field :: from => { if from . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: notifications :: from :: NAME)) ; } from = Some (map . next_value () ?) ; } Field :: meta_data => { if meta_data . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: notifications :: meta_data :: NAME)) ; } meta_data = Some (map . next_value () ?) ; } Field :: r#type => { if r#type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: notifications :: r#type :: NAME)) ; } r#type = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: notifications :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: notifications :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: notifications :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: notifications :: created_at :: NAME)) ? ; let business_id = business_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: notifications :: business_id :: NAME)) ? ; let review_id = review_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: notifications :: review_id :: NAME)) ? ; let seen = seen . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: notifications :: seen :: NAME)) ? ; let to = to . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: notifications :: to :: NAME)) ? ; let from = from . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: notifications :: from :: NAME)) ? ; let meta_data = meta_data . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: notifications :: meta_data :: NAME)) ? ; let r#type = r#type . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: notifications :: r#type :: NAME)) ? ; Ok (Data { id , created_at , business_id , review_id , seen , to , from , meta_data , r#type , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "business_id" , "review_id" , "seen" , "to" , "from" , "meta_data" , "type" , "businesses" , "users_notifications_fromTousers" , "reviews" , "users_notifications_toTousers"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: notifications :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < businesses :: Data > } ; (@ field_type ; businesses) => { Option < crate :: prisma :: businesses :: Data > } ; (@ field_type ; users_notifications_from_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < users_notifications_from_tousers :: Data > } ; (@ field_type ; users_notifications_from_tousers) => { Option < crate :: prisma :: users :: Data > } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < reviews :: Data > } ; (@ field_type ; reviews) => { Option < crate :: prisma :: reviews :: Data > } ; (@ field_type ; users_notifications_to_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { users_notifications_to_tousers :: Data } ; (@ field_type ; users_notifications_to_tousers) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Notifications" , available relations are "businesses, users_notifications_from_tousers, reviews, users_notifications_to_tousers")) } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_notifications_from_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_notifications_to_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: notifications :: IncludeParam > :: into (crate :: prisma :: notifications :: businesses :: Include :: $ selection_mode (crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: notifications :: IncludeParam > :: into (crate :: prisma :: notifications :: businesses :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users_notifications_from_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: notifications :: IncludeParam > :: into (crate :: prisma :: notifications :: users_notifications_from_tousers :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_notifications_from_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: notifications :: IncludeParam > :: into (crate :: prisma :: notifications :: users_notifications_from_tousers :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: notifications :: IncludeParam > :: into (crate :: prisma :: notifications :: reviews :: Include :: $ selection_mode (crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: notifications :: IncludeParam > :: into (crate :: prisma :: notifications :: reviews :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users_notifications_to_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: notifications :: IncludeParam > :: into (crate :: prisma :: notifications :: users_notifications_to_tousers :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_notifications_to_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: notifications :: IncludeParam > :: into (crate :: prisma :: notifications :: users_notifications_to_tousers :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: notifications :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; business_id) => { "business_id" } ; (@ field_serde_name ; review_id) => { "review_id" } ; (@ field_serde_name ; seen) => { "seen" } ; (@ field_serde_name ; to) => { "to" } ; (@ field_serde_name ; from) => { "from" } ; (@ field_serde_name ; meta_data) => { "meta_data" } ; (@ field_serde_name ; r#type) => { "type" } ; (@ field_serde_name ; businesses) => { "businesses" } ; (@ field_serde_name ; users_notifications_from_tousers) => { "users_notifications_fromTousers" } ; (@ field_serde_name ; reviews) => { "reviews" } ; (@ field_serde_name ; users_notifications_to_tousers) => { "users_notifications_toTousers" } ; }
    pub use _include_notifications as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        BusinessId(business_id::Include),
        ReviewId(review_id::Include),
        Seen(seen::Include),
        To(to::Include),
        From(from::Include),
        MetaData(meta_data::Include),
        Type(r#type::Include),
        Businesses(businesses::Include),
        UsersNotificationsFromTousers(users_notifications_from_tousers::Include),
        Reviews(reviews::Include),
        UsersNotificationsToTousers(users_notifications_to_tousers::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::BusinessId(data) => data.to_selection(),
                Self::ReviewId(data) => data.to_selection(),
                Self::Seen(data) => data.to_selection(),
                Self::To(data) => data.to_selection(),
                Self::From(data) => data.to_selection(),
                Self::MetaData(data) => data.to_selection(),
                Self::Type(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
                Self::UsersNotificationsFromTousers(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
                Self::UsersNotificationsToTousers(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_notifications { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: notifications struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "business_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub business_id : Option < i32 > , # [serde (rename = "review_id")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub review_id : Option < i32 > , # [serde (rename = "seen")] pub seen : bool , # [serde (rename = "to")] pub to : i32 , # [serde (rename = "from")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub from : Option < i32 > , # [serde (rename = "meta_data")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub meta_data : Option < String > , # [serde (rename = "type")] pub r#type : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_notifications as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "business_id")]
        pub business_id: Option<i32>,
        #[serde(rename = "review_id")]
        pub review_id: Option<i32>,
        #[serde(rename = "seen")]
        pub seen: bool,
        #[serde(rename = "to")]
        pub to: i32,
        #[serde(rename = "from")]
        pub from: Option<i32>,
        #[serde(rename = "meta_data")]
        pub meta_data: Option<String>,
        #[serde(rename = "type")]
        pub r#type: String,
        #[serde(
            rename = "businesses",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub businesses: Option<Option<Box<super::businesses::Data>>>,
        #[serde(
            rename = "users_notifications_fromTousers",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub users_notifications_from_tousers: Option<Option<Box<super::users::Data>>>,
        #[serde(
            rename = "reviews",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub reviews: Option<Option<Box<super::reviews::Data>>>,
        #[serde(rename = "users_notifications_toTousers")]
        pub users_notifications_to_tousers: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn businesses(
            &self,
        ) -> Result<Option<&super::businesses::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.businesses
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(businesses),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn users_notifications_from_tousers(
            &self,
        ) -> Result<Option<&super::users::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.users_notifications_from_tousers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users_notifications_from_tousers),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn reviews(
            &self,
        ) -> Result<Option<&super::reviews::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.reviews
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(reviews),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn users_notifications_to_tousers(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.users_notifications_to_tousers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users_notifications_to_tousers),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Businesses(super::businesses::UniqueArgs),
        UsersNotificationsFromTousers(super::users::UniqueArgs),
        Reviews(super::reviews::UniqueArgs),
        UsersNotificationsToTousers(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Businesses(args) => {
                    let mut selections = < super :: businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(businesses::NAME, None, [], selections)
                }
                Self::UsersNotificationsFromTousers(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        users_notifications_from_tousers::NAME,
                        None,
                        [],
                        selections,
                    )
                }
                Self::Reviews(args) => {
                    let mut selections = < super :: reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(reviews::NAME, None, [], selections)
                }
                Self::UsersNotificationsToTousers(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        users_notifications_to_tousers::NAME,
                        None,
                        [],
                        selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetBusinessId(Option<i32>),
        IncrementBusinessId(i32),
        DecrementBusinessId(i32),
        MultiplyBusinessId(i32),
        DivideBusinessId(i32),
        SetReviewId(Option<i32>),
        IncrementReviewId(i32),
        DecrementReviewId(i32),
        MultiplyReviewId(i32),
        DivideReviewId(i32),
        SetSeen(bool),
        SetTo(i32),
        IncrementTo(i32),
        DecrementTo(i32),
        MultiplyTo(i32),
        DivideTo(i32),
        SetFrom(Option<i32>),
        IncrementFrom(i32),
        DecrementFrom(i32),
        MultiplyFrom(i32),
        DivideFrom(i32),
        SetMetaData(Option<String>),
        SetType(String),
        ConnectBusinesses(super::businesses::UniqueWhereParam),
        DisconnectBusinesses,
        ConnectUsersNotificationsFromTousers(super::users::UniqueWhereParam),
        DisconnectUsersNotificationsFromTousers,
        ConnectReviews(super::reviews::UniqueWhereParam),
        DisconnectReviews,
        ConnectUsersNotificationsToTousers(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetBusinessId(value) => (
                    business_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetReviewId(value) => (
                    review_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetSeen(value) => (
                    seen::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetTo(value) => (
                    to::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementTo(value) => (
                    to::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementTo(value) => (
                    to::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyTo(value) => (
                    to::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideTo(value) => (
                    to::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetFrom(value) => (
                    from::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementFrom(value) => (
                    from::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementFrom(value) => (
                    from::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyFrom(value) => (
                    from::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideFrom(value) => (
                    from::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetMetaData(value) => (
                    meta_data::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetType(value) => (
                    r#type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectBusinesses(where_param) => (
                    businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectBusinesses => (
                    businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectUsersNotificationsFromTousers(where_param) => (
                    users_notifications_from_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectUsersNotificationsFromTousers => (
                    users_notifications_from_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectReviews(where_param) => (
                    reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectReviews => (
                    reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectUsersNotificationsToTousers(where_param) => (
                    users_notifications_to_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        BusinessId(Option<i32>),
        ReviewId(Option<i32>),
        Seen(bool),
        To(i32),
        From(Option<i32>),
        MetaData(Option<String>),
        Type(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::BusinessId(value) => Self::SetBusinessId(value),
                UncheckedSetParam::ReviewId(value) => Self::SetReviewId(value),
                UncheckedSetParam::Seen(value) => Self::SetSeen(value),
                UncheckedSetParam::To(value) => Self::SetTo(value),
                UncheckedSetParam::From(value) => Self::SetFrom(value),
                UncheckedSetParam::MetaData(value) => Self::SetMetaData(value),
                UncheckedSetParam::Type(value) => Self::SetType(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        BusinessId(::prisma_client_rust::Direction),
        ReviewId(::prisma_client_rust::Direction),
        Seen(::prisma_client_rust::Direction),
        To(::prisma_client_rust::Direction),
        From(::prisma_client_rust::Direction),
        MetaData(::prisma_client_rust::Direction),
        Type(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::BusinessId(direction) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ReviewId(direction) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Seen(direction) => (
                    seen::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::To(direction) => (
                    to::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::From(direction) => (
                    from::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::MetaData(direction) => (
                    meta_data::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Type(direction) => (
                    r#type::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        BusinessId(_prisma::read_filters::IntNullableFilter),
        ReviewId(_prisma::read_filters::IntNullableFilter),
        Seen(_prisma::read_filters::BoolFilter),
        To(_prisma::read_filters::IntFilter),
        From(_prisma::read_filters::IntNullableFilter),
        MetaData(_prisma::read_filters::StringNullableFilter),
        Type(_prisma::read_filters::StringFilter),
        BusinessesIsNull,
        BusinessesIs(Vec<super::businesses::WhereParam>),
        BusinessesIsNot(Vec<super::businesses::WhereParam>),
        UsersNotificationsFromTousersIsNull,
        UsersNotificationsFromTousersIs(Vec<super::users::WhereParam>),
        UsersNotificationsFromTousersIsNot(Vec<super::users::WhereParam>),
        ReviewsIsNull,
        ReviewsIs(Vec<super::reviews::WhereParam>),
        ReviewsIsNot(Vec<super::reviews::WhereParam>),
        UsersNotificationsToTousersIs(Vec<super::users::WhereParam>),
        UsersNotificationsToTousersIsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::BusinessId(value) => (business_id::NAME, value.into()),
                Self::ReviewId(value) => (review_id::NAME, value.into()),
                Self::Seen(value) => (seen::NAME, value.into()),
                Self::To(value) => (to::NAME, value.into()),
                Self::From(value) => (from::NAME, value.into()),
                Self::MetaData(value) => (meta_data::NAME, value.into()),
                Self::Type(value) => (r#type::NAME, value.into()),
                Self::BusinessesIsNull => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::BusinessesIs(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BusinessesIsNot(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersNotificationsFromTousersIsNull => (
                    users_notifications_from_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::UsersNotificationsFromTousersIs(where_params) => (
                    users_notifications_from_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersNotificationsFromTousersIsNot(where_params) => (
                    users_notifications_from_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewsIsNull => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::ReviewsIs(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewsIsNot(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersNotificationsToTousersIs(where_params) => (
                    users_notifications_to_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersNotificationsToTousersIsNot(where_params) => (
                    users_notifications_to_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(business_id::NAME),
                ::prisma_client_rust::sel(review_id::NAME),
                ::prisma_client_rust::sel(seen::NAME),
                ::prisma_client_rust::sel(to::NAME),
                ::prisma_client_rust::sel(from::NAME),
                ::prisma_client_rust::sel(meta_data::NAME),
                ::prisma_client_rust::sel(r#type::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            r#type: String,
            users_notifications_to_tousers: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                r#type::set(r#type),
                users_notifications_to_tousers::connect(users_notifications_to_tousers),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            to: i32,
            r#type: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([to::set(to), r#type::set(r#type)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(to, r#type, mut _params)| {
                    _params.extend([to::set(to), r#type::set(r#type)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (r#type, users_notifications_to_tousers, mut _params): (
                String,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                r#type::set(r#type),
                users_notifications_to_tousers::connect(users_notifications_to_tousers),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod rates_on_businesses {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "rates_on_businesses";
    pub mod valuer_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "valuer_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetValuerId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ValuerId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ValuerId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ValuerId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ValuerId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementValuerId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementValuerId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyValuerId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideValuerId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ValuerId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ValuerId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod business_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "business_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBusinessId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BusinessId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BusinessId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::BusinessId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            BusinessId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementBusinessId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementBusinessId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyBusinessId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideBusinessId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BusinessId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BusinessId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod rating {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "rating";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRating(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Rating(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Rating(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Rating(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Rating, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementRating(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementRating(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyRating(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideRating(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Rating(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Rating(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "businesses";
        pub struct Fetch(pub businesses::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Businesses(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(businesses::UniqueArgs::new())
        }
        pub struct Connect(businesses::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: businesses::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesIs(value)
        }
        pub fn is_not(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesIsNot(value)
        }
        pub enum Include {
            Select(Vec<businesses::SelectParam>),
            Include(Vec<businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Businesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("businesses", None, [], selections)
            }
            pub fn select(nested_selections: Vec<businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<businesses::SelectParam>),
            Include(Vec<businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Businesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("businesses", None, [], selections)
            }
            pub fn select(nested_selections: Vec<businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Users(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Users(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Users(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn valuer_id_business_id<T: From<UniqueWhereParam>>(valuer_id: i32, business_id: i32) -> T {
        UniqueWhereParam::ValuerIdBusinessIdEquals(valuer_id, business_id).into()
    }
    pub fn create(
        rating: i32,
        businesses: super::businesses::UniqueWhereParam,
        users: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        super::businesses::UniqueWhereParam,
        super::users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (rating, businesses, users, _params)
    }
    pub fn create_unchecked(
        valuer_id: i32,
        business_id: i32,
        rating: i32,
        _params: Vec<SetParam>,
    ) -> (i32, i32, i32, Vec<SetParam>) {
        (valuer_id, business_id, rating, _params)
    }
    #[macro_export]
    macro_rules ! _select_rates_on_businesses { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: rates_on_businesses :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: rates_on_businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: rates_on_businesses :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: rates_on_businesses :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: rates_on_businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: rates_on_businesses :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { valuer_id , business_id , rating , businesses , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: rates_on_businesses :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: rates_on_businesses :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: rates_on_businesses :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: rates_on_businesses :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: rates_on_businesses :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: rates_on_businesses :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["valuer_id" , "business_id" , "rating" , "businesses" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: rates_on_businesses :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; valuer_id) => { i32 } ; (@ field_type ; business_id) => { i32 } ; (@ field_type ; rating) => { i32 } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { businesses :: Data } ; (@ field_type ; businesses) => { crate :: prisma :: businesses :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "RatesOnBusinesses" , available relations are "valuer_id, business_id, rating, businesses, users")) } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; valuer_id) => { Into :: < crate :: prisma :: rates_on_businesses :: SelectParam > :: into (crate :: prisma :: rates_on_businesses :: valuer_id :: Select) } ; (@ selection_field_to_selection_param ; business_id) => { Into :: < crate :: prisma :: rates_on_businesses :: SelectParam > :: into (crate :: prisma :: rates_on_businesses :: business_id :: Select) } ; (@ selection_field_to_selection_param ; rating) => { Into :: < crate :: prisma :: rates_on_businesses :: SelectParam > :: into (crate :: prisma :: rates_on_businesses :: rating :: Select) } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: rates_on_businesses :: SelectParam > :: into (crate :: prisma :: rates_on_businesses :: businesses :: Select :: $ selection_mode (crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: rates_on_businesses :: SelectParam > :: into (crate :: prisma :: rates_on_businesses :: businesses :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: rates_on_businesses :: SelectParam > :: into (crate :: prisma :: rates_on_businesses :: users :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: rates_on_businesses :: SelectParam > :: into (crate :: prisma :: rates_on_businesses :: users :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: rates_on_businesses :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; valuer_id) => { "valuer_id" } ; (@ field_serde_name ; business_id) => { "business_id" } ; (@ field_serde_name ; rating) => { "rating" } ; (@ field_serde_name ; businesses) => { "businesses" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _select_rates_on_businesses as select;
    pub enum SelectParam {
        ValuerId(valuer_id::Select),
        BusinessId(business_id::Select),
        Rating(rating::Select),
        Businesses(businesses::Select),
        Users(users::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::ValuerId(data) => data.to_selection(),
                Self::BusinessId(data) => data.to_selection(),
                Self::Rating(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_rates_on_businesses { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: rates_on_businesses :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: rates_on_businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: rates_on_businesses :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: rates_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: rates_on_businesses :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: rates_on_businesses :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: rates_on_businesses :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: rates_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { businesses , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub valuer_id : i32 , pub business_id : i32 , pub rating : i32 , $ (pub $ field : crate :: prisma :: rates_on_businesses :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (valuer_id) , stringify ! (business_id) , stringify ! (rating)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: rates_on_businesses :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: rates_on_businesses :: valuer_id :: NAME , & self . valuer_id) ? ; state . serialize_field (crate :: prisma :: rates_on_businesses :: business_id :: NAME , & self . business_id) ? ; state . serialize_field (crate :: prisma :: rates_on_businesses :: rating :: NAME , & self . rating) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , valuer_id , business_id , rating } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: rates_on_businesses :: $ field :: NAME) , + , crate :: prisma :: rates_on_businesses :: valuer_id :: NAME , crate :: prisma :: rates_on_businesses :: business_id :: NAME , crate :: prisma :: rates_on_businesses :: rating :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: rates_on_businesses :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: rates_on_businesses :: valuer_id :: NAME => Ok (Field :: valuer_id) , crate :: prisma :: rates_on_businesses :: business_id :: NAME => Ok (Field :: business_id) , crate :: prisma :: rates_on_businesses :: rating :: NAME => Ok (Field :: rating) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut valuer_id = None ; let mut business_id = None ; let mut rating = None ; while let Some (key) = map . next_key () ? { match key { Field :: valuer_id => { if valuer_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: rates_on_businesses :: valuer_id :: NAME)) ; } valuer_id = Some (map . next_value () ?) ; } Field :: business_id => { if business_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: rates_on_businesses :: business_id :: NAME)) ; } business_id = Some (map . next_value () ?) ; } Field :: rating => { if rating . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: rates_on_businesses :: rating :: NAME)) ; } rating = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: rates_on_businesses :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: rates_on_businesses :: $ field :: NAME)) ? ;) * let valuer_id = valuer_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: rates_on_businesses :: valuer_id :: NAME)) ? ; let business_id = business_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: rates_on_businesses :: business_id :: NAME)) ? ; let rating = rating . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: rates_on_businesses :: rating :: NAME)) ? ; Ok (Data { valuer_id , business_id , rating , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["valuer_id" , "business_id" , "rating" , "businesses" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: rates_on_businesses :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { businesses :: Data } ; (@ field_type ; businesses) => { crate :: prisma :: businesses :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "RatesOnBusinesses" , available relations are "businesses, users")) } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: rates_on_businesses :: IncludeParam > :: into (crate :: prisma :: rates_on_businesses :: businesses :: Include :: $ selection_mode (crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: rates_on_businesses :: IncludeParam > :: into (crate :: prisma :: rates_on_businesses :: businesses :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: rates_on_businesses :: IncludeParam > :: into (crate :: prisma :: rates_on_businesses :: users :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: rates_on_businesses :: IncludeParam > :: into (crate :: prisma :: rates_on_businesses :: users :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: rates_on_businesses :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; valuer_id) => { "valuer_id" } ; (@ field_serde_name ; business_id) => { "business_id" } ; (@ field_serde_name ; rating) => { "rating" } ; (@ field_serde_name ; businesses) => { "businesses" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _include_rates_on_businesses as include;
    pub enum IncludeParam {
        ValuerId(valuer_id::Include),
        BusinessId(business_id::Include),
        Rating(rating::Include),
        Businesses(businesses::Include),
        Users(users::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::ValuerId(data) => data.to_selection(),
                Self::BusinessId(data) => data.to_selection(),
                Self::Rating(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_rates_on_businesses { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: rates_on_businesses struct $ struct_name { # [serde (rename = "valuer_id")] pub valuer_id : i32 , # [serde (rename = "business_id")] pub business_id : i32 , # [serde (rename = "rating")] pub rating : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_rates_on_businesses as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "valuer_id")]
        pub valuer_id: i32,
        #[serde(rename = "business_id")]
        pub business_id: i32,
        #[serde(rename = "rating")]
        pub rating: i32,
        #[serde(rename = "businesses")]
        pub businesses: Option<Box<super::businesses::Data>>,
        #[serde(rename = "users")]
        pub users: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn businesses(
            &self,
        ) -> Result<&super::businesses::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.businesses
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(businesses),
                ))
                .map(|v| v.as_ref())
        }
        pub fn users(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Businesses(super::businesses::UniqueArgs),
        Users(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Businesses(args) => {
                    let mut selections = < super :: businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(businesses::NAME, None, [], selections)
                }
                Self::Users(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(users::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetValuerId(i32),
        IncrementValuerId(i32),
        DecrementValuerId(i32),
        MultiplyValuerId(i32),
        DivideValuerId(i32),
        SetBusinessId(i32),
        IncrementBusinessId(i32),
        DecrementBusinessId(i32),
        MultiplyBusinessId(i32),
        DivideBusinessId(i32),
        SetRating(i32),
        IncrementRating(i32),
        DecrementRating(i32),
        MultiplyRating(i32),
        DivideRating(i32),
        ConnectBusinesses(super::businesses::UniqueWhereParam),
        ConnectUsers(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetValuerId(value) => (
                    valuer_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementValuerId(value) => (
                    valuer_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementValuerId(value) => (
                    valuer_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyValuerId(value) => (
                    valuer_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideValuerId(value) => (
                    valuer_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetRating(value) => (
                    rating::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementRating(value) => (
                    rating::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementRating(value) => (
                    rating::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyRating(value) => (
                    rating::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideRating(value) => (
                    rating::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectBusinesses(where_param) => (
                    businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUsers(where_param) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        ValuerId(i32),
        BusinessId(i32),
        Rating(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::ValuerId(value) => Self::SetValuerId(value),
                UncheckedSetParam::BusinessId(value) => Self::SetBusinessId(value),
                UncheckedSetParam::Rating(value) => Self::SetRating(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        ValuerId(::prisma_client_rust::Direction),
        BusinessId(::prisma_client_rust::Direction),
        Rating(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::ValuerId(direction) => (
                    valuer_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::BusinessId(direction) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Rating(direction) => (
                    rating::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        ValuerIdBusinessIdEquals(i32, i32),
        ValuerId(_prisma::read_filters::IntFilter),
        BusinessId(_prisma::read_filters::IntFilter),
        Rating(_prisma::read_filters::IntFilter),
        BusinessesIs(Vec<super::businesses::WhereParam>),
        BusinessesIsNot(Vec<super::businesses::WhereParam>),
        UsersIs(Vec<super::users::WhereParam>),
        UsersIsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::ValuerIdBusinessIdEquals(valuer_id, business_id) => (
                    "valuer_id_business_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            valuer_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(valuer_id as i64),
                        ),
                        (
                            business_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(business_id as i64),
                        ),
                    ]),
                ),
                Self::ValuerId(value) => (valuer_id::NAME, value.into()),
                Self::BusinessId(value) => (business_id::NAME, value.into()),
                Self::Rating(value) => (rating::NAME, value.into()),
                Self::BusinessesIs(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BusinessesIsNot(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIs(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIsNot(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        ValuerIdBusinessIdEquals(i32, i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::ValuerIdBusinessIdEquals(valuer_id, business_id) => {
                    Self::ValuerIdBusinessIdEquals(valuer_id, business_id)
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(valuer_id::NAME),
                ::prisma_client_rust::sel(business_id::NAME),
                ::prisma_client_rust::sel(rating::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            rating: i32,
            businesses: super::businesses::UniqueWhereParam,
            users: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                rating::set(rating),
                businesses::connect(businesses),
                users::connect(users),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            valuer_id: i32,
            business_id: i32,
            rating: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                valuer_id::set(valuer_id),
                business_id::set(business_id),
                rating::set(rating),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(valuer_id, business_id, rating, mut _params)| {
                    _params.extend([
                        valuer_id::set(valuer_id),
                        business_id::set(business_id),
                        rating::set(rating),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (rating, businesses, users, mut _params): (
                i32,
                super::businesses::UniqueWhereParam,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                rating::set(rating),
                businesses::connect(businesses),
                users::connect(users),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod replies {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "replies";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod desc {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "desc";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDesc(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Desc(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Desc(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Desc(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Desc, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Desc(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Desc(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod review_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "review_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetReviewId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ReviewId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ReviewId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ReviewId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ReviewId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementReviewId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementReviewId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyReviewId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideReviewId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ReviewId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ReviewId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod likes {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "likes";
        pub struct Set(pub Vec<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLikes(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Likes(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Likes(direction)
        }
        pub fn equals(value: Vec<i32>) -> WhereParam {
            WhereParam::Likes(_prisma::read_filters::IntListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntListFilter,
            Likes,
            {
                fn has(_: Option<i32>) -> Has;
                fn has_every(_: Vec<i32>) -> HasEvery;
                fn has_some(_: Vec<i32>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<i32>) -> SetParam {
            SetParam::PushLikes(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Likes(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Likes(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod dislikes {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "dislikes";
        pub struct Set(pub Vec<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDislikes(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Dislikes(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Dislikes(direction)
        }
        pub fn equals(value: Vec<i32>) -> WhereParam {
            WhereParam::Dislikes(_prisma::read_filters::IntListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntListFilter,
            Dislikes,
            {
                fn has(_: Option<i32>) -> Has;
                fn has_every(_: Vec<i32>) -> HasEvery;
                fn has_some(_: Vec<i32>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<i32>) -> SetParam {
            SetParam::PushDislikes(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Dislikes(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Dislikes(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUserId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, UserId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod reviews {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "reviews";
        pub struct Fetch(pub reviews::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<reviews::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Reviews(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(reviews::UniqueArgs::new())
        }
        pub struct Connect(reviews::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectReviews(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: reviews::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsIs(value)
        }
        pub fn is_not(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsIsNot(value)
        }
        pub enum Include {
            Select(Vec<reviews::SelectParam>),
            Include(Vec<reviews::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Reviews(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("reviews", None, [], selections)
            }
            pub fn select(nested_selections: Vec<reviews::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<reviews::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<reviews::SelectParam>),
            Include(Vec<reviews::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Reviews(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("reviews", None, [], selections)
            }
            pub fn select(nested_selections: Vec<reviews::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<reviews::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Users(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Users(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Users(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        desc: String,
        reviews: super::reviews::UniqueWhereParam,
        users: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        super::reviews::UniqueWhereParam,
        super::users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (desc, reviews, users, _params)
    }
    pub fn create_unchecked(
        desc: String,
        review_id: i32,
        user_id: i32,
        _params: Vec<SetParam>,
    ) -> (String, i32, i32, Vec<SetParam>) {
        (desc, review_id, user_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_replies { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: replies :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: replies :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: replies :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: replies :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: replies :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: replies :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , desc , review_id , likes , dislikes , user_id , reviews , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: replies :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: replies :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: replies :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: replies :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "desc" , "review_id" , "likes" , "dislikes" , "user_id" , "reviews" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: replies :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; desc) => { String } ; (@ field_type ; review_id) => { i32 } ; (@ field_type ; likes) => { Vec < i32 > } ; (@ field_type ; dislikes) => { Vec < i32 > } ; (@ field_type ; user_id) => { i32 } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { reviews :: Data } ; (@ field_type ; reviews) => { crate :: prisma :: reviews :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Replies" , available relations are "id, created_at, desc, review_id, likes, dislikes, user_id, reviews, users")) } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: replies :: SelectParam > :: into (crate :: prisma :: replies :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: replies :: SelectParam > :: into (crate :: prisma :: replies :: created_at :: Select) } ; (@ selection_field_to_selection_param ; desc) => { Into :: < crate :: prisma :: replies :: SelectParam > :: into (crate :: prisma :: replies :: desc :: Select) } ; (@ selection_field_to_selection_param ; review_id) => { Into :: < crate :: prisma :: replies :: SelectParam > :: into (crate :: prisma :: replies :: review_id :: Select) } ; (@ selection_field_to_selection_param ; likes) => { Into :: < crate :: prisma :: replies :: SelectParam > :: into (crate :: prisma :: replies :: likes :: Select) } ; (@ selection_field_to_selection_param ; dislikes) => { Into :: < crate :: prisma :: replies :: SelectParam > :: into (crate :: prisma :: replies :: dislikes :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < crate :: prisma :: replies :: SelectParam > :: into (crate :: prisma :: replies :: user_id :: Select) } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: replies :: SelectParam > :: into (crate :: prisma :: replies :: reviews :: Select :: $ selection_mode (crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: replies :: SelectParam > :: into (crate :: prisma :: replies :: reviews :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: replies :: SelectParam > :: into (crate :: prisma :: replies :: users :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: replies :: SelectParam > :: into (crate :: prisma :: replies :: users :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: replies :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; desc) => { "desc" } ; (@ field_serde_name ; review_id) => { "review_id" } ; (@ field_serde_name ; likes) => { "likes" } ; (@ field_serde_name ; dislikes) => { "dislikes" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; reviews) => { "reviews" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _select_replies as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        Desc(desc::Select),
        ReviewId(review_id::Select),
        Likes(likes::Select),
        Dislikes(dislikes::Select),
        UserId(user_id::Select),
        Reviews(reviews::Select),
        Users(users::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Desc(data) => data.to_selection(),
                Self::ReviewId(data) => data.to_selection(),
                Self::Likes(data) => data.to_selection(),
                Self::Dislikes(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_replies { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: replies :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: replies :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: replies :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: replies :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: replies :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: replies :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: replies :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: replies :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { reviews , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub desc : String , pub review_id : i32 , pub likes : Vec < i32 > , pub dislikes : Vec < i32 > , pub user_id : i32 , $ (pub $ field : crate :: prisma :: replies :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (desc) , stringify ! (review_id) , stringify ! (likes) , stringify ! (dislikes) , stringify ! (user_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: replies :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: replies :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: replies :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: replies :: desc :: NAME , & self . desc) ? ; state . serialize_field (crate :: prisma :: replies :: review_id :: NAME , & self . review_id) ? ; state . serialize_field (crate :: prisma :: replies :: likes :: NAME , & self . likes) ? ; state . serialize_field (crate :: prisma :: replies :: dislikes :: NAME , & self . dislikes) ? ; state . serialize_field (crate :: prisma :: replies :: user_id :: NAME , & self . user_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , desc , review_id , likes , dislikes , user_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: replies :: $ field :: NAME) , + , crate :: prisma :: replies :: id :: NAME , crate :: prisma :: replies :: created_at :: NAME , crate :: prisma :: replies :: desc :: NAME , crate :: prisma :: replies :: review_id :: NAME , crate :: prisma :: replies :: likes :: NAME , crate :: prisma :: replies :: dislikes :: NAME , crate :: prisma :: replies :: user_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: replies :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: replies :: id :: NAME => Ok (Field :: id) , crate :: prisma :: replies :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: replies :: desc :: NAME => Ok (Field :: desc) , crate :: prisma :: replies :: review_id :: NAME => Ok (Field :: review_id) , crate :: prisma :: replies :: likes :: NAME => Ok (Field :: likes) , crate :: prisma :: replies :: dislikes :: NAME => Ok (Field :: dislikes) , crate :: prisma :: replies :: user_id :: NAME => Ok (Field :: user_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut desc = None ; let mut review_id = None ; let mut likes = None ; let mut dislikes = None ; let mut user_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: desc => { if desc . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies :: desc :: NAME)) ; } desc = Some (map . next_value () ?) ; } Field :: review_id => { if review_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies :: review_id :: NAME)) ; } review_id = Some (map . next_value () ?) ; } Field :: likes => { if likes . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies :: likes :: NAME)) ; } likes = Some (map . next_value () ?) ; } Field :: dislikes => { if dislikes . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies :: dislikes :: NAME)) ; } dislikes = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies :: user_id :: NAME)) ; } user_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies :: created_at :: NAME)) ? ; let desc = desc . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies :: desc :: NAME)) ? ; let review_id = review_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies :: review_id :: NAME)) ? ; let likes = likes . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies :: likes :: NAME)) ? ; let dislikes = dislikes . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies :: dislikes :: NAME)) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies :: user_id :: NAME)) ? ; Ok (Data { id , created_at , desc , review_id , likes , dislikes , user_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "desc" , "review_id" , "likes" , "dislikes" , "user_id" , "reviews" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: replies :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { reviews :: Data } ; (@ field_type ; reviews) => { crate :: prisma :: reviews :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Replies" , available relations are "reviews, users")) } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: replies :: IncludeParam > :: into (crate :: prisma :: replies :: reviews :: Include :: $ selection_mode (crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: replies :: IncludeParam > :: into (crate :: prisma :: replies :: reviews :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: replies :: IncludeParam > :: into (crate :: prisma :: replies :: users :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: replies :: IncludeParam > :: into (crate :: prisma :: replies :: users :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: replies :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; desc) => { "desc" } ; (@ field_serde_name ; review_id) => { "review_id" } ; (@ field_serde_name ; likes) => { "likes" } ; (@ field_serde_name ; dislikes) => { "dislikes" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; reviews) => { "reviews" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _include_replies as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        Desc(desc::Include),
        ReviewId(review_id::Include),
        Likes(likes::Include),
        Dislikes(dislikes::Include),
        UserId(user_id::Include),
        Reviews(reviews::Include),
        Users(users::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Desc(data) => data.to_selection(),
                Self::ReviewId(data) => data.to_selection(),
                Self::Likes(data) => data.to_selection(),
                Self::Dislikes(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_replies { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: replies struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "desc")] pub desc : String , # [serde (rename = "review_id")] pub review_id : i32 , # [serde (rename = "likes")] pub likes : Vec < i32 > , # [serde (rename = "dislikes")] pub dislikes : Vec < i32 > , # [serde (rename = "user_id")] pub user_id : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_replies as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "desc")]
        pub desc: String,
        #[serde(rename = "review_id")]
        pub review_id: i32,
        #[serde(rename = "likes")]
        pub likes: Vec<i32>,
        #[serde(rename = "dislikes")]
        pub dislikes: Vec<i32>,
        #[serde(rename = "user_id")]
        pub user_id: i32,
        #[serde(rename = "reviews")]
        pub reviews: Option<Box<super::reviews::Data>>,
        #[serde(rename = "users")]
        pub users: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn reviews(
            &self,
        ) -> Result<&super::reviews::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.reviews
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(reviews),
                ))
                .map(|v| v.as_ref())
        }
        pub fn users(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Reviews(super::reviews::UniqueArgs),
        Users(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Reviews(args) => {
                    let mut selections = < super :: reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(reviews::NAME, None, [], selections)
                }
                Self::Users(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(users::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetDesc(String),
        SetReviewId(i32),
        IncrementReviewId(i32),
        DecrementReviewId(i32),
        MultiplyReviewId(i32),
        DivideReviewId(i32),
        SetLikes(Vec<i32>),
        PushLikes(Vec<i32>),
        SetDislikes(Vec<i32>),
        PushDislikes(Vec<i32>),
        SetUserId(i32),
        IncrementUserId(i32),
        DecrementUserId(i32),
        MultiplyUserId(i32),
        DivideUserId(i32),
        ConnectReviews(super::reviews::UniqueWhereParam),
        ConnectUsers(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetDesc(value) => (
                    desc::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetLikes(value) => (
                    likes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .collect(),
                    ),
                ),
                SetParam::PushLikes(value) => (
                    likes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetDislikes(value) => (
                    dislikes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .collect(),
                    ),
                ),
                SetParam::PushDislikes(value) => (
                    dislikes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectReviews(where_param) => (
                    reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUsers(where_param) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        Desc(String),
        ReviewId(i32),
        Likes(Vec<i32>),
        Dislikes(Vec<i32>),
        UserId(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::Desc(value) => Self::SetDesc(value),
                UncheckedSetParam::ReviewId(value) => Self::SetReviewId(value),
                UncheckedSetParam::Likes(value) => Self::SetLikes(value),
                UncheckedSetParam::Dislikes(value) => Self::SetDislikes(value),
                UncheckedSetParam::UserId(value) => Self::SetUserId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        Desc(::prisma_client_rust::Direction),
        ReviewId(::prisma_client_rust::Direction),
        Likes(::prisma_client_rust::Direction),
        Dislikes(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Desc(direction) => (
                    desc::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ReviewId(direction) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Likes(direction) => (
                    likes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Dislikes(direction) => (
                    dislikes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        Desc(_prisma::read_filters::StringFilter),
        ReviewId(_prisma::read_filters::IntFilter),
        Likes(_prisma::read_filters::IntListFilter),
        Dislikes(_prisma::read_filters::IntListFilter),
        UserId(_prisma::read_filters::IntFilter),
        ReviewsIs(Vec<super::reviews::WhereParam>),
        ReviewsIsNot(Vec<super::reviews::WhereParam>),
        UsersIs(Vec<super::users::WhereParam>),
        UsersIsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::Desc(value) => (desc::NAME, value.into()),
                Self::ReviewId(value) => (review_id::NAME, value.into()),
                Self::Likes(value) => (likes::NAME, value.into()),
                Self::Dislikes(value) => (dislikes::NAME, value.into()),
                Self::UserId(value) => (user_id::NAME, value.into()),
                Self::ReviewsIs(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewsIsNot(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIs(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIsNot(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(desc::NAME),
                ::prisma_client_rust::sel(review_id::NAME),
                ::prisma_client_rust::sel(likes::NAME),
                ::prisma_client_rust::sel(dislikes::NAME),
                ::prisma_client_rust::sel(user_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            desc: String,
            reviews: super::reviews::UniqueWhereParam,
            users: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                desc::set(desc),
                reviews::connect(reviews),
                users::connect(users),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            desc: String,
            review_id: i32,
            user_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                desc::set(desc),
                review_id::set(review_id),
                user_id::set(user_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, i32, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(desc, review_id, user_id, mut _params)| {
                    _params.extend([
                        desc::set(desc),
                        review_id::set(review_id),
                        user_id::set(user_id),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (desc, reviews, users, mut _params): (
                String,
                super::reviews::UniqueWhereParam,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                desc::set(desc),
                reviews::connect(reviews),
                users::connect(users),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod replies_on_feedbacks {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "replies_on_feedbacks";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod feedback_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "feedback_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetFeedbackId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::FeedbackId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::FeedbackId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::FeedbackId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            FeedbackId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementFeedbackId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementFeedbackId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyFeedbackId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideFeedbackId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FeedbackId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FeedbackId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUserId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, UserId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod desc {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "desc";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDesc(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Desc(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Desc(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Desc(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Desc, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Desc(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Desc(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod feedbacks_on_businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "feedbacks_on_businesses";
        pub struct Fetch(pub feedbacks_on_businesses::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<feedbacks_on_businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::FeedbacksOnBusinesses(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(feedbacks_on_businesses::UniqueArgs::new())
        }
        pub struct Connect(feedbacks_on_businesses::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectFeedbacksOnBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: feedbacks_on_businesses::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<feedbacks_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FeedbacksOnBusinessesIs(value)
        }
        pub fn is_not(value: Vec<feedbacks_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FeedbacksOnBusinessesIsNot(value)
        }
        pub enum Include {
            Select(Vec<feedbacks_on_businesses::SelectParam>),
            Include(Vec<feedbacks_on_businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FeedbacksOnBusinesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "feedbacks_on_businesses",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<feedbacks_on_businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<feedbacks_on_businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<feedbacks_on_businesses::SelectParam>),
            Include(Vec<feedbacks_on_businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FeedbacksOnBusinesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ;
                ::prisma_client_rust::Selection::new(
                    "feedbacks_on_businesses",
                    None,
                    [],
                    selections,
                )
            }
            pub fn select(nested_selections: Vec<feedbacks_on_businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<feedbacks_on_businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Users(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Users(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Users(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        desc: String,
        feedbacks_on_businesses: super::feedbacks_on_businesses::UniqueWhereParam,
        users: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        String,
        super::feedbacks_on_businesses::UniqueWhereParam,
        super::users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (desc, feedbacks_on_businesses, users, _params)
    }
    pub fn create_unchecked(
        feedback_id: i32,
        user_id: i32,
        desc: String,
        _params: Vec<SetParam>,
    ) -> (i32, i32, String, Vec<SetParam>) {
        (feedback_id, user_id, desc, _params)
    }
    #[macro_export]
    macro_rules ! _select_replies_on_feedbacks { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: replies_on_feedbacks :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: replies_on_feedbacks :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: replies_on_feedbacks :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: replies_on_feedbacks :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: replies_on_feedbacks :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: replies_on_feedbacks :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , feedback_id , user_id , desc , feedbacks_on_businesses , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: replies_on_feedbacks :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: replies_on_feedbacks :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: replies_on_feedbacks :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: replies_on_feedbacks :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies_on_feedbacks :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies_on_feedbacks :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "feedback_id" , "user_id" , "desc" , "feedbacks_on_businesses" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: replies_on_feedbacks :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; feedback_id) => { i32 } ; (@ field_type ; user_id) => { i32 } ; (@ field_type ; desc) => { String } ; (@ field_type ; feedbacks_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { feedbacks_on_businesses :: Data } ; (@ field_type ; feedbacks_on_businesses) => { crate :: prisma :: feedbacks_on_businesses :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "RepliesOnFeedbacks" , available relations are "id, created_at, feedback_id, user_id, desc, feedbacks_on_businesses, users")) } ; (@ field_module ; feedbacks_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: feedbacks_on_businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: replies_on_feedbacks :: SelectParam > :: into (crate :: prisma :: replies_on_feedbacks :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: replies_on_feedbacks :: SelectParam > :: into (crate :: prisma :: replies_on_feedbacks :: created_at :: Select) } ; (@ selection_field_to_selection_param ; feedback_id) => { Into :: < crate :: prisma :: replies_on_feedbacks :: SelectParam > :: into (crate :: prisma :: replies_on_feedbacks :: feedback_id :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < crate :: prisma :: replies_on_feedbacks :: SelectParam > :: into (crate :: prisma :: replies_on_feedbacks :: user_id :: Select) } ; (@ selection_field_to_selection_param ; desc) => { Into :: < crate :: prisma :: replies_on_feedbacks :: SelectParam > :: into (crate :: prisma :: replies_on_feedbacks :: desc :: Select) } ; (@ selection_field_to_selection_param ; feedbacks_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: replies_on_feedbacks :: SelectParam > :: into (crate :: prisma :: replies_on_feedbacks :: feedbacks_on_businesses :: Select :: $ selection_mode (crate :: prisma :: feedbacks_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; feedbacks_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: replies_on_feedbacks :: SelectParam > :: into (crate :: prisma :: replies_on_feedbacks :: feedbacks_on_businesses :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: replies_on_feedbacks :: SelectParam > :: into (crate :: prisma :: replies_on_feedbacks :: users :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: replies_on_feedbacks :: SelectParam > :: into (crate :: prisma :: replies_on_feedbacks :: users :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: replies_on_feedbacks :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; feedback_id) => { "feedback_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; desc) => { "desc" } ; (@ field_serde_name ; feedbacks_on_businesses) => { "feedbacks_on_businesses" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _select_replies_on_feedbacks as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        FeedbackId(feedback_id::Select),
        UserId(user_id::Select),
        Desc(desc::Select),
        FeedbacksOnBusinesses(feedbacks_on_businesses::Select),
        Users(users::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::FeedbackId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::Desc(data) => data.to_selection(),
                Self::FeedbacksOnBusinesses(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_replies_on_feedbacks { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: replies_on_feedbacks :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: replies_on_feedbacks :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: replies_on_feedbacks :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: replies_on_feedbacks :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: replies_on_feedbacks :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: replies_on_feedbacks :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: replies_on_feedbacks :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: replies_on_feedbacks :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { feedbacks_on_businesses , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub feedback_id : i32 , pub user_id : i32 , pub desc : String , $ (pub $ field : crate :: prisma :: replies_on_feedbacks :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (feedback_id) , stringify ! (user_id) , stringify ! (desc)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: replies_on_feedbacks :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: replies_on_feedbacks :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: replies_on_feedbacks :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: replies_on_feedbacks :: feedback_id :: NAME , & self . feedback_id) ? ; state . serialize_field (crate :: prisma :: replies_on_feedbacks :: user_id :: NAME , & self . user_id) ? ; state . serialize_field (crate :: prisma :: replies_on_feedbacks :: desc :: NAME , & self . desc) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , feedback_id , user_id , desc } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: replies_on_feedbacks :: $ field :: NAME) , + , crate :: prisma :: replies_on_feedbacks :: id :: NAME , crate :: prisma :: replies_on_feedbacks :: created_at :: NAME , crate :: prisma :: replies_on_feedbacks :: feedback_id :: NAME , crate :: prisma :: replies_on_feedbacks :: user_id :: NAME , crate :: prisma :: replies_on_feedbacks :: desc :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: replies_on_feedbacks :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: replies_on_feedbacks :: id :: NAME => Ok (Field :: id) , crate :: prisma :: replies_on_feedbacks :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: replies_on_feedbacks :: feedback_id :: NAME => Ok (Field :: feedback_id) , crate :: prisma :: replies_on_feedbacks :: user_id :: NAME => Ok (Field :: user_id) , crate :: prisma :: replies_on_feedbacks :: desc :: NAME => Ok (Field :: desc) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut feedback_id = None ; let mut user_id = None ; let mut desc = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies_on_feedbacks :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies_on_feedbacks :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: feedback_id => { if feedback_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies_on_feedbacks :: feedback_id :: NAME)) ; } feedback_id = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies_on_feedbacks :: user_id :: NAME)) ; } user_id = Some (map . next_value () ?) ; } Field :: desc => { if desc . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies_on_feedbacks :: desc :: NAME)) ; } desc = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: replies_on_feedbacks :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies_on_feedbacks :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies_on_feedbacks :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies_on_feedbacks :: created_at :: NAME)) ? ; let feedback_id = feedback_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies_on_feedbacks :: feedback_id :: NAME)) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies_on_feedbacks :: user_id :: NAME)) ? ; let desc = desc . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: replies_on_feedbacks :: desc :: NAME)) ? ; Ok (Data { id , created_at , feedback_id , user_id , desc , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "feedback_id" , "user_id" , "desc" , "feedbacks_on_businesses" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: replies_on_feedbacks :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; feedbacks_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { feedbacks_on_businesses :: Data } ; (@ field_type ; feedbacks_on_businesses) => { crate :: prisma :: feedbacks_on_businesses :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "RepliesOnFeedbacks" , available relations are "feedbacks_on_businesses, users")) } ; (@ field_module ; feedbacks_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: feedbacks_on_businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; feedbacks_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: replies_on_feedbacks :: IncludeParam > :: into (crate :: prisma :: replies_on_feedbacks :: feedbacks_on_businesses :: Include :: $ selection_mode (crate :: prisma :: feedbacks_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; feedbacks_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: replies_on_feedbacks :: IncludeParam > :: into (crate :: prisma :: replies_on_feedbacks :: feedbacks_on_businesses :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: replies_on_feedbacks :: IncludeParam > :: into (crate :: prisma :: replies_on_feedbacks :: users :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: replies_on_feedbacks :: IncludeParam > :: into (crate :: prisma :: replies_on_feedbacks :: users :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: replies_on_feedbacks :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; feedback_id) => { "feedback_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; desc) => { "desc" } ; (@ field_serde_name ; feedbacks_on_businesses) => { "feedbacks_on_businesses" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _include_replies_on_feedbacks as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        FeedbackId(feedback_id::Include),
        UserId(user_id::Include),
        Desc(desc::Include),
        FeedbacksOnBusinesses(feedbacks_on_businesses::Include),
        Users(users::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::FeedbackId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::Desc(data) => data.to_selection(),
                Self::FeedbacksOnBusinesses(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_replies_on_feedbacks { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: replies_on_feedbacks struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "feedback_id")] pub feedback_id : i32 , # [serde (rename = "user_id")] pub user_id : i32 , # [serde (rename = "desc")] pub desc : String } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_replies_on_feedbacks as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "feedback_id")]
        pub feedback_id: i32,
        #[serde(rename = "user_id")]
        pub user_id: i32,
        #[serde(rename = "desc")]
        pub desc: String,
        #[serde(rename = "feedbacks_on_businesses")]
        pub feedbacks_on_businesses: Option<Box<super::feedbacks_on_businesses::Data>>,
        #[serde(rename = "users")]
        pub users: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn feedbacks_on_businesses(
            &self,
        ) -> Result<
            &super::feedbacks_on_businesses::Data,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.feedbacks_on_businesses
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(feedbacks_on_businesses),
                ))
                .map(|v| v.as_ref())
        }
        pub fn users(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        FeedbacksOnBusinesses(super::feedbacks_on_businesses::UniqueArgs),
        Users(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::FeedbacksOnBusinesses(args) => {
                    let mut selections = < super :: feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(
                        feedbacks_on_businesses::NAME,
                        None,
                        [],
                        selections,
                    )
                }
                Self::Users(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(users::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetFeedbackId(i32),
        IncrementFeedbackId(i32),
        DecrementFeedbackId(i32),
        MultiplyFeedbackId(i32),
        DivideFeedbackId(i32),
        SetUserId(i32),
        IncrementUserId(i32),
        DecrementUserId(i32),
        MultiplyUserId(i32),
        DivideUserId(i32),
        SetDesc(String),
        ConnectFeedbacksOnBusinesses(super::feedbacks_on_businesses::UniqueWhereParam),
        ConnectUsers(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetFeedbackId(value) => (
                    feedback_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementFeedbackId(value) => (
                    feedback_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementFeedbackId(value) => (
                    feedback_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyFeedbackId(value) => (
                    feedback_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideFeedbackId(value) => (
                    feedback_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetDesc(value) => (
                    desc::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::ConnectFeedbacksOnBusinesses(where_param) => (
                    feedbacks_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::feedbacks_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUsers(where_param) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        FeedbackId(i32),
        UserId(i32),
        Desc(String),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::FeedbackId(value) => Self::SetFeedbackId(value),
                UncheckedSetParam::UserId(value) => Self::SetUserId(value),
                UncheckedSetParam::Desc(value) => Self::SetDesc(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        FeedbackId(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
        Desc(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::FeedbackId(direction) => (
                    feedback_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Desc(direction) => (
                    desc::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        FeedbackId(_prisma::read_filters::IntFilter),
        UserId(_prisma::read_filters::IntFilter),
        Desc(_prisma::read_filters::StringFilter),
        FeedbacksOnBusinessesIs(Vec<super::feedbacks_on_businesses::WhereParam>),
        FeedbacksOnBusinessesIsNot(Vec<super::feedbacks_on_businesses::WhereParam>),
        UsersIs(Vec<super::users::WhereParam>),
        UsersIsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::FeedbackId(value) => (feedback_id::NAME, value.into()),
                Self::UserId(value) => (user_id::NAME, value.into()),
                Self::Desc(value) => (desc::NAME, value.into()),
                Self::FeedbacksOnBusinessesIs(where_params) => (
                    feedbacks_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FeedbacksOnBusinessesIsNot(where_params) => (
                    feedbacks_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIs(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIsNot(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(feedback_id::NAME),
                ::prisma_client_rust::sel(user_id::NAME),
                ::prisma_client_rust::sel(desc::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            desc: String,
            feedbacks_on_businesses: super::feedbacks_on_businesses::UniqueWhereParam,
            users: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                desc::set(desc),
                feedbacks_on_businesses::connect(feedbacks_on_businesses),
                users::connect(users),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            feedback_id: i32,
            user_id: i32,
            desc: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                feedback_id::set(feedback_id),
                user_id::set(user_id),
                desc::set(desc),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(feedback_id, user_id, desc, mut _params)| {
                    _params.extend([
                        feedback_id::set(feedback_id),
                        user_id::set(user_id),
                        desc::set(desc),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (desc, feedbacks_on_businesses, users, mut _params): (
                String,
                super::feedbacks_on_businesses::UniqueWhereParam,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                desc::set(desc),
                feedbacks_on_businesses::connect(feedbacks_on_businesses),
                users::connect(users),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod review_histories {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "review_histories";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod rate {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "rate";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRate(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Rate(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Rate(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Rate(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Rate, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementRate(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementRate(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyRate(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideRate(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Rate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Rate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod review_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "review_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetReviewId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::ReviewId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::ReviewId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ReviewId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            ReviewId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementReviewId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementReviewId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyReviewId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideReviewId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ReviewId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ReviewId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod txn_hash {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "txn_hash";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTxnHash(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TxnHash(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TxnHash(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::TxnHashEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            TxnHash,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TxnHash(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TxnHash(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod headline {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "headline";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetHeadline(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Headline(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Headline(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Headline(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Headline,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Headline(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Headline(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod comment {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "comment";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetComment(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Comment(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Comment(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Comment(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Comment,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Comment(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Comment(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod reviews {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "reviews";
        pub struct Fetch(pub reviews::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<reviews::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Reviews(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(reviews::UniqueArgs::new())
        }
        pub struct Connect(reviews::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectReviews(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: reviews::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsIs(value)
        }
        pub fn is_not(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsIsNot(value)
        }
        pub enum Include {
            Select(Vec<reviews::SelectParam>),
            Include(Vec<reviews::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Reviews(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("reviews", None, [], selections)
            }
            pub fn select(nested_selections: Vec<reviews::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<reviews::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<reviews::SelectParam>),
            Include(Vec<reviews::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Reviews(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("reviews", None, [], selections)
            }
            pub fn select(nested_selections: Vec<reviews::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<reviews::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        rate: i32,
        txn_hash: String,
        reviews: super::reviews::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (i32, String, super::reviews::UniqueWhereParam, Vec<SetParam>) {
        (rate, txn_hash, reviews, _params)
    }
    pub fn create_unchecked(
        rate: i32,
        review_id: i32,
        txn_hash: String,
        _params: Vec<SetParam>,
    ) -> (i32, i32, String, Vec<SetParam>) {
        (rate, review_id, txn_hash, _params)
    }
    #[macro_export]
    macro_rules ! _select_review_histories { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: review_histories :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: review_histories :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: review_histories :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: review_histories :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: review_histories :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: review_histories :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , rate , review_id , txn_hash , headline , comment , reviews } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: review_histories :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: review_histories :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: review_histories :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: review_histories :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: review_histories :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: review_histories :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "rate" , "review_id" , "txn_hash" , "headline" , "comment" , "reviews"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: review_histories :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; rate) => { i32 } ; (@ field_type ; review_id) => { i32 } ; (@ field_type ; txn_hash) => { String } ; (@ field_type ; headline) => { Option < String > } ; (@ field_type ; comment) => { Option < String > } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { reviews :: Data } ; (@ field_type ; reviews) => { crate :: prisma :: reviews :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ReviewHistories" , available relations are "id, created_at, rate, review_id, txn_hash, headline, comment, reviews")) } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: review_histories :: SelectParam > :: into (crate :: prisma :: review_histories :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: review_histories :: SelectParam > :: into (crate :: prisma :: review_histories :: created_at :: Select) } ; (@ selection_field_to_selection_param ; rate) => { Into :: < crate :: prisma :: review_histories :: SelectParam > :: into (crate :: prisma :: review_histories :: rate :: Select) } ; (@ selection_field_to_selection_param ; review_id) => { Into :: < crate :: prisma :: review_histories :: SelectParam > :: into (crate :: prisma :: review_histories :: review_id :: Select) } ; (@ selection_field_to_selection_param ; txn_hash) => { Into :: < crate :: prisma :: review_histories :: SelectParam > :: into (crate :: prisma :: review_histories :: txn_hash :: Select) } ; (@ selection_field_to_selection_param ; headline) => { Into :: < crate :: prisma :: review_histories :: SelectParam > :: into (crate :: prisma :: review_histories :: headline :: Select) } ; (@ selection_field_to_selection_param ; comment) => { Into :: < crate :: prisma :: review_histories :: SelectParam > :: into (crate :: prisma :: review_histories :: comment :: Select) } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: review_histories :: SelectParam > :: into (crate :: prisma :: review_histories :: reviews :: Select :: $ selection_mode (crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: review_histories :: SelectParam > :: into (crate :: prisma :: review_histories :: reviews :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: review_histories :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; rate) => { "rate" } ; (@ field_serde_name ; review_id) => { "review_id" } ; (@ field_serde_name ; txn_hash) => { "txn_hash" } ; (@ field_serde_name ; headline) => { "headline" } ; (@ field_serde_name ; comment) => { "comment" } ; (@ field_serde_name ; reviews) => { "reviews" } ; }
    pub use _select_review_histories as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        Rate(rate::Select),
        ReviewId(review_id::Select),
        TxnHash(txn_hash::Select),
        Headline(headline::Select),
        Comment(comment::Select),
        Reviews(reviews::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Rate(data) => data.to_selection(),
                Self::ReviewId(data) => data.to_selection(),
                Self::TxnHash(data) => data.to_selection(),
                Self::Headline(data) => data.to_selection(),
                Self::Comment(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_review_histories { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: review_histories :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: review_histories :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: review_histories :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: review_histories :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: review_histories :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: review_histories :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: review_histories :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: review_histories :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { reviews } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub rate : i32 , pub review_id : i32 , pub txn_hash : String , pub headline : Option < String > , pub comment : Option < String > , $ (pub $ field : crate :: prisma :: review_histories :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (rate) , stringify ! (review_id) , stringify ! (txn_hash) , stringify ! (headline) , stringify ! (comment)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: review_histories :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: review_histories :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: review_histories :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: review_histories :: rate :: NAME , & self . rate) ? ; state . serialize_field (crate :: prisma :: review_histories :: review_id :: NAME , & self . review_id) ? ; state . serialize_field (crate :: prisma :: review_histories :: txn_hash :: NAME , & self . txn_hash) ? ; state . serialize_field (crate :: prisma :: review_histories :: headline :: NAME , & self . headline) ? ; state . serialize_field (crate :: prisma :: review_histories :: comment :: NAME , & self . comment) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , rate , review_id , txn_hash , headline , comment } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: review_histories :: $ field :: NAME) , + , crate :: prisma :: review_histories :: id :: NAME , crate :: prisma :: review_histories :: created_at :: NAME , crate :: prisma :: review_histories :: rate :: NAME , crate :: prisma :: review_histories :: review_id :: NAME , crate :: prisma :: review_histories :: txn_hash :: NAME , crate :: prisma :: review_histories :: headline :: NAME , crate :: prisma :: review_histories :: comment :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: review_histories :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: review_histories :: id :: NAME => Ok (Field :: id) , crate :: prisma :: review_histories :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: review_histories :: rate :: NAME => Ok (Field :: rate) , crate :: prisma :: review_histories :: review_id :: NAME => Ok (Field :: review_id) , crate :: prisma :: review_histories :: txn_hash :: NAME => Ok (Field :: txn_hash) , crate :: prisma :: review_histories :: headline :: NAME => Ok (Field :: headline) , crate :: prisma :: review_histories :: comment :: NAME => Ok (Field :: comment) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut rate = None ; let mut review_id = None ; let mut txn_hash = None ; let mut headline = None ; let mut comment = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: review_histories :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: review_histories :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: rate => { if rate . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: review_histories :: rate :: NAME)) ; } rate = Some (map . next_value () ?) ; } Field :: review_id => { if review_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: review_histories :: review_id :: NAME)) ; } review_id = Some (map . next_value () ?) ; } Field :: txn_hash => { if txn_hash . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: review_histories :: txn_hash :: NAME)) ; } txn_hash = Some (map . next_value () ?) ; } Field :: headline => { if headline . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: review_histories :: headline :: NAME)) ; } headline = Some (map . next_value () ?) ; } Field :: comment => { if comment . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: review_histories :: comment :: NAME)) ; } comment = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: review_histories :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: review_histories :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: review_histories :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: review_histories :: created_at :: NAME)) ? ; let rate = rate . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: review_histories :: rate :: NAME)) ? ; let review_id = review_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: review_histories :: review_id :: NAME)) ? ; let txn_hash = txn_hash . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: review_histories :: txn_hash :: NAME)) ? ; let headline = headline . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: review_histories :: headline :: NAME)) ? ; let comment = comment . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: review_histories :: comment :: NAME)) ? ; Ok (Data { id , created_at , rate , review_id , txn_hash , headline , comment , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "rate" , "review_id" , "txn_hash" , "headline" , "comment" , "reviews"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: review_histories :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { reviews :: Data } ; (@ field_type ; reviews) => { crate :: prisma :: reviews :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "ReviewHistories" , available relations are "reviews")) } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: review_histories :: IncludeParam > :: into (crate :: prisma :: review_histories :: reviews :: Include :: $ selection_mode (crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: review_histories :: IncludeParam > :: into (crate :: prisma :: review_histories :: reviews :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: review_histories :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; rate) => { "rate" } ; (@ field_serde_name ; review_id) => { "review_id" } ; (@ field_serde_name ; txn_hash) => { "txn_hash" } ; (@ field_serde_name ; headline) => { "headline" } ; (@ field_serde_name ; comment) => { "comment" } ; (@ field_serde_name ; reviews) => { "reviews" } ; }
    pub use _include_review_histories as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        Rate(rate::Include),
        ReviewId(review_id::Include),
        TxnHash(txn_hash::Include),
        Headline(headline::Include),
        Comment(comment::Include),
        Reviews(reviews::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Rate(data) => data.to_selection(),
                Self::ReviewId(data) => data.to_selection(),
                Self::TxnHash(data) => data.to_selection(),
                Self::Headline(data) => data.to_selection(),
                Self::Comment(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_review_histories { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: review_histories struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "rate")] pub rate : i32 , # [serde (rename = "review_id")] pub review_id : i32 , # [serde (rename = "txn_hash")] pub txn_hash : String , # [serde (rename = "headline")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub headline : Option < String > , # [serde (rename = "comment")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub comment : Option < String > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_review_histories as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "rate")]
        pub rate: i32,
        #[serde(rename = "review_id")]
        pub review_id: i32,
        #[serde(rename = "txn_hash")]
        pub txn_hash: String,
        #[serde(rename = "headline")]
        pub headline: Option<String>,
        #[serde(rename = "comment")]
        pub comment: Option<String>,
        #[serde(rename = "reviews")]
        pub reviews: Option<Box<super::reviews::Data>>,
    }
    impl Data {
        pub fn reviews(
            &self,
        ) -> Result<&super::reviews::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.reviews
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(reviews),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Reviews(super::reviews::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Reviews(args) => {
                    let mut selections = < super :: reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(reviews::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetRate(i32),
        IncrementRate(i32),
        DecrementRate(i32),
        MultiplyRate(i32),
        DivideRate(i32),
        SetReviewId(i32),
        IncrementReviewId(i32),
        DecrementReviewId(i32),
        MultiplyReviewId(i32),
        DivideReviewId(i32),
        SetTxnHash(String),
        SetHeadline(Option<String>),
        SetComment(Option<String>),
        ConnectReviews(super::reviews::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetRate(value) => (
                    rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementRate(value) => (
                    rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementRate(value) => (
                    rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyRate(value) => (
                    rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideRate(value) => (
                    rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideReviewId(value) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetTxnHash(value) => (
                    txn_hash::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetHeadline(value) => (
                    headline::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetComment(value) => (
                    comment::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectReviews(where_param) => (
                    reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        Rate(i32),
        ReviewId(i32),
        TxnHash(String),
        Headline(Option<String>),
        Comment(Option<String>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::Rate(value) => Self::SetRate(value),
                UncheckedSetParam::ReviewId(value) => Self::SetReviewId(value),
                UncheckedSetParam::TxnHash(value) => Self::SetTxnHash(value),
                UncheckedSetParam::Headline(value) => Self::SetHeadline(value),
                UncheckedSetParam::Comment(value) => Self::SetComment(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        Rate(::prisma_client_rust::Direction),
        ReviewId(::prisma_client_rust::Direction),
        TxnHash(::prisma_client_rust::Direction),
        Headline(::prisma_client_rust::Direction),
        Comment(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Rate(direction) => (
                    rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::ReviewId(direction) => (
                    review_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TxnHash(direction) => (
                    txn_hash::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Headline(direction) => (
                    headline::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Comment(direction) => (
                    comment::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        Rate(_prisma::read_filters::IntFilter),
        ReviewId(_prisma::read_filters::IntFilter),
        TxnHash(_prisma::read_filters::StringFilter),
        Headline(_prisma::read_filters::StringNullableFilter),
        Comment(_prisma::read_filters::StringNullableFilter),
        ReviewsIs(Vec<super::reviews::WhereParam>),
        ReviewsIsNot(Vec<super::reviews::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::Rate(value) => (rate::NAME, value.into()),
                Self::ReviewId(value) => (review_id::NAME, value.into()),
                Self::TxnHash(value) => (txn_hash::NAME, value.into()),
                Self::Headline(value) => (headline::NAME, value.into()),
                Self::Comment(value) => (comment::NAME, value.into()),
                Self::ReviewsIs(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewsIsNot(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        TxnHashEquals(String),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::TxnHashEquals(value) => {
                    Self::TxnHash(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(rate::NAME),
                ::prisma_client_rust::sel(review_id::NAME),
                ::prisma_client_rust::sel(txn_hash::NAME),
                ::prisma_client_rust::sel(headline::NAME),
                ::prisma_client_rust::sel(comment::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            rate: i32,
            txn_hash: String,
            reviews: super::reviews::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                rate::set(rate),
                txn_hash::set(txn_hash),
                reviews::connect(reviews),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            rate: i32,
            review_id: i32,
            txn_hash: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                rate::set(rate),
                review_id::set(review_id),
                txn_hash::set(txn_hash),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(rate, review_id, txn_hash, mut _params)| {
                    _params.extend([
                        rate::set(rate),
                        review_id::set(review_id),
                        txn_hash::set(txn_hash),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (rate, txn_hash, reviews, mut _params): (
                i32,
                String,
                super::reviews::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                rate::set(rate),
                txn_hash::set(txn_hash),
                reviews::connect(reviews),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod reviews {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "reviews";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod rate {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "rate";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRate(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Rate(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Rate(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Rate(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Rate, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementRate(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementRate(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyRate(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideRate(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Rate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Rate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod business_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "business_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBusinessId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BusinessId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BusinessId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::BusinessId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            BusinessId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementBusinessId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementBusinessId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyBusinessId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideBusinessId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BusinessId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BusinessId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUserId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, UserId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod status {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "status";
        pub struct Set(pub self::ReviewStatuses);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetStatus(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Status(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::ReviewStatuses) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Status(direction)
        }
        pub fn equals(value: self::ReviewStatuses) -> WhereParam {
            WhereParam::Status(_prisma::read_filters::ReviewStatusesFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::ReviewStatusesFilter,
            Status,
            {
                fn in_vec(_: Vec<super::super::ReviewStatuses>) -> InVec;
                fn not_in_vec(_: Vec<super::super::ReviewStatuses>) -> NotInVec;
                fn not(_: super::super::ReviewStatuses) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Status(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Status(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod likes {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "likes";
        pub struct Set(pub Vec<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLikes(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Likes(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Likes(direction)
        }
        pub fn equals(value: Vec<i32>) -> WhereParam {
            WhereParam::Likes(_prisma::read_filters::IntListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntListFilter,
            Likes,
            {
                fn has(_: Option<i32>) -> Has;
                fn has_every(_: Vec<i32>) -> HasEvery;
                fn has_some(_: Vec<i32>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<i32>) -> SetParam {
            SetParam::PushLikes(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Likes(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Likes(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod dislikes {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "dislikes";
        pub struct Set(pub Vec<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDislikes(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Dislikes(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Dislikes(direction)
        }
        pub fn equals(value: Vec<i32>) -> WhereParam {
            WhereParam::Dislikes(_prisma::read_filters::IntListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntListFilter,
            Dislikes,
            {
                fn has(_: Option<i32>) -> Has;
                fn has_every(_: Vec<i32>) -> HasEvery;
                fn has_some(_: Vec<i32>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<i32>) -> SetParam {
            SetParam::PushDislikes(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Dislikes(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Dislikes(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod headline {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "headline";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetHeadline(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Headline(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Headline(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Headline(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Headline,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Headline(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Headline(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod comment {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "comment";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetComment(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Comment(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Comment(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Comment(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Comment,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Comment(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Comment(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod txn_hash {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "txn_hash";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTxnHash(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TxnHash(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TxnHash(direction)
        }
        pub fn equals<A, T: ::prisma_client_rust::FromOptionalUniqueArg<Set, Arg = A>>(
            value: A,
        ) -> T {
            T::from_arg(value)
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            TxnHash,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TxnHash(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TxnHash(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod sharings {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "sharings";
        pub struct Set(pub Vec<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSharings(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Sharings(v)
            }
        }
        pub fn set<T: From<Set>>(value: Vec<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Sharings(direction)
        }
        pub fn equals(value: Vec<i32>) -> WhereParam {
            WhereParam::Sharings(_prisma::read_filters::IntListFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntListFilter,
            Sharings,
            {
                fn has(_: Option<i32>) -> Has;
                fn has_every(_: Vec<i32>) -> HasEvery;
                fn has_some(_: Vec<i32>) -> HasSome;
                fn is_empty(_: bool) -> IsEmpty;
            }
        );
        pub fn push(value: Vec<i32>) -> SetParam {
            SetParam::PushSharings(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Sharings(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Sharings(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod activities {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "activities";
        pub struct Fetch(pub activities::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<activities::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: activities::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: activities::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Activities(v)
            }
        }
        pub fn fetch(params: Vec<activities::WhereParam>) -> Fetch {
            Fetch(activities::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<activities::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectActivities(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<activities::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<activities::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectActivities(params)
        }
        pub fn set(params: Vec<activities::UniqueWhereParam>) -> SetParam {
            SetParam::SetActivities(params)
        }
        pub fn some(value: Vec<activities::WhereParam>) -> WhereParam {
            WhereParam::ActivitiesSome(value)
        }
        pub fn every(value: Vec<activities::WhereParam>) -> WhereParam {
            WhereParam::ActivitiesEvery(value)
        }
        pub fn none(value: Vec<activities::WhereParam>) -> WhereParam {
            WhereParam::ActivitiesNone(value)
        }
        pub enum Include {
            Select(activities::ManyArgs, Vec<activities::SelectParam>),
            Include(activities::ManyArgs, Vec<activities::IncludeParam>),
            Fetch(activities::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Activities(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < activities :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <activities::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: activities::ManyArgs,
                nested_selections: Vec<activities::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: activities::ManyArgs,
                nested_selections: Vec<activities::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(activities::ManyArgs, Vec<activities::SelectParam>),
            Include(activities::ManyArgs, Vec<activities::IncludeParam>),
            Fetch(activities::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Activities(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <activities::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: activities::ManyArgs,
                nested_selections: Vec<activities::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: activities::ManyArgs,
                nested_selections: Vec<activities::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod criteria_reviews {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "criteria_reviews";
        pub struct Fetch(pub criteria_reviews::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<criteria_reviews::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: criteria_reviews::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: criteria_reviews::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::CriteriaReviews(v)
            }
        }
        pub fn fetch(params: Vec<criteria_reviews::WhereParam>) -> Fetch {
            Fetch(criteria_reviews::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<criteria_reviews::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectCriteriaReviews(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<criteria_reviews::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<criteria_reviews::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectCriteriaReviews(params)
        }
        pub fn set(params: Vec<criteria_reviews::UniqueWhereParam>) -> SetParam {
            SetParam::SetCriteriaReviews(params)
        }
        pub fn some(value: Vec<criteria_reviews::WhereParam>) -> WhereParam {
            WhereParam::CriteriaReviewsSome(value)
        }
        pub fn every(value: Vec<criteria_reviews::WhereParam>) -> WhereParam {
            WhereParam::CriteriaReviewsEvery(value)
        }
        pub fn none(value: Vec<criteria_reviews::WhereParam>) -> WhereParam {
            WhereParam::CriteriaReviewsNone(value)
        }
        pub enum Include {
            Select(
                criteria_reviews::ManyArgs,
                Vec<criteria_reviews::SelectParam>,
            ),
            Include(
                criteria_reviews::ManyArgs,
                Vec<criteria_reviews::IncludeParam>,
            ),
            Fetch(criteria_reviews::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CriteriaReviews(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < criteria_reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < criteria_reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: criteria_reviews::ManyArgs,
                nested_selections: Vec<criteria_reviews::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: criteria_reviews::ManyArgs,
                nested_selections: Vec<criteria_reviews::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                criteria_reviews::ManyArgs,
                Vec<criteria_reviews::SelectParam>,
            ),
            Include(
                criteria_reviews::ManyArgs,
                Vec<criteria_reviews::IncludeParam>,
            ),
            Fetch(criteria_reviews::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CriteriaReviews(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < criteria_reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: criteria_reviews::ManyArgs,
                nested_selections: Vec<criteria_reviews::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: criteria_reviews::ManyArgs,
                nested_selections: Vec<criteria_reviews::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod notifications {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "notifications";
        pub struct Fetch(pub notifications::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<notifications::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: notifications::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: notifications::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Notifications(v)
            }
        }
        pub fn fetch(params: Vec<notifications::WhereParam>) -> Fetch {
            Fetch(notifications::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<notifications::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectNotifications(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<notifications::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<notifications::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectNotifications(params)
        }
        pub fn set(params: Vec<notifications::UniqueWhereParam>) -> SetParam {
            SetParam::SetNotifications(params)
        }
        pub fn some(value: Vec<notifications::WhereParam>) -> WhereParam {
            WhereParam::NotificationsSome(value)
        }
        pub fn every(value: Vec<notifications::WhereParam>) -> WhereParam {
            WhereParam::NotificationsEvery(value)
        }
        pub fn none(value: Vec<notifications::WhereParam>) -> WhereParam {
            WhereParam::NotificationsNone(value)
        }
        pub enum Include {
            Select(notifications::ManyArgs, Vec<notifications::SelectParam>),
            Include(notifications::ManyArgs, Vec<notifications::IncludeParam>),
            Fetch(notifications::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Notifications(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(notifications::ManyArgs, Vec<notifications::SelectParam>),
            Include(notifications::ManyArgs, Vec<notifications::IncludeParam>),
            Fetch(notifications::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Notifications(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod replies {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "replies";
        pub struct Fetch(pub replies::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<replies::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: replies::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: replies::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Replies(v)
            }
        }
        pub fn fetch(params: Vec<replies::WhereParam>) -> Fetch {
            Fetch(replies::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<replies::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectReplies(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<replies::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<replies::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectReplies(params)
        }
        pub fn set(params: Vec<replies::UniqueWhereParam>) -> SetParam {
            SetParam::SetReplies(params)
        }
        pub fn some(value: Vec<replies::WhereParam>) -> WhereParam {
            WhereParam::RepliesSome(value)
        }
        pub fn every(value: Vec<replies::WhereParam>) -> WhereParam {
            WhereParam::RepliesEvery(value)
        }
        pub fn none(value: Vec<replies::WhereParam>) -> WhereParam {
            WhereParam::RepliesNone(value)
        }
        pub enum Include {
            Select(replies::ManyArgs, Vec<replies::SelectParam>),
            Include(replies::ManyArgs, Vec<replies::IncludeParam>),
            Fetch(replies::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Replies(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <replies::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <replies::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: replies::ManyArgs,
                nested_selections: Vec<replies::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: replies::ManyArgs,
                nested_selections: Vec<replies::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(replies::ManyArgs, Vec<replies::SelectParam>),
            Include(replies::ManyArgs, Vec<replies::IncludeParam>),
            Fetch(replies::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Replies(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <replies::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: replies::ManyArgs,
                nested_selections: Vec<replies::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: replies::ManyArgs,
                nested_selections: Vec<replies::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod review_histories {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "review_histories";
        pub struct Fetch(pub review_histories::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<review_histories::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: review_histories::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: review_histories::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ReviewHistories(v)
            }
        }
        pub fn fetch(params: Vec<review_histories::WhereParam>) -> Fetch {
            Fetch(review_histories::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<review_histories::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectReviewHistories(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<review_histories::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<review_histories::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectReviewHistories(params)
        }
        pub fn set(params: Vec<review_histories::UniqueWhereParam>) -> SetParam {
            SetParam::SetReviewHistories(params)
        }
        pub fn some(value: Vec<review_histories::WhereParam>) -> WhereParam {
            WhereParam::ReviewHistoriesSome(value)
        }
        pub fn every(value: Vec<review_histories::WhereParam>) -> WhereParam {
            WhereParam::ReviewHistoriesEvery(value)
        }
        pub fn none(value: Vec<review_histories::WhereParam>) -> WhereParam {
            WhereParam::ReviewHistoriesNone(value)
        }
        pub enum Include {
            Select(
                review_histories::ManyArgs,
                Vec<review_histories::SelectParam>,
            ),
            Include(
                review_histories::ManyArgs,
                Vec<review_histories::IncludeParam>,
            ),
            Fetch(review_histories::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ReviewHistories(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < review_histories :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < review_histories :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: review_histories::ManyArgs,
                nested_selections: Vec<review_histories::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: review_histories::ManyArgs,
                nested_selections: Vec<review_histories::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                review_histories::ManyArgs,
                Vec<review_histories::SelectParam>,
            ),
            Include(
                review_histories::ManyArgs,
                Vec<review_histories::IncludeParam>,
            ),
            Fetch(review_histories::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ReviewHistories(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < review_histories :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: review_histories::ManyArgs,
                nested_selections: Vec<review_histories::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: review_histories::ManyArgs,
                nested_selections: Vec<review_histories::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "businesses";
        pub struct Fetch(pub businesses::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Businesses(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(businesses::UniqueArgs::new())
        }
        pub struct Connect(businesses::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: businesses::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesIs(value)
        }
        pub fn is_not(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesIsNot(value)
        }
        pub enum Include {
            Select(Vec<businesses::SelectParam>),
            Include(Vec<businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Businesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("businesses", None, [], selections)
            }
            pub fn select(nested_selections: Vec<businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<businesses::SelectParam>),
            Include(Vec<businesses::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Businesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("businesses", None, [], selections)
            }
            pub fn select(nested_selections: Vec<businesses::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<businesses::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Users(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Users(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Users(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        rate: i32,
        businesses: super::businesses::UniqueWhereParam,
        users: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        super::businesses::UniqueWhereParam,
        super::users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (rate, businesses, users, _params)
    }
    pub fn create_unchecked(
        rate: i32,
        business_id: i32,
        user_id: i32,
        _params: Vec<SetParam>,
    ) -> (i32, i32, i32, Vec<SetParam>) {
        (rate, business_id, user_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_reviews { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: reviews :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: reviews :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: reviews :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: reviews :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: reviews :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: reviews :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , rate , business_id , user_id , status , likes , dislikes , headline , comment , txn_hash , sharings , activities , criteria_reviews , notifications , replies , review_histories , businesses , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: reviews :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: reviews :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: reviews :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: reviews :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "rate" , "business_id" , "user_id" , "status" , "likes" , "dislikes" , "headline" , "comment" , "txn_hash" , "sharings" , "activities" , "criteria_reviews" , "notifications" , "replies" , "review_histories" , "businesses" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: reviews :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; rate) => { i32 } ; (@ field_type ; business_id) => { i32 } ; (@ field_type ; user_id) => { i32 } ; (@ field_type ; status) => { crate :: prisma :: ReviewStatuses } ; (@ field_type ; likes) => { Vec < i32 > } ; (@ field_type ; dislikes) => { Vec < i32 > } ; (@ field_type ; headline) => { Option < String > } ; (@ field_type ; comment) => { Option < String > } ; (@ field_type ; txn_hash) => { Option < String > } ; (@ field_type ; sharings) => { Vec < i32 > } ; (@ field_type ; activities : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < activities :: Data > } ; (@ field_type ; activities) => { Vec < crate :: prisma :: activities :: Data > } ; (@ field_type ; criteria_reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < criteria_reviews :: Data > } ; (@ field_type ; criteria_reviews) => { Vec < crate :: prisma :: criteria_reviews :: Data > } ; (@ field_type ; notifications : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < notifications :: Data > } ; (@ field_type ; notifications) => { Vec < crate :: prisma :: notifications :: Data > } ; (@ field_type ; replies : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < replies :: Data > } ; (@ field_type ; replies) => { Vec < crate :: prisma :: replies :: Data > } ; (@ field_type ; review_histories : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < review_histories :: Data > } ; (@ field_type ; review_histories) => { Vec < crate :: prisma :: review_histories :: Data > } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { businesses :: Data } ; (@ field_type ; businesses) => { crate :: prisma :: businesses :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Reviews" , available relations are "id, created_at, rate, business_id, user_id, status, likes, dislikes, headline, comment, txn_hash, sharings, activities, criteria_reviews, notifications, replies, review_histories, businesses, users")) } ; (@ field_module ; activities : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: activities :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; criteria_reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: criteria_reviews :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; notifications : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: notifications :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; replies : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: replies :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; review_histories : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: review_histories :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: created_at :: Select) } ; (@ selection_field_to_selection_param ; rate) => { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: rate :: Select) } ; (@ selection_field_to_selection_param ; business_id) => { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: business_id :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: user_id :: Select) } ; (@ selection_field_to_selection_param ; status) => { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: status :: Select) } ; (@ selection_field_to_selection_param ; likes) => { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: likes :: Select) } ; (@ selection_field_to_selection_param ; dislikes) => { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: dislikes :: Select) } ; (@ selection_field_to_selection_param ; headline) => { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: headline :: Select) } ; (@ selection_field_to_selection_param ; comment) => { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: comment :: Select) } ; (@ selection_field_to_selection_param ; txn_hash) => { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: txn_hash :: Select) } ; (@ selection_field_to_selection_param ; sharings) => { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: sharings :: Select) } ; (@ selection_field_to_selection_param ; activities $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: activities :: Select :: $ selection_mode (crate :: prisma :: activities :: ManyArgs :: new (crate :: prisma :: activities :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: activities :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; activities $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: activities :: Select :: Fetch (crate :: prisma :: activities :: ManyArgs :: new (crate :: prisma :: activities :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; criteria_reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: criteria_reviews :: Select :: $ selection_mode (crate :: prisma :: criteria_reviews :: ManyArgs :: new (crate :: prisma :: criteria_reviews :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: criteria_reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; criteria_reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: criteria_reviews :: Select :: Fetch (crate :: prisma :: criteria_reviews :: ManyArgs :: new (crate :: prisma :: criteria_reviews :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; notifications $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: notifications :: Select :: $ selection_mode (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: notifications :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; notifications $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: notifications :: Select :: Fetch (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; replies $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: replies :: Select :: $ selection_mode (crate :: prisma :: replies :: ManyArgs :: new (crate :: prisma :: replies :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: replies :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; replies $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: replies :: Select :: Fetch (crate :: prisma :: replies :: ManyArgs :: new (crate :: prisma :: replies :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; review_histories $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: review_histories :: Select :: $ selection_mode (crate :: prisma :: review_histories :: ManyArgs :: new (crate :: prisma :: review_histories :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: review_histories :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; review_histories $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: review_histories :: Select :: Fetch (crate :: prisma :: review_histories :: ManyArgs :: new (crate :: prisma :: review_histories :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: businesses :: Select :: $ selection_mode (crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: businesses :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: users :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: SelectParam > :: into (crate :: prisma :: reviews :: users :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: reviews :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; rate) => { "rate" } ; (@ field_serde_name ; business_id) => { "business_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; likes) => { "likes" } ; (@ field_serde_name ; dislikes) => { "dislikes" } ; (@ field_serde_name ; headline) => { "headline" } ; (@ field_serde_name ; comment) => { "comment" } ; (@ field_serde_name ; txn_hash) => { "txn_hash" } ; (@ field_serde_name ; sharings) => { "sharings" } ; (@ field_serde_name ; activities) => { "activities" } ; (@ field_serde_name ; criteria_reviews) => { "criteria_reviews" } ; (@ field_serde_name ; notifications) => { "notifications" } ; (@ field_serde_name ; replies) => { "replies" } ; (@ field_serde_name ; review_histories) => { "review_histories" } ; (@ field_serde_name ; businesses) => { "businesses" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _select_reviews as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        Rate(rate::Select),
        BusinessId(business_id::Select),
        UserId(user_id::Select),
        Status(status::Select),
        Likes(likes::Select),
        Dislikes(dislikes::Select),
        Headline(headline::Select),
        Comment(comment::Select),
        TxnHash(txn_hash::Select),
        Sharings(sharings::Select),
        Activities(activities::Select),
        CriteriaReviews(criteria_reviews::Select),
        Notifications(notifications::Select),
        Replies(replies::Select),
        ReviewHistories(review_histories::Select),
        Businesses(businesses::Select),
        Users(users::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Rate(data) => data.to_selection(),
                Self::BusinessId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::Status(data) => data.to_selection(),
                Self::Likes(data) => data.to_selection(),
                Self::Dislikes(data) => data.to_selection(),
                Self::Headline(data) => data.to_selection(),
                Self::Comment(data) => data.to_selection(),
                Self::TxnHash(data) => data.to_selection(),
                Self::Sharings(data) => data.to_selection(),
                Self::Activities(data) => data.to_selection(),
                Self::CriteriaReviews(data) => data.to_selection(),
                Self::Notifications(data) => data.to_selection(),
                Self::Replies(data) => data.to_selection(),
                Self::ReviewHistories(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_reviews { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: reviews :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: reviews :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: reviews :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: reviews :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: reviews :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: reviews :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { activities , criteria_reviews , notifications , replies , review_histories , businesses , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub rate : i32 , pub business_id : i32 , pub user_id : i32 , pub status : crate :: prisma :: ReviewStatuses , pub likes : Vec < i32 > , pub dislikes : Vec < i32 > , pub headline : Option < String > , pub comment : Option < String > , pub txn_hash : Option < String > , pub sharings : Vec < i32 > , $ (pub $ field : crate :: prisma :: reviews :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (rate) , stringify ! (business_id) , stringify ! (user_id) , stringify ! (status) , stringify ! (likes) , stringify ! (dislikes) , stringify ! (headline) , stringify ! (comment) , stringify ! (txn_hash) , stringify ! (sharings)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: reviews :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: reviews :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: reviews :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: reviews :: rate :: NAME , & self . rate) ? ; state . serialize_field (crate :: prisma :: reviews :: business_id :: NAME , & self . business_id) ? ; state . serialize_field (crate :: prisma :: reviews :: user_id :: NAME , & self . user_id) ? ; state . serialize_field (crate :: prisma :: reviews :: status :: NAME , & self . status) ? ; state . serialize_field (crate :: prisma :: reviews :: likes :: NAME , & self . likes) ? ; state . serialize_field (crate :: prisma :: reviews :: dislikes :: NAME , & self . dislikes) ? ; state . serialize_field (crate :: prisma :: reviews :: headline :: NAME , & self . headline) ? ; state . serialize_field (crate :: prisma :: reviews :: comment :: NAME , & self . comment) ? ; state . serialize_field (crate :: prisma :: reviews :: txn_hash :: NAME , & self . txn_hash) ? ; state . serialize_field (crate :: prisma :: reviews :: sharings :: NAME , & self . sharings) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , rate , business_id , user_id , status , likes , dislikes , headline , comment , txn_hash , sharings } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: reviews :: $ field :: NAME) , + , crate :: prisma :: reviews :: id :: NAME , crate :: prisma :: reviews :: created_at :: NAME , crate :: prisma :: reviews :: rate :: NAME , crate :: prisma :: reviews :: business_id :: NAME , crate :: prisma :: reviews :: user_id :: NAME , crate :: prisma :: reviews :: status :: NAME , crate :: prisma :: reviews :: likes :: NAME , crate :: prisma :: reviews :: dislikes :: NAME , crate :: prisma :: reviews :: headline :: NAME , crate :: prisma :: reviews :: comment :: NAME , crate :: prisma :: reviews :: txn_hash :: NAME , crate :: prisma :: reviews :: sharings :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: reviews :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: reviews :: id :: NAME => Ok (Field :: id) , crate :: prisma :: reviews :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: reviews :: rate :: NAME => Ok (Field :: rate) , crate :: prisma :: reviews :: business_id :: NAME => Ok (Field :: business_id) , crate :: prisma :: reviews :: user_id :: NAME => Ok (Field :: user_id) , crate :: prisma :: reviews :: status :: NAME => Ok (Field :: status) , crate :: prisma :: reviews :: likes :: NAME => Ok (Field :: likes) , crate :: prisma :: reviews :: dislikes :: NAME => Ok (Field :: dislikes) , crate :: prisma :: reviews :: headline :: NAME => Ok (Field :: headline) , crate :: prisma :: reviews :: comment :: NAME => Ok (Field :: comment) , crate :: prisma :: reviews :: txn_hash :: NAME => Ok (Field :: txn_hash) , crate :: prisma :: reviews :: sharings :: NAME => Ok (Field :: sharings) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut rate = None ; let mut business_id = None ; let mut user_id = None ; let mut status = None ; let mut likes = None ; let mut dislikes = None ; let mut headline = None ; let mut comment = None ; let mut txn_hash = None ; let mut sharings = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: rate => { if rate . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: rate :: NAME)) ; } rate = Some (map . next_value () ?) ; } Field :: business_id => { if business_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: business_id :: NAME)) ; } business_id = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: user_id :: NAME)) ; } user_id = Some (map . next_value () ?) ; } Field :: status => { if status . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: status :: NAME)) ; } status = Some (map . next_value () ?) ; } Field :: likes => { if likes . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: likes :: NAME)) ; } likes = Some (map . next_value () ?) ; } Field :: dislikes => { if dislikes . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: dislikes :: NAME)) ; } dislikes = Some (map . next_value () ?) ; } Field :: headline => { if headline . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: headline :: NAME)) ; } headline = Some (map . next_value () ?) ; } Field :: comment => { if comment . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: comment :: NAME)) ; } comment = Some (map . next_value () ?) ; } Field :: txn_hash => { if txn_hash . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: txn_hash :: NAME)) ; } txn_hash = Some (map . next_value () ?) ; } Field :: sharings => { if sharings . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: sharings :: NAME)) ; } sharings = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: reviews :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: created_at :: NAME)) ? ; let rate = rate . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: rate :: NAME)) ? ; let business_id = business_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: business_id :: NAME)) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: user_id :: NAME)) ? ; let status = status . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: status :: NAME)) ? ; let likes = likes . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: likes :: NAME)) ? ; let dislikes = dislikes . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: dislikes :: NAME)) ? ; let headline = headline . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: headline :: NAME)) ? ; let comment = comment . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: comment :: NAME)) ? ; let txn_hash = txn_hash . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: txn_hash :: NAME)) ? ; let sharings = sharings . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: reviews :: sharings :: NAME)) ? ; Ok (Data { id , created_at , rate , business_id , user_id , status , likes , dislikes , headline , comment , txn_hash , sharings , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "rate" , "business_id" , "user_id" , "status" , "likes" , "dislikes" , "headline" , "comment" , "txn_hash" , "sharings" , "activities" , "criteria_reviews" , "notifications" , "replies" , "review_histories" , "businesses" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: reviews :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; activities : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < activities :: Data > } ; (@ field_type ; activities) => { Vec < crate :: prisma :: activities :: Data > } ; (@ field_type ; criteria_reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < criteria_reviews :: Data > } ; (@ field_type ; criteria_reviews) => { Vec < crate :: prisma :: criteria_reviews :: Data > } ; (@ field_type ; notifications : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < notifications :: Data > } ; (@ field_type ; notifications) => { Vec < crate :: prisma :: notifications :: Data > } ; (@ field_type ; replies : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < replies :: Data > } ; (@ field_type ; replies) => { Vec < crate :: prisma :: replies :: Data > } ; (@ field_type ; review_histories : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < review_histories :: Data > } ; (@ field_type ; review_histories) => { Vec < crate :: prisma :: review_histories :: Data > } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { businesses :: Data } ; (@ field_type ; businesses) => { crate :: prisma :: businesses :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Reviews" , available relations are "activities, criteria_reviews, notifications, replies, review_histories, businesses, users")) } ; (@ field_module ; activities : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: activities :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; criteria_reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: criteria_reviews :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; notifications : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: notifications :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; replies : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: replies :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; review_histories : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: review_histories :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; activities $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: activities :: Include :: $ selection_mode (crate :: prisma :: activities :: ManyArgs :: new (crate :: prisma :: activities :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: activities :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; activities $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: activities :: Include :: Fetch (crate :: prisma :: activities :: ManyArgs :: new (crate :: prisma :: activities :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; criteria_reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: criteria_reviews :: Include :: $ selection_mode (crate :: prisma :: criteria_reviews :: ManyArgs :: new (crate :: prisma :: criteria_reviews :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: criteria_reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; criteria_reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: criteria_reviews :: Include :: Fetch (crate :: prisma :: criteria_reviews :: ManyArgs :: new (crate :: prisma :: criteria_reviews :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; notifications $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: notifications :: Include :: $ selection_mode (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: notifications :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; notifications $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: notifications :: Include :: Fetch (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; replies $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: replies :: Include :: $ selection_mode (crate :: prisma :: replies :: ManyArgs :: new (crate :: prisma :: replies :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: replies :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; replies $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: replies :: Include :: Fetch (crate :: prisma :: replies :: ManyArgs :: new (crate :: prisma :: replies :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; review_histories $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: review_histories :: Include :: $ selection_mode (crate :: prisma :: review_histories :: ManyArgs :: new (crate :: prisma :: review_histories :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: review_histories :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; review_histories $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: review_histories :: Include :: Fetch (crate :: prisma :: review_histories :: ManyArgs :: new (crate :: prisma :: review_histories :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: businesses :: Include :: $ selection_mode (crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: businesses :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: users :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: reviews :: IncludeParam > :: into (crate :: prisma :: reviews :: users :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: reviews :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; rate) => { "rate" } ; (@ field_serde_name ; business_id) => { "business_id" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; status) => { "status" } ; (@ field_serde_name ; likes) => { "likes" } ; (@ field_serde_name ; dislikes) => { "dislikes" } ; (@ field_serde_name ; headline) => { "headline" } ; (@ field_serde_name ; comment) => { "comment" } ; (@ field_serde_name ; txn_hash) => { "txn_hash" } ; (@ field_serde_name ; sharings) => { "sharings" } ; (@ field_serde_name ; activities) => { "activities" } ; (@ field_serde_name ; criteria_reviews) => { "criteria_reviews" } ; (@ field_serde_name ; notifications) => { "notifications" } ; (@ field_serde_name ; replies) => { "replies" } ; (@ field_serde_name ; review_histories) => { "review_histories" } ; (@ field_serde_name ; businesses) => { "businesses" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _include_reviews as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        Rate(rate::Include),
        BusinessId(business_id::Include),
        UserId(user_id::Include),
        Status(status::Include),
        Likes(likes::Include),
        Dislikes(dislikes::Include),
        Headline(headline::Include),
        Comment(comment::Include),
        TxnHash(txn_hash::Include),
        Sharings(sharings::Include),
        Activities(activities::Include),
        CriteriaReviews(criteria_reviews::Include),
        Notifications(notifications::Include),
        Replies(replies::Include),
        ReviewHistories(review_histories::Include),
        Businesses(businesses::Include),
        Users(users::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Rate(data) => data.to_selection(),
                Self::BusinessId(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::Status(data) => data.to_selection(),
                Self::Likes(data) => data.to_selection(),
                Self::Dislikes(data) => data.to_selection(),
                Self::Headline(data) => data.to_selection(),
                Self::Comment(data) => data.to_selection(),
                Self::TxnHash(data) => data.to_selection(),
                Self::Sharings(data) => data.to_selection(),
                Self::Activities(data) => data.to_selection(),
                Self::CriteriaReviews(data) => data.to_selection(),
                Self::Notifications(data) => data.to_selection(),
                Self::Replies(data) => data.to_selection(),
                Self::ReviewHistories(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_reviews { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: reviews struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "rate")] pub rate : i32 , # [serde (rename = "business_id")] pub business_id : i32 , # [serde (rename = "user_id")] pub user_id : i32 , # [serde (rename = "status")] pub status : crate :: prisma :: ReviewStatuses , # [serde (rename = "likes")] pub likes : Vec < i32 > , # [serde (rename = "dislikes")] pub dislikes : Vec < i32 > , # [serde (rename = "headline")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub headline : Option < String > , # [serde (rename = "comment")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub comment : Option < String > , # [serde (rename = "txn_hash")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub txn_hash : Option < String > , # [serde (rename = "sharings")] pub sharings : Vec < i32 > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_reviews as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "rate")]
        pub rate: i32,
        #[serde(rename = "business_id")]
        pub business_id: i32,
        #[serde(rename = "user_id")]
        pub user_id: i32,
        #[serde(rename = "status")]
        pub status: super::ReviewStatuses,
        #[serde(rename = "likes")]
        pub likes: Vec<i32>,
        #[serde(rename = "dislikes")]
        pub dislikes: Vec<i32>,
        #[serde(rename = "headline")]
        pub headline: Option<String>,
        #[serde(rename = "comment")]
        pub comment: Option<String>,
        #[serde(rename = "txn_hash")]
        pub txn_hash: Option<String>,
        #[serde(rename = "sharings")]
        pub sharings: Vec<i32>,
        #[serde(rename = "activities")]
        pub activities: Option<Vec<super::activities::Data>>,
        #[serde(rename = "criteria_reviews")]
        pub criteria_reviews: Option<Vec<super::criteria_reviews::Data>>,
        #[serde(rename = "notifications")]
        pub notifications: Option<Vec<super::notifications::Data>>,
        #[serde(rename = "replies")]
        pub replies: Option<Vec<super::replies::Data>>,
        #[serde(rename = "review_histories")]
        pub review_histories: Option<Vec<super::review_histories::Data>>,
        #[serde(rename = "businesses")]
        pub businesses: Option<Box<super::businesses::Data>>,
        #[serde(rename = "users")]
        pub users: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn activities(
            &self,
        ) -> Result<&Vec<super::activities::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.activities
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(activities),
                ))
        }
        pub fn criteria_reviews(
            &self,
        ) -> Result<
            &Vec<super::criteria_reviews::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.criteria_reviews.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(criteria_reviews)),
            )
        }
        pub fn notifications(
            &self,
        ) -> Result<&Vec<super::notifications::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.notifications
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(notifications),
                ))
        }
        pub fn replies(
            &self,
        ) -> Result<&Vec<super::replies::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.replies
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(replies),
                ))
        }
        pub fn review_histories(
            &self,
        ) -> Result<
            &Vec<super::review_histories::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.review_histories.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(review_histories)),
            )
        }
        pub fn businesses(
            &self,
        ) -> Result<&super::businesses::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.businesses
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(businesses),
                ))
                .map(|v| v.as_ref())
        }
        pub fn users(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Activities(super::activities::ManyArgs),
        CriteriaReviews(super::criteria_reviews::ManyArgs),
        Notifications(super::notifications::ManyArgs),
        Replies(super::replies::ManyArgs),
        ReviewHistories(super::review_histories::ManyArgs),
        Businesses(super::businesses::UniqueArgs),
        Users(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Activities(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: activities :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        activities::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::CriteriaReviews(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: criteria_reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        criteria_reviews::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Notifications(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        notifications::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Replies(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: replies :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        replies::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::ReviewHistories(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: review_histories :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        review_histories::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Businesses(args) => {
                    let mut selections = < super :: businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(businesses::NAME, None, [], selections)
                }
                Self::Users(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(users::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetRate(i32),
        IncrementRate(i32),
        DecrementRate(i32),
        MultiplyRate(i32),
        DivideRate(i32),
        SetBusinessId(i32),
        IncrementBusinessId(i32),
        DecrementBusinessId(i32),
        MultiplyBusinessId(i32),
        DivideBusinessId(i32),
        SetUserId(i32),
        IncrementUserId(i32),
        DecrementUserId(i32),
        MultiplyUserId(i32),
        DivideUserId(i32),
        SetStatus(super::ReviewStatuses),
        SetLikes(Vec<i32>),
        PushLikes(Vec<i32>),
        SetDislikes(Vec<i32>),
        PushDislikes(Vec<i32>),
        SetHeadline(Option<String>),
        SetComment(Option<String>),
        SetTxnHash(Option<String>),
        SetSharings(Vec<i32>),
        PushSharings(Vec<i32>),
        ConnectActivities(Vec<super::activities::UniqueWhereParam>),
        DisconnectActivities(Vec<super::activities::UniqueWhereParam>),
        SetActivities(Vec<super::activities::UniqueWhereParam>),
        ConnectCriteriaReviews(Vec<super::criteria_reviews::UniqueWhereParam>),
        DisconnectCriteriaReviews(Vec<super::criteria_reviews::UniqueWhereParam>),
        SetCriteriaReviews(Vec<super::criteria_reviews::UniqueWhereParam>),
        ConnectNotifications(Vec<super::notifications::UniqueWhereParam>),
        DisconnectNotifications(Vec<super::notifications::UniqueWhereParam>),
        SetNotifications(Vec<super::notifications::UniqueWhereParam>),
        ConnectReplies(Vec<super::replies::UniqueWhereParam>),
        DisconnectReplies(Vec<super::replies::UniqueWhereParam>),
        SetReplies(Vec<super::replies::UniqueWhereParam>),
        ConnectReviewHistories(Vec<super::review_histories::UniqueWhereParam>),
        DisconnectReviewHistories(Vec<super::review_histories::UniqueWhereParam>),
        SetReviewHistories(Vec<super::review_histories::UniqueWhereParam>),
        ConnectBusinesses(super::businesses::UniqueWhereParam),
        ConnectUsers(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetRate(value) => (
                    rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementRate(value) => (
                    rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementRate(value) => (
                    rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyRate(value) => (
                    rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideRate(value) => (
                    rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideBusinessId(value) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetStatus(value) => (
                    status::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetLikes(value) => (
                    likes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .collect(),
                    ),
                ),
                SetParam::PushLikes(value) => (
                    likes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetDislikes(value) => (
                    dislikes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .collect(),
                    ),
                ),
                SetParam::PushDislikes(value) => (
                    dislikes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetHeadline(value) => (
                    headline::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetComment(value) => (
                    comment::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetTxnHash(value) => (
                    txn_hash::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetSharings(value) => (
                    sharings::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::List(
                        value
                            .into_iter()
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .collect(),
                    ),
                ),
                SetParam::PushSharings(value) => (
                    sharings::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "push".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            value
                                .into_iter()
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectActivities(where_params) => (
                    activities::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::activities::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectActivities(where_params) => (
                    activities::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::activities::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetActivities(where_params) => (
                    activities::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::activities::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectCriteriaReviews(where_params) => (
                    criteria_reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::criteria_reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectCriteriaReviews(where_params) => (
                    criteria_reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::criteria_reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetCriteriaReviews(where_params) => (
                    criteria_reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::criteria_reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectNotifications(where_params) => (
                    notifications::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::notifications::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectNotifications(where_params) => (
                    notifications::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::notifications::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetNotifications(where_params) => (
                    notifications::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::notifications::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectReplies(where_params) => (
                    replies::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::replies::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectReplies(where_params) => (
                    replies::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::replies::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetReplies(where_params) => (
                    replies::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::replies::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectReviewHistories(where_params) => (
                    review_histories::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::review_histories::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectReviewHistories(where_params) => (
                    review_histories::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::review_histories::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetReviewHistories(where_params) => (
                    review_histories::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::review_histories::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectBusinesses(where_param) => (
                    businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUsers(where_param) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        Rate(i32),
        BusinessId(i32),
        UserId(i32),
        Status(super::ReviewStatuses),
        Likes(Vec<i32>),
        Dislikes(Vec<i32>),
        Headline(Option<String>),
        Comment(Option<String>),
        TxnHash(Option<String>),
        Sharings(Vec<i32>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::Rate(value) => Self::SetRate(value),
                UncheckedSetParam::BusinessId(value) => Self::SetBusinessId(value),
                UncheckedSetParam::UserId(value) => Self::SetUserId(value),
                UncheckedSetParam::Status(value) => Self::SetStatus(value),
                UncheckedSetParam::Likes(value) => Self::SetLikes(value),
                UncheckedSetParam::Dislikes(value) => Self::SetDislikes(value),
                UncheckedSetParam::Headline(value) => Self::SetHeadline(value),
                UncheckedSetParam::Comment(value) => Self::SetComment(value),
                UncheckedSetParam::TxnHash(value) => Self::SetTxnHash(value),
                UncheckedSetParam::Sharings(value) => Self::SetSharings(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        Rate(::prisma_client_rust::Direction),
        BusinessId(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
        Status(::prisma_client_rust::Direction),
        Likes(::prisma_client_rust::Direction),
        Dislikes(::prisma_client_rust::Direction),
        Headline(::prisma_client_rust::Direction),
        Comment(::prisma_client_rust::Direction),
        TxnHash(::prisma_client_rust::Direction),
        Sharings(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Rate(direction) => (
                    rate::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::BusinessId(direction) => (
                    business_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Status(direction) => (
                    status::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Likes(direction) => (
                    likes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Dislikes(direction) => (
                    dislikes::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Headline(direction) => (
                    headline::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Comment(direction) => (
                    comment::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TxnHash(direction) => (
                    txn_hash::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Sharings(direction) => (
                    sharings::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        Rate(_prisma::read_filters::IntFilter),
        BusinessId(_prisma::read_filters::IntFilter),
        UserId(_prisma::read_filters::IntFilter),
        Status(_prisma::read_filters::ReviewStatusesFilter),
        Likes(_prisma::read_filters::IntListFilter),
        Dislikes(_prisma::read_filters::IntListFilter),
        Headline(_prisma::read_filters::StringNullableFilter),
        Comment(_prisma::read_filters::StringNullableFilter),
        TxnHash(_prisma::read_filters::StringNullableFilter),
        Sharings(_prisma::read_filters::IntListFilter),
        ActivitiesSome(Vec<super::activities::WhereParam>),
        ActivitiesEvery(Vec<super::activities::WhereParam>),
        ActivitiesNone(Vec<super::activities::WhereParam>),
        CriteriaReviewsSome(Vec<super::criteria_reviews::WhereParam>),
        CriteriaReviewsEvery(Vec<super::criteria_reviews::WhereParam>),
        CriteriaReviewsNone(Vec<super::criteria_reviews::WhereParam>),
        NotificationsSome(Vec<super::notifications::WhereParam>),
        NotificationsEvery(Vec<super::notifications::WhereParam>),
        NotificationsNone(Vec<super::notifications::WhereParam>),
        RepliesSome(Vec<super::replies::WhereParam>),
        RepliesEvery(Vec<super::replies::WhereParam>),
        RepliesNone(Vec<super::replies::WhereParam>),
        ReviewHistoriesSome(Vec<super::review_histories::WhereParam>),
        ReviewHistoriesEvery(Vec<super::review_histories::WhereParam>),
        ReviewHistoriesNone(Vec<super::review_histories::WhereParam>),
        BusinessesIs(Vec<super::businesses::WhereParam>),
        BusinessesIsNot(Vec<super::businesses::WhereParam>),
        UsersIs(Vec<super::users::WhereParam>),
        UsersIsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::Rate(value) => (rate::NAME, value.into()),
                Self::BusinessId(value) => (business_id::NAME, value.into()),
                Self::UserId(value) => (user_id::NAME, value.into()),
                Self::Status(value) => (status::NAME, value.into()),
                Self::Likes(value) => (likes::NAME, value.into()),
                Self::Dislikes(value) => (dislikes::NAME, value.into()),
                Self::Headline(value) => (headline::NAME, value.into()),
                Self::Comment(value) => (comment::NAME, value.into()),
                Self::TxnHash(value) => (txn_hash::NAME, value.into()),
                Self::Sharings(value) => (sharings::NAME, value.into()),
                Self::ActivitiesSome(where_params) => (
                    activities::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActivitiesEvery(where_params) => (
                    activities::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActivitiesNone(where_params) => (
                    activities::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CriteriaReviewsSome(where_params) => (
                    criteria_reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CriteriaReviewsEvery(where_params) => (
                    criteria_reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CriteriaReviewsNone(where_params) => (
                    criteria_reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotificationsSome(where_params) => (
                    notifications::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotificationsEvery(where_params) => (
                    notifications::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotificationsNone(where_params) => (
                    notifications::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepliesSome(where_params) => (
                    replies::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepliesEvery(where_params) => (
                    replies::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepliesNone(where_params) => (
                    replies::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewHistoriesSome(where_params) => (
                    review_histories::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewHistoriesEvery(where_params) => (
                    review_histories::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewHistoriesNone(where_params) => (
                    review_histories::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BusinessesIs(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BusinessesIsNot(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIs(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIsNot(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        TxnHashEquals(String),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::TxnHashEquals(value) => Self::TxnHash(
                    _prisma::read_filters::StringNullableFilter::Equals(Some(value)),
                ),
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl ::prisma_client_rust::FromOptionalUniqueArg<txn_hash::Set> for WhereParam {
        type Arg = Option<String>;
        fn from_arg(arg: Self::Arg) -> Self
        where
            Self: Sized,
        {
            Self::TxnHash(_prisma::read_filters::StringNullableFilter::Equals(arg))
        }
    }
    impl ::prisma_client_rust::FromOptionalUniqueArg<txn_hash::Set> for UniqueWhereParam {
        type Arg = String;
        fn from_arg(arg: Self::Arg) -> Self
        where
            Self: Sized,
        {
            Self::TxnHashEquals(arg)
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(rate::NAME),
                ::prisma_client_rust::sel(business_id::NAME),
                ::prisma_client_rust::sel(user_id::NAME),
                ::prisma_client_rust::sel(status::NAME),
                ::prisma_client_rust::sel(likes::NAME),
                ::prisma_client_rust::sel(dislikes::NAME),
                ::prisma_client_rust::sel(headline::NAME),
                ::prisma_client_rust::sel(comment::NAME),
                ::prisma_client_rust::sel(txn_hash::NAME),
                ::prisma_client_rust::sel(sharings::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            rate: i32,
            businesses: super::businesses::UniqueWhereParam,
            users: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                rate::set(rate),
                businesses::connect(businesses),
                users::connect(users),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            rate: i32,
            business_id: i32,
            user_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                rate::set(rate),
                business_id::set(business_id),
                user_id::set(user_id),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(rate, business_id, user_id, mut _params)| {
                    _params.extend([
                        rate::set(rate),
                        business_id::set(business_id),
                        user_id::set(user_id),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (rate, businesses, users, mut _params): (
                i32,
                super::businesses::UniqueWhereParam,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                rate::set(rate),
                businesses::connect(businesses),
                users::connect(users),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod search_params {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "search_params";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod business_name {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "business_name";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBusinessName(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BusinessName(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BusinessName(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::BusinessNameEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            BusinessName,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BusinessName(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BusinessName(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod times {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "times";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTimes(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Times(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Times(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Times(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Times, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementTimes(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementTimes(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyTimes(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideTimes(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Times(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Times(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub fn create(
        business_name: String,
        times: i32,
        _params: Vec<SetParam>,
    ) -> (String, i32, Vec<SetParam>) {
        (business_name, times, _params)
    }
    pub fn create_unchecked(
        business_name: String,
        times: i32,
        _params: Vec<SetParam>,
    ) -> (String, i32, Vec<SetParam>) {
        (business_name, times, _params)
    }
    #[macro_export]
    macro_rules ! _select_search_params { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: search_params :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: search_params :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: search_params :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: search_params :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: search_params :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: search_params :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , business_name , times } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: search_params :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: search_params :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: search_params :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: search_params :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: search_params :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: search_params :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "business_name" , "times"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: search_params :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; business_name) => { String } ; (@ field_type ; times) => { i32 } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SearchParams" , available relations are "id, business_name, times")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: search_params :: SelectParam > :: into (crate :: prisma :: search_params :: id :: Select) } ; (@ selection_field_to_selection_param ; business_name) => { Into :: < crate :: prisma :: search_params :: SelectParam > :: into (crate :: prisma :: search_params :: business_name :: Select) } ; (@ selection_field_to_selection_param ; times) => { Into :: < crate :: prisma :: search_params :: SelectParam > :: into (crate :: prisma :: search_params :: times :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: search_params :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; business_name) => { "business_name" } ; (@ field_serde_name ; times) => { "times" } ; }
    pub use _select_search_params as select;
    pub enum SelectParam {
        Id(id::Select),
        BusinessName(business_name::Select),
        Times(times::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::BusinessName(data) => data.to_selection(),
                Self::Times(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_search_params { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: search_params :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: search_params :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: search_params :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: search_params :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: search_params :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: search_params :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: search_params :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: search_params :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub business_name : String , pub times : i32 , $ (pub $ field : crate :: prisma :: search_params :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (business_name) , stringify ! (times)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: search_params :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: search_params :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: search_params :: business_name :: NAME , & self . business_name) ? ; state . serialize_field (crate :: prisma :: search_params :: times :: NAME , & self . times) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , business_name , times } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: search_params :: $ field :: NAME) , + , crate :: prisma :: search_params :: id :: NAME , crate :: prisma :: search_params :: business_name :: NAME , crate :: prisma :: search_params :: times :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: search_params :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: search_params :: id :: NAME => Ok (Field :: id) , crate :: prisma :: search_params :: business_name :: NAME => Ok (Field :: business_name) , crate :: prisma :: search_params :: times :: NAME => Ok (Field :: times) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut business_name = None ; let mut times = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: search_params :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: business_name => { if business_name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: search_params :: business_name :: NAME)) ; } business_name = Some (map . next_value () ?) ; } Field :: times => { if times . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: search_params :: times :: NAME)) ; } times = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: search_params :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: search_params :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: search_params :: id :: NAME)) ? ; let business_name = business_name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: search_params :: business_name :: NAME)) ? ; let times = times . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: search_params :: times :: NAME)) ? ; Ok (Data { id , business_name , times , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "business_name" , "times"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: search_params :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SearchParams" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: search_params :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; business_name) => { "business_name" } ; (@ field_serde_name ; times) => { "times" } ; }
    pub use _include_search_params as include;
    pub enum IncludeParam {
        Id(id::Include),
        BusinessName(business_name::Include),
        Times(times::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::BusinessName(data) => data.to_selection(),
                Self::Times(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_search_params { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: search_params struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "business_name")] pub business_name : String , # [serde (rename = "times")] pub times : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_search_params as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "business_name")]
        pub business_name: String,
        #[serde(rename = "times")]
        pub times: i32,
    }
    impl Data {}
    #[derive(Clone)]
    pub enum WithParam {}
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {}
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetBusinessName(String),
        SetTimes(i32),
        IncrementTimes(i32),
        DecrementTimes(i32),
        MultiplyTimes(i32),
        DivideTimes(i32),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetBusinessName(value) => (
                    business_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTimes(value) => (
                    times::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementTimes(value) => (
                    times::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementTimes(value) => (
                    times::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyTimes(value) => (
                    times::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideTimes(value) => (
                    times::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        BusinessName(String),
        Times(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::BusinessName(value) => Self::SetBusinessName(value),
                UncheckedSetParam::Times(value) => Self::SetTimes(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        BusinessName(::prisma_client_rust::Direction),
        Times(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::BusinessName(direction) => (
                    business_name::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Times(direction) => (
                    times::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        BusinessName(_prisma::read_filters::StringFilter),
        Times(_prisma::read_filters::IntFilter),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::BusinessName(value) => (business_name::NAME, value.into()),
                Self::Times(value) => (times::NAME, value.into()),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        BusinessNameEquals(String),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::BusinessNameEquals(value) => {
                    Self::BusinessName(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(business_name::NAME),
                ::prisma_client_rust::sel(times::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            business_name: String,
            times: i32,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([business_name::set(business_name), times::set(times)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            business_name: String,
            times: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([business_name::set(business_name), times::set(times)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(business_name, times, mut _params)| {
                    _params.extend([business_name::set(business_name), times::set(times)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (business_name, times, mut _params): (String, i32, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([business_name::set(business_name), times::set(times)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod socials {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "socials";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod last_update {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "last_update";
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLastUpdate(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::LastUpdate(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LastUpdate(direction)
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::LastUpdate(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeNullableFilter,
            LastUpdate,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: Option<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LastUpdate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LastUpdate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod twitter_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "twitterId";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTwitterId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TwitterId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TwitterId(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::TwitterId(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            TwitterId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TwitterId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TwitterId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod twitter {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "twitter";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTwitter(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Twitter(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Twitter(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Twitter(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Twitter,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Twitter(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Twitter(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod discord_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "discordId";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDiscordId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::DiscordId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DiscordId(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::DiscordId(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            DiscordId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DiscordId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DiscordId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod discord {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "discord";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDiscord(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Discord(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Discord(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Discord(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Discord,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Discord(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Discord(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod telegram_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "telegramId";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTelegramId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TelegramId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TelegramId(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::TelegramId(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            TelegramId,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TelegramId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TelegramId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod telegram {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "telegram";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTelegram(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Telegram(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Telegram(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Telegram(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Telegram,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Telegram(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Telegram(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUserId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::UserIdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, UserId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Users(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Users(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Users(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn create(
        users: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (super::users::UniqueWhereParam, Vec<SetParam>) {
        (users, _params)
    }
    pub fn create_unchecked(user_id: i32, _params: Vec<SetParam>) -> (i32, Vec<SetParam>) {
        (user_id, _params)
    }
    #[macro_export]
    macro_rules ! _select_socials { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: socials :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: socials :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: socials :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: socials :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: socials :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: socials :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , last_update , twitter_id , twitter , discord_id , discord , telegram_id , telegram , user_id , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: socials :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: socials :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: socials :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: socials :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: socials :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: socials :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "last_update" , "twitterId" , "twitter" , "discordId" , "discord" , "telegramId" , "telegram" , "user_id" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: socials :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; last_update) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; twitter_id) => { Option < String > } ; (@ field_type ; twitter) => { Option < String > } ; (@ field_type ; discord_id) => { Option < String > } ; (@ field_type ; discord) => { Option < String > } ; (@ field_type ; telegram_id) => { Option < String > } ; (@ field_type ; telegram) => { Option < String > } ; (@ field_type ; user_id) => { i32 } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Socials" , available relations are "id, last_update, twitter_id, twitter, discord_id, discord, telegram_id, telegram, user_id, users")) } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: socials :: SelectParam > :: into (crate :: prisma :: socials :: id :: Select) } ; (@ selection_field_to_selection_param ; last_update) => { Into :: < crate :: prisma :: socials :: SelectParam > :: into (crate :: prisma :: socials :: last_update :: Select) } ; (@ selection_field_to_selection_param ; twitter_id) => { Into :: < crate :: prisma :: socials :: SelectParam > :: into (crate :: prisma :: socials :: twitter_id :: Select) } ; (@ selection_field_to_selection_param ; twitter) => { Into :: < crate :: prisma :: socials :: SelectParam > :: into (crate :: prisma :: socials :: twitter :: Select) } ; (@ selection_field_to_selection_param ; discord_id) => { Into :: < crate :: prisma :: socials :: SelectParam > :: into (crate :: prisma :: socials :: discord_id :: Select) } ; (@ selection_field_to_selection_param ; discord) => { Into :: < crate :: prisma :: socials :: SelectParam > :: into (crate :: prisma :: socials :: discord :: Select) } ; (@ selection_field_to_selection_param ; telegram_id) => { Into :: < crate :: prisma :: socials :: SelectParam > :: into (crate :: prisma :: socials :: telegram_id :: Select) } ; (@ selection_field_to_selection_param ; telegram) => { Into :: < crate :: prisma :: socials :: SelectParam > :: into (crate :: prisma :: socials :: telegram :: Select) } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < crate :: prisma :: socials :: SelectParam > :: into (crate :: prisma :: socials :: user_id :: Select) } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: socials :: SelectParam > :: into (crate :: prisma :: socials :: users :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: socials :: SelectParam > :: into (crate :: prisma :: socials :: users :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: socials :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; last_update) => { "last_update" } ; (@ field_serde_name ; twitter_id) => { "twitterId" } ; (@ field_serde_name ; twitter) => { "twitter" } ; (@ field_serde_name ; discord_id) => { "discordId" } ; (@ field_serde_name ; discord) => { "discord" } ; (@ field_serde_name ; telegram_id) => { "telegramId" } ; (@ field_serde_name ; telegram) => { "telegram" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _select_socials as select;
    pub enum SelectParam {
        Id(id::Select),
        LastUpdate(last_update::Select),
        TwitterId(twitter_id::Select),
        Twitter(twitter::Select),
        DiscordId(discord_id::Select),
        Discord(discord::Select),
        TelegramId(telegram_id::Select),
        Telegram(telegram::Select),
        UserId(user_id::Select),
        Users(users::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::LastUpdate(data) => data.to_selection(),
                Self::TwitterId(data) => data.to_selection(),
                Self::Twitter(data) => data.to_selection(),
                Self::DiscordId(data) => data.to_selection(),
                Self::Discord(data) => data.to_selection(),
                Self::TelegramId(data) => data.to_selection(),
                Self::Telegram(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_socials { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: socials :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: socials :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: socials :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: socials :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: socials :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: socials :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: socials :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: socials :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub last_update : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , pub twitter_id : Option < String > , pub twitter : Option < String > , pub discord_id : Option < String > , pub discord : Option < String > , pub telegram_id : Option < String > , pub telegram : Option < String > , pub user_id : i32 , $ (pub $ field : crate :: prisma :: socials :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (last_update) , stringify ! (twitter_id) , stringify ! (twitter) , stringify ! (discord_id) , stringify ! (discord) , stringify ! (telegram_id) , stringify ! (telegram) , stringify ! (user_id)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: socials :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: socials :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: socials :: last_update :: NAME , & self . last_update) ? ; state . serialize_field (crate :: prisma :: socials :: twitter_id :: NAME , & self . twitter_id) ? ; state . serialize_field (crate :: prisma :: socials :: twitter :: NAME , & self . twitter) ? ; state . serialize_field (crate :: prisma :: socials :: discord_id :: NAME , & self . discord_id) ? ; state . serialize_field (crate :: prisma :: socials :: discord :: NAME , & self . discord) ? ; state . serialize_field (crate :: prisma :: socials :: telegram_id :: NAME , & self . telegram_id) ? ; state . serialize_field (crate :: prisma :: socials :: telegram :: NAME , & self . telegram) ? ; state . serialize_field (crate :: prisma :: socials :: user_id :: NAME , & self . user_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , last_update , twitter_id , twitter , discord_id , discord , telegram_id , telegram , user_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: socials :: $ field :: NAME) , + , crate :: prisma :: socials :: id :: NAME , crate :: prisma :: socials :: last_update :: NAME , crate :: prisma :: socials :: twitter_id :: NAME , crate :: prisma :: socials :: twitter :: NAME , crate :: prisma :: socials :: discord_id :: NAME , crate :: prisma :: socials :: discord :: NAME , crate :: prisma :: socials :: telegram_id :: NAME , crate :: prisma :: socials :: telegram :: NAME , crate :: prisma :: socials :: user_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: socials :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: socials :: id :: NAME => Ok (Field :: id) , crate :: prisma :: socials :: last_update :: NAME => Ok (Field :: last_update) , crate :: prisma :: socials :: twitter_id :: NAME => Ok (Field :: twitter_id) , crate :: prisma :: socials :: twitter :: NAME => Ok (Field :: twitter) , crate :: prisma :: socials :: discord_id :: NAME => Ok (Field :: discord_id) , crate :: prisma :: socials :: discord :: NAME => Ok (Field :: discord) , crate :: prisma :: socials :: telegram_id :: NAME => Ok (Field :: telegram_id) , crate :: prisma :: socials :: telegram :: NAME => Ok (Field :: telegram) , crate :: prisma :: socials :: user_id :: NAME => Ok (Field :: user_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut last_update = None ; let mut twitter_id = None ; let mut twitter = None ; let mut discord_id = None ; let mut discord = None ; let mut telegram_id = None ; let mut telegram = None ; let mut user_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: socials :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: last_update => { if last_update . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: socials :: last_update :: NAME)) ; } last_update = Some (map . next_value () ?) ; } Field :: twitter_id => { if twitter_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: socials :: twitter_id :: NAME)) ; } twitter_id = Some (map . next_value () ?) ; } Field :: twitter => { if twitter . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: socials :: twitter :: NAME)) ; } twitter = Some (map . next_value () ?) ; } Field :: discord_id => { if discord_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: socials :: discord_id :: NAME)) ; } discord_id = Some (map . next_value () ?) ; } Field :: discord => { if discord . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: socials :: discord :: NAME)) ; } discord = Some (map . next_value () ?) ; } Field :: telegram_id => { if telegram_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: socials :: telegram_id :: NAME)) ; } telegram_id = Some (map . next_value () ?) ; } Field :: telegram => { if telegram . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: socials :: telegram :: NAME)) ; } telegram = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: socials :: user_id :: NAME)) ; } user_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: socials :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: socials :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: socials :: id :: NAME)) ? ; let last_update = last_update . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: socials :: last_update :: NAME)) ? ; let twitter_id = twitter_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: socials :: twitter_id :: NAME)) ? ; let twitter = twitter . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: socials :: twitter :: NAME)) ? ; let discord_id = discord_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: socials :: discord_id :: NAME)) ? ; let discord = discord . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: socials :: discord :: NAME)) ? ; let telegram_id = telegram_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: socials :: telegram_id :: NAME)) ? ; let telegram = telegram . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: socials :: telegram :: NAME)) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: socials :: user_id :: NAME)) ? ; Ok (Data { id , last_update , twitter_id , twitter , discord_id , discord , telegram_id , telegram , user_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "last_update" , "twitterId" , "twitter" , "discordId" , "discord" , "telegramId" , "telegram" , "user_id" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: socials :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Socials" , available relations are "users")) } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: socials :: IncludeParam > :: into (crate :: prisma :: socials :: users :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: socials :: IncludeParam > :: into (crate :: prisma :: socials :: users :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: socials :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; last_update) => { "last_update" } ; (@ field_serde_name ; twitter_id) => { "twitterId" } ; (@ field_serde_name ; twitter) => { "twitter" } ; (@ field_serde_name ; discord_id) => { "discordId" } ; (@ field_serde_name ; discord) => { "discord" } ; (@ field_serde_name ; telegram_id) => { "telegramId" } ; (@ field_serde_name ; telegram) => { "telegram" } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _include_socials as include;
    pub enum IncludeParam {
        Id(id::Include),
        LastUpdate(last_update::Include),
        TwitterId(twitter_id::Include),
        Twitter(twitter::Include),
        DiscordId(discord_id::Include),
        Discord(discord::Include),
        TelegramId(telegram_id::Include),
        Telegram(telegram::Include),
        UserId(user_id::Include),
        Users(users::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::LastUpdate(data) => data.to_selection(),
                Self::TwitterId(data) => data.to_selection(),
                Self::Twitter(data) => data.to_selection(),
                Self::DiscordId(data) => data.to_selection(),
                Self::Discord(data) => data.to_selection(),
                Self::TelegramId(data) => data.to_selection(),
                Self::Telegram(data) => data.to_selection(),
                Self::UserId(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_socials { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: socials struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "last_update")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub last_update : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "twitterId")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub twitter_id : Option < String > , # [serde (rename = "twitter")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub twitter : Option < String > , # [serde (rename = "discordId")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub discord_id : Option < String > , # [serde (rename = "discord")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub discord : Option < String > , # [serde (rename = "telegramId")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub telegram_id : Option < String > , # [serde (rename = "telegram")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub telegram : Option < String > , # [serde (rename = "user_id")] pub user_id : i32 } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_socials as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "last_update")]
        pub last_update: Option<
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        >,
        #[serde(rename = "twitterId")]
        pub twitter_id: Option<String>,
        #[serde(rename = "twitter")]
        pub twitter: Option<String>,
        #[serde(rename = "discordId")]
        pub discord_id: Option<String>,
        #[serde(rename = "discord")]
        pub discord: Option<String>,
        #[serde(rename = "telegramId")]
        pub telegram_id: Option<String>,
        #[serde(rename = "telegram")]
        pub telegram: Option<String>,
        #[serde(rename = "user_id")]
        pub user_id: i32,
        #[serde(rename = "users")]
        pub users: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn users(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Users(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Users(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(users::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetLastUpdate(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        SetTwitterId(Option<String>),
        SetTwitter(Option<String>),
        SetDiscordId(Option<String>),
        SetDiscord(Option<String>),
        SetTelegramId(Option<String>),
        SetTelegram(Option<String>),
        SetUserId(i32),
        IncrementUserId(i32),
        DecrementUserId(i32),
        MultiplyUserId(i32),
        DivideUserId(i32),
        ConnectUsers(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetLastUpdate(value) => (
                    last_update::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetTwitterId(value) => (
                    twitter_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetTwitter(value) => (
                    twitter::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetDiscordId(value) => (
                    discord_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetDiscord(value) => (
                    discord::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetTelegramId(value) => (
                    telegram_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetTelegram(value) => (
                    telegram::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::ConnectUsers(where_param) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        LastUpdate(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        TwitterId(Option<String>),
        Twitter(Option<String>),
        DiscordId(Option<String>),
        Discord(Option<String>),
        TelegramId(Option<String>),
        Telegram(Option<String>),
        UserId(i32),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::LastUpdate(value) => Self::SetLastUpdate(value),
                UncheckedSetParam::TwitterId(value) => Self::SetTwitterId(value),
                UncheckedSetParam::Twitter(value) => Self::SetTwitter(value),
                UncheckedSetParam::DiscordId(value) => Self::SetDiscordId(value),
                UncheckedSetParam::Discord(value) => Self::SetDiscord(value),
                UncheckedSetParam::TelegramId(value) => Self::SetTelegramId(value),
                UncheckedSetParam::Telegram(value) => Self::SetTelegram(value),
                UncheckedSetParam::UserId(value) => Self::SetUserId(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        LastUpdate(::prisma_client_rust::Direction),
        TwitterId(::prisma_client_rust::Direction),
        Twitter(::prisma_client_rust::Direction),
        DiscordId(::prisma_client_rust::Direction),
        Discord(::prisma_client_rust::Direction),
        TelegramId(::prisma_client_rust::Direction),
        Telegram(::prisma_client_rust::Direction),
        UserId(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::LastUpdate(direction) => (
                    last_update::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TwitterId(direction) => (
                    twitter_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Twitter(direction) => (
                    twitter::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DiscordId(direction) => (
                    discord_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Discord(direction) => (
                    discord::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TelegramId(direction) => (
                    telegram_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Telegram(direction) => (
                    telegram::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        LastUpdate(_prisma::read_filters::DateTimeNullableFilter),
        TwitterId(_prisma::read_filters::StringNullableFilter),
        Twitter(_prisma::read_filters::StringNullableFilter),
        DiscordId(_prisma::read_filters::StringNullableFilter),
        Discord(_prisma::read_filters::StringNullableFilter),
        TelegramId(_prisma::read_filters::StringNullableFilter),
        Telegram(_prisma::read_filters::StringNullableFilter),
        UserId(_prisma::read_filters::IntFilter),
        UsersIs(Vec<super::users::WhereParam>),
        UsersIsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::LastUpdate(value) => (last_update::NAME, value.into()),
                Self::TwitterId(value) => (twitter_id::NAME, value.into()),
                Self::Twitter(value) => (twitter::NAME, value.into()),
                Self::DiscordId(value) => (discord_id::NAME, value.into()),
                Self::Discord(value) => (discord::NAME, value.into()),
                Self::TelegramId(value) => (telegram_id::NAME, value.into()),
                Self::Telegram(value) => (telegram::NAME, value.into()),
                Self::UserId(value) => (user_id::NAME, value.into()),
                Self::UsersIs(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIsNot(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        UserIdEquals(i32),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::UserIdEquals(value) => {
                    Self::UserId(_prisma::read_filters::IntFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(last_update::NAME),
                ::prisma_client_rust::sel(twitter_id::NAME),
                ::prisma_client_rust::sel(twitter::NAME),
                ::prisma_client_rust::sel(discord_id::NAME),
                ::prisma_client_rust::sel(discord::NAME),
                ::prisma_client_rust::sel(telegram_id::NAME),
                ::prisma_client_rust::sel(telegram::NAME),
                ::prisma_client_rust::sel(user_id::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            users: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([users::connect(users)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            user_id: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([user_id::set(user_id)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(user_id, mut _params)| {
                    _params.extend([user_id::set(user_id)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (users, mut _params): (super::users::UniqueWhereParam, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([users::connect(users)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod storages {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "storages";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod url {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "url";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUrl(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Url(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Url(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Url(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::StringFilter, Url, {
            fn in_vec(_: Vec<String>) -> InVec;
            fn not_in_vec(_: Vec<String>) -> NotInVec;
            fn lt(_: String) -> Lt;
            fn lte(_: String) -> Lte;
            fn gt(_: String) -> Gt;
            fn gte(_: String) -> Gte;
            fn contains(_: String) -> Contains;
            fn starts_with(_: String) -> StartsWith;
            fn ends_with(_: String) -> EndsWith;
            fn mode(_: super::super::QueryMode) -> Mode;
            fn not(_: String) -> Not;
        });
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Url(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Url(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod tag {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "tag";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTag(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Tag(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Tag(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Tag(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Tag,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Tag(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Tag(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod banners {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "banners";
        pub struct Fetch(pub banners::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<banners::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: banners::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: banners::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Banners(v)
            }
        }
        pub fn fetch(params: Vec<banners::WhereParam>) -> Fetch {
            Fetch(banners::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<banners::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBanners(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<banners::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<banners::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectBanners(params)
        }
        pub fn set(params: Vec<banners::UniqueWhereParam>) -> SetParam {
            SetParam::SetBanners(params)
        }
        pub fn some(value: Vec<banners::WhereParam>) -> WhereParam {
            WhereParam::BannersSome(value)
        }
        pub fn every(value: Vec<banners::WhereParam>) -> WhereParam {
            WhereParam::BannersEvery(value)
        }
        pub fn none(value: Vec<banners::WhereParam>) -> WhereParam {
            WhereParam::BannersNone(value)
        }
        pub enum Include {
            Select(banners::ManyArgs, Vec<banners::SelectParam>),
            Include(banners::ManyArgs, Vec<banners::IncludeParam>),
            Fetch(banners::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Banners(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <banners::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <banners::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: banners::ManyArgs,
                nested_selections: Vec<banners::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: banners::ManyArgs,
                nested_selections: Vec<banners::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(banners::ManyArgs, Vec<banners::SelectParam>),
            Include(banners::ManyArgs, Vec<banners::IncludeParam>),
            Fetch(banners::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Banners(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <banners::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: banners::ManyArgs,
                nested_selections: Vec<banners::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: banners::ManyArgs,
                nested_selections: Vec<banners::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(url: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (url, _params)
    }
    pub fn create_unchecked(url: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (url, _params)
    }
    #[macro_export]
    macro_rules ! _select_storages { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: storages :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: storages :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: storages :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: storages :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: storages :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: storages :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , url , tag , banners } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: storages :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: storages :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: storages :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: storages :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: storages :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: storages :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "url" , "tag" , "banners"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: storages :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; url) => { String } ; (@ field_type ; tag) => { Option < String > } ; (@ field_type ; banners : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < banners :: Data > } ; (@ field_type ; banners) => { Vec < crate :: prisma :: banners :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Storages" , available relations are "id, created_at, url, tag, banners")) } ; (@ field_module ; banners : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: banners :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: storages :: SelectParam > :: into (crate :: prisma :: storages :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: storages :: SelectParam > :: into (crate :: prisma :: storages :: created_at :: Select) } ; (@ selection_field_to_selection_param ; url) => { Into :: < crate :: prisma :: storages :: SelectParam > :: into (crate :: prisma :: storages :: url :: Select) } ; (@ selection_field_to_selection_param ; tag) => { Into :: < crate :: prisma :: storages :: SelectParam > :: into (crate :: prisma :: storages :: tag :: Select) } ; (@ selection_field_to_selection_param ; banners $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: storages :: SelectParam > :: into (crate :: prisma :: storages :: banners :: Select :: $ selection_mode (crate :: prisma :: banners :: ManyArgs :: new (crate :: prisma :: banners :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: banners :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; banners $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: storages :: SelectParam > :: into (crate :: prisma :: storages :: banners :: Select :: Fetch (crate :: prisma :: banners :: ManyArgs :: new (crate :: prisma :: banners :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: storages :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; tag) => { "tag" } ; (@ field_serde_name ; banners) => { "banners" } ; }
    pub use _select_storages as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        Url(url::Select),
        Tag(tag::Select),
        Banners(banners::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Url(data) => data.to_selection(),
                Self::Tag(data) => data.to_selection(),
                Self::Banners(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_storages { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: storages :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: storages :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: storages :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: storages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: storages :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: storages :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: storages :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: storages :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { banners } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub url : String , pub tag : Option < String > , $ (pub $ field : crate :: prisma :: storages :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (url) , stringify ! (tag)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: storages :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: storages :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: storages :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: storages :: url :: NAME , & self . url) ? ; state . serialize_field (crate :: prisma :: storages :: tag :: NAME , & self . tag) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , url , tag } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: storages :: $ field :: NAME) , + , crate :: prisma :: storages :: id :: NAME , crate :: prisma :: storages :: created_at :: NAME , crate :: prisma :: storages :: url :: NAME , crate :: prisma :: storages :: tag :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: storages :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: storages :: id :: NAME => Ok (Field :: id) , crate :: prisma :: storages :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: storages :: url :: NAME => Ok (Field :: url) , crate :: prisma :: storages :: tag :: NAME => Ok (Field :: tag) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut url = None ; let mut tag = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: storages :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: storages :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: url => { if url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: storages :: url :: NAME)) ; } url = Some (map . next_value () ?) ; } Field :: tag => { if tag . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: storages :: tag :: NAME)) ; } tag = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: storages :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: storages :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: storages :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: storages :: created_at :: NAME)) ? ; let url = url . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: storages :: url :: NAME)) ? ; let tag = tag . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: storages :: tag :: NAME)) ? ; Ok (Data { id , created_at , url , tag , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "url" , "tag" , "banners"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: storages :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; banners : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < banners :: Data > } ; (@ field_type ; banners) => { Vec < crate :: prisma :: banners :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Storages" , available relations are "banners")) } ; (@ field_module ; banners : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: banners :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; banners $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: storages :: IncludeParam > :: into (crate :: prisma :: storages :: banners :: Include :: $ selection_mode (crate :: prisma :: banners :: ManyArgs :: new (crate :: prisma :: banners :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: banners :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; banners $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: storages :: IncludeParam > :: into (crate :: prisma :: storages :: banners :: Include :: Fetch (crate :: prisma :: banners :: ManyArgs :: new (crate :: prisma :: banners :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: storages :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; url) => { "url" } ; (@ field_serde_name ; tag) => { "tag" } ; (@ field_serde_name ; banners) => { "banners" } ; }
    pub use _include_storages as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        Url(url::Include),
        Tag(tag::Include),
        Banners(banners::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::Url(data) => data.to_selection(),
                Self::Tag(data) => data.to_selection(),
                Self::Banners(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_storages { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: storages struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "url")] pub url : String , # [serde (rename = "tag")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub tag : Option < String > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_storages as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "url")]
        pub url: String,
        #[serde(rename = "tag")]
        pub tag: Option<String>,
        #[serde(rename = "banners")]
        pub banners: Option<Vec<super::banners::Data>>,
    }
    impl Data {
        pub fn banners(
            &self,
        ) -> Result<&Vec<super::banners::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.banners
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(banners),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Banners(super::banners::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Banners(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: banners :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        banners::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetUrl(String),
        SetTag(Option<String>),
        ConnectBanners(Vec<super::banners::UniqueWhereParam>),
        DisconnectBanners(Vec<super::banners::UniqueWhereParam>),
        SetBanners(Vec<super::banners::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetUrl(value) => (
                    url::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetTag(value) => (
                    tag::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectBanners(where_params) => (
                    banners::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::banners::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectBanners(where_params) => (
                    banners::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::banners::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBanners(where_params) => (
                    banners::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::banners::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        Url(String),
        Tag(Option<String>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::Url(value) => Self::SetUrl(value),
                UncheckedSetParam::Tag(value) => Self::SetTag(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        Url(::prisma_client_rust::Direction),
        Tag(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Url(direction) => (
                    url::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Tag(direction) => (
                    tag::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        Url(_prisma::read_filters::StringFilter),
        Tag(_prisma::read_filters::StringNullableFilter),
        BannersSome(Vec<super::banners::WhereParam>),
        BannersEvery(Vec<super::banners::WhereParam>),
        BannersNone(Vec<super::banners::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::Url(value) => (url::NAME, value.into()),
                Self::Tag(value) => (tag::NAME, value.into()),
                Self::BannersSome(where_params) => (
                    banners::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BannersEvery(where_params) => (
                    banners::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BannersNone(where_params) => (
                    banners::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(url::NAME),
                ::prisma_client_rust::sel(tag::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, url: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.extend([url::set(url)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            url: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([url::set(url)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(url, mut _params)| {
                    _params.extend([url::set(url)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (url, mut _params): (String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([url::set(url)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod super_users {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "super_users";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod role {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "role";
        pub struct Set(pub self::SuperUserRoles);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRole(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Role(v)
            }
        }
        pub fn set<T: From<Set>>(value: self::SuperUserRoles) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Role(direction)
        }
        pub fn equals(value: self::SuperUserRoles) -> WhereParam {
            WhereParam::Role(_prisma::read_filters::SuperUserRolesFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::SuperUserRolesFilter,
            Role,
            {
                fn in_vec(_: Vec<super::super::SuperUserRoles>) -> InVec;
                fn not_in_vec(_: Vec<super::super::SuperUserRoles>) -> NotInVec;
                fn not(_: super::super::SuperUserRoles) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Role(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Role(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod refresh_token {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "refresh_token";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRefreshToken(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::RefreshToken(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::RefreshToken(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::RefreshToken(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            RefreshToken,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RefreshToken(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RefreshToken(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod username {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "username";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUsername(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Username(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Username(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::UsernameEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Username,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Username(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Username(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod password {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "password";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPassword(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Password(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Password(direction)
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::Password(_prisma::read_filters::StringFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            Password,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Password(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Password(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod avatar {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "avatar";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAvatar(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Avatar(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Avatar(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Avatar(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Avatar,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Avatar(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Avatar(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "businesses";
        pub struct Fetch(pub businesses::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: businesses::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: businesses::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Businesses(v)
            }
        }
        pub fn fetch(params: Vec<businesses::WhereParam>) -> Fetch {
            Fetch(businesses::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<businesses::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<businesses::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<businesses::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectBusinesses(params)
        }
        pub fn set(params: Vec<businesses::UniqueWhereParam>) -> SetParam {
            SetParam::SetBusinesses(params)
        }
        pub fn some(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesSome(value)
        }
        pub fn every(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesEvery(value)
        }
        pub fn none(value: Vec<businesses::WhereParam>) -> WhereParam {
            WhereParam::BusinessesNone(value)
        }
        pub enum Include {
            Select(businesses::ManyArgs, Vec<businesses::SelectParam>),
            Include(businesses::ManyArgs, Vec<businesses::IncludeParam>),
            Fetch(businesses::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Businesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: businesses::ManyArgs,
                nested_selections: Vec<businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: businesses::ManyArgs,
                nested_selections: Vec<businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(businesses::ManyArgs, Vec<businesses::SelectParam>),
            Include(businesses::ManyArgs, Vec<businesses::IncludeParam>),
            Fetch(businesses::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Businesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <businesses::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: businesses::ManyArgs,
                nested_selections: Vec<businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: businesses::ManyArgs,
                nested_selections: Vec<businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(
        role: super::SuperUserRoles,
        username: String,
        password: String,
        _params: Vec<SetParam>,
    ) -> (super::SuperUserRoles, String, String, Vec<SetParam>) {
        (role, username, password, _params)
    }
    pub fn create_unchecked(
        role: super::SuperUserRoles,
        username: String,
        password: String,
        _params: Vec<SetParam>,
    ) -> (super::SuperUserRoles, String, String, Vec<SetParam>) {
        (role, username, password, _params)
    }
    #[macro_export]
    macro_rules ! _select_super_users { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: super_users :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: super_users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: super_users :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: super_users :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: super_users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: super_users :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , role , refresh_token , username , password , avatar , businesses } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: super_users :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: super_users :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: super_users :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: super_users :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: super_users :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: super_users :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "role" , "refresh_token" , "username" , "password" , "avatar" , "businesses"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: super_users :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; role) => { crate :: prisma :: SuperUserRoles } ; (@ field_type ; refresh_token) => { Option < String > } ; (@ field_type ; username) => { String } ; (@ field_type ; password) => { String } ; (@ field_type ; avatar) => { Option < String > } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < businesses :: Data > } ; (@ field_type ; businesses) => { Vec < crate :: prisma :: businesses :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SuperUsers" , available relations are "id, role, refresh_token, username, password, avatar, businesses")) } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: super_users :: SelectParam > :: into (crate :: prisma :: super_users :: id :: Select) } ; (@ selection_field_to_selection_param ; role) => { Into :: < crate :: prisma :: super_users :: SelectParam > :: into (crate :: prisma :: super_users :: role :: Select) } ; (@ selection_field_to_selection_param ; refresh_token) => { Into :: < crate :: prisma :: super_users :: SelectParam > :: into (crate :: prisma :: super_users :: refresh_token :: Select) } ; (@ selection_field_to_selection_param ; username) => { Into :: < crate :: prisma :: super_users :: SelectParam > :: into (crate :: prisma :: super_users :: username :: Select) } ; (@ selection_field_to_selection_param ; password) => { Into :: < crate :: prisma :: super_users :: SelectParam > :: into (crate :: prisma :: super_users :: password :: Select) } ; (@ selection_field_to_selection_param ; avatar) => { Into :: < crate :: prisma :: super_users :: SelectParam > :: into (crate :: prisma :: super_users :: avatar :: Select) } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: super_users :: SelectParam > :: into (crate :: prisma :: super_users :: businesses :: Select :: $ selection_mode (crate :: prisma :: businesses :: ManyArgs :: new (crate :: prisma :: businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: super_users :: SelectParam > :: into (crate :: prisma :: super_users :: businesses :: Select :: Fetch (crate :: prisma :: businesses :: ManyArgs :: new (crate :: prisma :: businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: super_users :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; role) => { "role" } ; (@ field_serde_name ; refresh_token) => { "refresh_token" } ; (@ field_serde_name ; username) => { "username" } ; (@ field_serde_name ; password) => { "password" } ; (@ field_serde_name ; avatar) => { "avatar" } ; (@ field_serde_name ; businesses) => { "businesses" } ; }
    pub use _select_super_users as select;
    pub enum SelectParam {
        Id(id::Select),
        Role(role::Select),
        RefreshToken(refresh_token::Select),
        Username(username::Select),
        Password(password::Select),
        Avatar(avatar::Select),
        Businesses(businesses::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Role(data) => data.to_selection(),
                Self::RefreshToken(data) => data.to_selection(),
                Self::Username(data) => data.to_selection(),
                Self::Password(data) => data.to_selection(),
                Self::Avatar(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_super_users { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: super_users :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: super_users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: super_users :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: super_users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: super_users :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: super_users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: super_users :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: super_users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { businesses } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub role : crate :: prisma :: SuperUserRoles , pub refresh_token : Option < String > , pub username : String , pub password : String , pub avatar : Option < String > , $ (pub $ field : crate :: prisma :: super_users :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (role) , stringify ! (refresh_token) , stringify ! (username) , stringify ! (password) , stringify ! (avatar)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: super_users :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: super_users :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: super_users :: role :: NAME , & self . role) ? ; state . serialize_field (crate :: prisma :: super_users :: refresh_token :: NAME , & self . refresh_token) ? ; state . serialize_field (crate :: prisma :: super_users :: username :: NAME , & self . username) ? ; state . serialize_field (crate :: prisma :: super_users :: password :: NAME , & self . password) ? ; state . serialize_field (crate :: prisma :: super_users :: avatar :: NAME , & self . avatar) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , role , refresh_token , username , password , avatar } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: super_users :: $ field :: NAME) , + , crate :: prisma :: super_users :: id :: NAME , crate :: prisma :: super_users :: role :: NAME , crate :: prisma :: super_users :: refresh_token :: NAME , crate :: prisma :: super_users :: username :: NAME , crate :: prisma :: super_users :: password :: NAME , crate :: prisma :: super_users :: avatar :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: super_users :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: super_users :: id :: NAME => Ok (Field :: id) , crate :: prisma :: super_users :: role :: NAME => Ok (Field :: role) , crate :: prisma :: super_users :: refresh_token :: NAME => Ok (Field :: refresh_token) , crate :: prisma :: super_users :: username :: NAME => Ok (Field :: username) , crate :: prisma :: super_users :: password :: NAME => Ok (Field :: password) , crate :: prisma :: super_users :: avatar :: NAME => Ok (Field :: avatar) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut role = None ; let mut refresh_token = None ; let mut username = None ; let mut password = None ; let mut avatar = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: super_users :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: role => { if role . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: super_users :: role :: NAME)) ; } role = Some (map . next_value () ?) ; } Field :: refresh_token => { if refresh_token . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: super_users :: refresh_token :: NAME)) ; } refresh_token = Some (map . next_value () ?) ; } Field :: username => { if username . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: super_users :: username :: NAME)) ; } username = Some (map . next_value () ?) ; } Field :: password => { if password . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: super_users :: password :: NAME)) ; } password = Some (map . next_value () ?) ; } Field :: avatar => { if avatar . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: super_users :: avatar :: NAME)) ; } avatar = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: super_users :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: super_users :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: super_users :: id :: NAME)) ? ; let role = role . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: super_users :: role :: NAME)) ? ; let refresh_token = refresh_token . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: super_users :: refresh_token :: NAME)) ? ; let username = username . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: super_users :: username :: NAME)) ? ; let password = password . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: super_users :: password :: NAME)) ? ; let avatar = avatar . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: super_users :: avatar :: NAME)) ? ; Ok (Data { id , role , refresh_token , username , password , avatar , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "role" , "refresh_token" , "username" , "password" , "avatar" , "businesses"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: super_users :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < businesses :: Data > } ; (@ field_type ; businesses) => { Vec < crate :: prisma :: businesses :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "SuperUsers" , available relations are "businesses")) } ; (@ field_module ; businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: super_users :: IncludeParam > :: into (crate :: prisma :: super_users :: businesses :: Include :: $ selection_mode (crate :: prisma :: businesses :: ManyArgs :: new (crate :: prisma :: businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: super_users :: IncludeParam > :: into (crate :: prisma :: super_users :: businesses :: Include :: Fetch (crate :: prisma :: businesses :: ManyArgs :: new (crate :: prisma :: businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: super_users :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; role) => { "role" } ; (@ field_serde_name ; refresh_token) => { "refresh_token" } ; (@ field_serde_name ; username) => { "username" } ; (@ field_serde_name ; password) => { "password" } ; (@ field_serde_name ; avatar) => { "avatar" } ; (@ field_serde_name ; businesses) => { "businesses" } ; }
    pub use _include_super_users as include;
    pub enum IncludeParam {
        Id(id::Include),
        Role(role::Include),
        RefreshToken(refresh_token::Include),
        Username(username::Include),
        Password(password::Include),
        Avatar(avatar::Include),
        Businesses(businesses::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::Role(data) => data.to_selection(),
                Self::RefreshToken(data) => data.to_selection(),
                Self::Username(data) => data.to_selection(),
                Self::Password(data) => data.to_selection(),
                Self::Avatar(data) => data.to_selection(),
                Self::Businesses(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_super_users { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: super_users struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "role")] pub role : crate :: prisma :: SuperUserRoles , # [serde (rename = "refresh_token")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub refresh_token : Option < String > , # [serde (rename = "username")] pub username : String , # [serde (rename = "password")] pub password : String , # [serde (rename = "avatar")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub avatar : Option < String > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_super_users as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "role")]
        pub role: super::SuperUserRoles,
        #[serde(rename = "refresh_token")]
        pub refresh_token: Option<String>,
        #[serde(rename = "username")]
        pub username: String,
        #[serde(rename = "password")]
        pub password: String,
        #[serde(rename = "avatar")]
        pub avatar: Option<String>,
        #[serde(rename = "businesses")]
        pub businesses: Option<Vec<super::businesses::Data>>,
    }
    impl Data {
        pub fn businesses(
            &self,
        ) -> Result<&Vec<super::businesses::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.businesses
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(businesses),
                ))
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Businesses(super::businesses::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Businesses(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        businesses::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetRole(super::SuperUserRoles),
        SetRefreshToken(Option<String>),
        SetUsername(String),
        SetPassword(String),
        SetAvatar(Option<String>),
        ConnectBusinesses(Vec<super::businesses::UniqueWhereParam>),
        DisconnectBusinesses(Vec<super::businesses::UniqueWhereParam>),
        SetBusinesses(Vec<super::businesses::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetRole(value) => (
                    role::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                ),
                SetParam::SetRefreshToken(value) => (
                    refresh_token::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetUsername(value) => (
                    username::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetPassword(value) => (
                    password::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetAvatar(value) => (
                    avatar::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectBusinesses(where_params) => (
                    businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectBusinesses(where_params) => (
                    businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetBusinesses(where_params) => (
                    businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        Role(super::SuperUserRoles),
        RefreshToken(Option<String>),
        Username(String),
        Password(String),
        Avatar(Option<String>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::Role(value) => Self::SetRole(value),
                UncheckedSetParam::RefreshToken(value) => Self::SetRefreshToken(value),
                UncheckedSetParam::Username(value) => Self::SetUsername(value),
                UncheckedSetParam::Password(value) => Self::SetPassword(value),
                UncheckedSetParam::Avatar(value) => Self::SetAvatar(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        Role(::prisma_client_rust::Direction),
        RefreshToken(::prisma_client_rust::Direction),
        Username(::prisma_client_rust::Direction),
        Password(::prisma_client_rust::Direction),
        Avatar(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Role(direction) => (
                    role::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::RefreshToken(direction) => (
                    refresh_token::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Username(direction) => (
                    username::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Password(direction) => (
                    password::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Avatar(direction) => (
                    avatar::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        Role(_prisma::read_filters::SuperUserRolesFilter),
        RefreshToken(_prisma::read_filters::StringNullableFilter),
        Username(_prisma::read_filters::StringFilter),
        Password(_prisma::read_filters::StringFilter),
        Avatar(_prisma::read_filters::StringNullableFilter),
        BusinessesSome(Vec<super::businesses::WhereParam>),
        BusinessesEvery(Vec<super::businesses::WhereParam>),
        BusinessesNone(Vec<super::businesses::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::Role(value) => (role::NAME, value.into()),
                Self::RefreshToken(value) => (refresh_token::NAME, value.into()),
                Self::Username(value) => (username::NAME, value.into()),
                Self::Password(value) => (password::NAME, value.into()),
                Self::Avatar(value) => (avatar::NAME, value.into()),
                Self::BusinessesSome(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BusinessesEvery(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::BusinessesNone(where_params) => (
                    businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        UsernameEquals(String),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::UsernameEquals(value) => {
                    Self::Username(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(role::NAME),
                ::prisma_client_rust::sel(refresh_token::NAME),
                ::prisma_client_rust::sel(username::NAME),
                ::prisma_client_rust::sel(password::NAME),
                ::prisma_client_rust::sel(avatar::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            role: super::SuperUserRoles,
            username: String,
            password: String,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                role::set(role),
                username::set(username),
                password::set(password),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            role: super::SuperUserRoles,
            username: String,
            password: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                role::set(role),
                username::set(username),
                password::set(password),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(
            self,
            data: Vec<(super::SuperUserRoles, String, String, Vec<SetParam>)>,
        ) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(role, username, password, mut _params)| {
                    _params.extend([
                        role::set(role),
                        username::set(username),
                        password::set(password),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (role, username, password, mut _params): (
                super::SuperUserRoles,
                String,
                String,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                role::set(role),
                username::set(username),
                password::set(password),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod users {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "users";
    pub mod id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Id(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Id, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Id(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Id(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod created_at {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "created_at";
        pub struct Set(
            pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCreatedAt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CreatedAt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CreatedAt(direction)
        }
        pub fn equals(
            value: ::prisma_client_rust::chrono::DateTime<
                ::prisma_client_rust::chrono::FixedOffset,
            >,
        ) -> WhereParam {
            WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeFilter,
            CreatedAt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CreatedAt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CreatedAt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod wallet_address {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "wallet_address";
        pub struct Set(pub String);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetWalletAddress(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::WalletAddress(v)
            }
        }
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::WalletAddress(direction)
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::WalletAddressEquals(value).into()
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringFilter,
            WalletAddress,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: String) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::WalletAddress(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::WalletAddress(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod noti_accepted {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "noti_accepted";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetNotiAccepted(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::NotiAccepted(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::NotiAccepted(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::NotiAccepted(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            NotiAccepted,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::NotiAccepted(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::NotiAccepted(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod spam_accepted {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "spam_accepted";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetSpamAccepted(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::SpamAccepted(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::SpamAccepted(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::SpamAccepted(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            SpamAccepted,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::SpamAccepted(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::SpamAccepted(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod email {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "email";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetEmail(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Email(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Email(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Email(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Email,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Email(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Email(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod nickname {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "nickname";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetNickname(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Nickname(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Nickname(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Nickname(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Nickname,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Nickname(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Nickname(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod avatar_url {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "avatar_url";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAvatarUrl(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::AvatarUrl(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::AvatarUrl(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::AvatarUrl(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            AvatarUrl,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::AvatarUrl(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::AvatarUrl(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod refresh_token {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "refresh_token";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetRefreshToken(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::RefreshToken(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::RefreshToken(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::RefreshToken(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            RefreshToken,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RefreshToken(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RefreshToken(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod is_admin {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "isAdmin";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetIsAdmin(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::IsAdmin(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::IsAdmin(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::IsAdmin(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            IsAdmin,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::IsAdmin(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::IsAdmin(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod password {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "password";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetPassword(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Password(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Password(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::Password(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            Password,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Password(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Password(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod background_url {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "background_url";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetBackgroundUrl(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::BackgroundUrl(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::BackgroundUrl(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::BackgroundUrl(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            BackgroundUrl,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::BackgroundUrl(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::BackgroundUrl(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod did_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "didId";
        pub struct Set(pub Option<i32>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetDidId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::DidId(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::DidId(direction)
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::DidId(_prisma::read_filters::IntNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntNullableFilter,
            DidId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: Option<i32>) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementDidId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementDidId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyDidId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideDidId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::DidId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::DidId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod last_sync_ibt {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "last_sync_ibt";
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLastSyncIbt(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::LastSyncIbt(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LastSyncIbt(direction)
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::LastSyncIbt(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeNullableFilter,
            LastSyncIbt,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: Option<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LastSyncIbt(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LastSyncIbt(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod last_update {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "last_update";
        pub struct Set(
            pub  Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        );
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetLastUpdate(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::LastUpdate(v)
            }
        }
        pub fn set<T: From<Set>>(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::LastUpdate(direction)
        }
        pub fn equals(
            value: Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ) -> WhereParam {
            WhereParam::LastUpdate(_prisma::read_filters::DateTimeNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::DateTimeNullableFilter,
            LastUpdate,
            {
                fn in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> InVec;
                fn not_in_vec(
                    _: Vec<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> NotInVec;
                fn lt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lt;
                fn lte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Lte;
                fn gt(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gt;
                fn gte(
                    _: ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                ) -> Gte;
                fn not(
                    _: Option<
                        ::prisma_client_rust::chrono::DateTime<
                            ::prisma_client_rust::chrono::FixedOffset,
                        >,
                    >,
                ) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::LastUpdate(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::LastUpdate(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod activities_activities_from_user_id_tousers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "activities_activities_from_user_idTousers";
        pub struct Fetch(pub activities::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<activities::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: activities::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: activities::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ActivitiesActivitiesFromUserIdTousers(v)
            }
        }
        pub fn fetch(params: Vec<activities::WhereParam>) -> Fetch {
            Fetch(activities::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<activities::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectActivitiesActivitiesFromUserIdTousers(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<activities::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<activities::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectActivitiesActivitiesFromUserIdTousers(params)
        }
        pub fn set(params: Vec<activities::UniqueWhereParam>) -> SetParam {
            SetParam::SetActivitiesActivitiesFromUserIdTousers(params)
        }
        pub fn some(value: Vec<activities::WhereParam>) -> WhereParam {
            WhereParam::ActivitiesActivitiesFromUserIdTousersSome(value)
        }
        pub fn every(value: Vec<activities::WhereParam>) -> WhereParam {
            WhereParam::ActivitiesActivitiesFromUserIdTousersEvery(value)
        }
        pub fn none(value: Vec<activities::WhereParam>) -> WhereParam {
            WhereParam::ActivitiesActivitiesFromUserIdTousersNone(value)
        }
        pub enum Include {
            Select(activities::ManyArgs, Vec<activities::SelectParam>),
            Include(activities::ManyArgs, Vec<activities::IncludeParam>),
            Fetch(activities::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ActivitiesActivitiesFromUserIdTousers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < activities :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <activities::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: activities::ManyArgs,
                nested_selections: Vec<activities::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: activities::ManyArgs,
                nested_selections: Vec<activities::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(activities::ManyArgs, Vec<activities::SelectParam>),
            Include(activities::ManyArgs, Vec<activities::IncludeParam>),
            Fetch(activities::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ActivitiesActivitiesFromUserIdTousers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <activities::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: activities::ManyArgs,
                nested_selections: Vec<activities::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: activities::ManyArgs,
                nested_selections: Vec<activities::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod activities_activities_user_id_tousers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "activities_activities_user_idTousers";
        pub struct Fetch(pub activities::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<activities::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: activities::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: activities::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::ActivitiesActivitiesUserIdTousers(v)
            }
        }
        pub fn fetch(params: Vec<activities::WhereParam>) -> Fetch {
            Fetch(activities::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<activities::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectActivitiesActivitiesUserIdTousers(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<activities::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<activities::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectActivitiesActivitiesUserIdTousers(params)
        }
        pub fn set(params: Vec<activities::UniqueWhereParam>) -> SetParam {
            SetParam::SetActivitiesActivitiesUserIdTousers(params)
        }
        pub fn some(value: Vec<activities::WhereParam>) -> WhereParam {
            WhereParam::ActivitiesActivitiesUserIdTousersSome(value)
        }
        pub fn every(value: Vec<activities::WhereParam>) -> WhereParam {
            WhereParam::ActivitiesActivitiesUserIdTousersEvery(value)
        }
        pub fn none(value: Vec<activities::WhereParam>) -> WhereParam {
            WhereParam::ActivitiesActivitiesUserIdTousersNone(value)
        }
        pub enum Include {
            Select(activities::ManyArgs, Vec<activities::SelectParam>),
            Include(activities::ManyArgs, Vec<activities::IncludeParam>),
            Fetch(activities::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::ActivitiesActivitiesUserIdTousers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = < activities :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <activities::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: activities::ManyArgs,
                nested_selections: Vec<activities::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: activities::ManyArgs,
                nested_selections: Vec<activities::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(activities::ManyArgs, Vec<activities::SelectParam>),
            Include(activities::ManyArgs, Vec<activities::IncludeParam>),
            Fetch(activities::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::ActivitiesActivitiesUserIdTousers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <activities::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        ),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: activities::ManyArgs,
                nested_selections: Vec<activities::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: activities::ManyArgs,
                nested_selections: Vec<activities::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod feedbacks_on_businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "feedbacks_on_businesses";
        pub struct Fetch(pub feedbacks_on_businesses::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<feedbacks_on_businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: feedbacks_on_businesses::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: feedbacks_on_businesses::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::FeedbacksOnBusinesses(v)
            }
        }
        pub fn fetch(params: Vec<feedbacks_on_businesses::WhereParam>) -> Fetch {
            Fetch(feedbacks_on_businesses::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<feedbacks_on_businesses::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectFeedbacksOnBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(
            params: Vec<feedbacks_on_businesses::UniqueWhereParam>,
        ) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<feedbacks_on_businesses::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectFeedbacksOnBusinesses(params)
        }
        pub fn set(params: Vec<feedbacks_on_businesses::UniqueWhereParam>) -> SetParam {
            SetParam::SetFeedbacksOnBusinesses(params)
        }
        pub fn some(value: Vec<feedbacks_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FeedbacksOnBusinessesSome(value)
        }
        pub fn every(value: Vec<feedbacks_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FeedbacksOnBusinessesEvery(value)
        }
        pub fn none(value: Vec<feedbacks_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FeedbacksOnBusinessesNone(value)
        }
        pub enum Include {
            Select(
                feedbacks_on_businesses::ManyArgs,
                Vec<feedbacks_on_businesses::SelectParam>,
            ),
            Include(
                feedbacks_on_businesses::ManyArgs,
                Vec<feedbacks_on_businesses::IncludeParam>,
            ),
            Fetch(feedbacks_on_businesses::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FeedbacksOnBusinesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: feedbacks_on_businesses::ManyArgs,
                nested_selections: Vec<feedbacks_on_businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: feedbacks_on_businesses::ManyArgs,
                nested_selections: Vec<feedbacks_on_businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                feedbacks_on_businesses::ManyArgs,
                Vec<feedbacks_on_businesses::SelectParam>,
            ),
            Include(
                feedbacks_on_businesses::ManyArgs,
                Vec<feedbacks_on_businesses::IncludeParam>,
            ),
            Fetch(feedbacks_on_businesses::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FeedbacksOnBusinesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: feedbacks_on_businesses::ManyArgs,
                nested_selections: Vec<feedbacks_on_businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: feedbacks_on_businesses::ManyArgs,
                nested_selections: Vec<feedbacks_on_businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod followers_on_businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "followers_on_businesses";
        pub struct Fetch(pub followers_on_businesses::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<followers_on_businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: followers_on_businesses::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: followers_on_businesses::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::FollowersOnBusinesses(v)
            }
        }
        pub fn fetch(params: Vec<followers_on_businesses::WhereParam>) -> Fetch {
            Fetch(followers_on_businesses::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<followers_on_businesses::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectFollowersOnBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(
            params: Vec<followers_on_businesses::UniqueWhereParam>,
        ) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<followers_on_businesses::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectFollowersOnBusinesses(params)
        }
        pub fn set(params: Vec<followers_on_businesses::UniqueWhereParam>) -> SetParam {
            SetParam::SetFollowersOnBusinesses(params)
        }
        pub fn some(value: Vec<followers_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FollowersOnBusinessesSome(value)
        }
        pub fn every(value: Vec<followers_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FollowersOnBusinessesEvery(value)
        }
        pub fn none(value: Vec<followers_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::FollowersOnBusinessesNone(value)
        }
        pub enum Include {
            Select(
                followers_on_businesses::ManyArgs,
                Vec<followers_on_businesses::SelectParam>,
            ),
            Include(
                followers_on_businesses::ManyArgs,
                Vec<followers_on_businesses::IncludeParam>,
            ),
            Fetch(followers_on_businesses::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::FollowersOnBusinesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < followers_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < followers_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: followers_on_businesses::ManyArgs,
                nested_selections: Vec<followers_on_businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: followers_on_businesses::ManyArgs,
                nested_selections: Vec<followers_on_businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                followers_on_businesses::ManyArgs,
                Vec<followers_on_businesses::SelectParam>,
            ),
            Include(
                followers_on_businesses::ManyArgs,
                Vec<followers_on_businesses::IncludeParam>,
            ),
            Fetch(followers_on_businesses::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::FollowersOnBusinesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < followers_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: followers_on_businesses::ManyArgs,
                nested_selections: Vec<followers_on_businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: followers_on_businesses::ManyArgs,
                nested_selections: Vec<followers_on_businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod notifications_notifications_from_tousers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "notifications_notifications_fromTousers";
        pub struct Fetch(pub notifications::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<notifications::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: notifications::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: notifications::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::NotificationsNotificationsFromTousers(v)
            }
        }
        pub fn fetch(params: Vec<notifications::WhereParam>) -> Fetch {
            Fetch(notifications::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<notifications::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectNotificationsNotificationsFromTousers(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<notifications::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<notifications::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectNotificationsNotificationsFromTousers(params)
        }
        pub fn set(params: Vec<notifications::UniqueWhereParam>) -> SetParam {
            SetParam::SetNotificationsNotificationsFromTousers(params)
        }
        pub fn some(value: Vec<notifications::WhereParam>) -> WhereParam {
            WhereParam::NotificationsNotificationsFromTousersSome(value)
        }
        pub fn every(value: Vec<notifications::WhereParam>) -> WhereParam {
            WhereParam::NotificationsNotificationsFromTousersEvery(value)
        }
        pub fn none(value: Vec<notifications::WhereParam>) -> WhereParam {
            WhereParam::NotificationsNotificationsFromTousersNone(value)
        }
        pub enum Include {
            Select(notifications::ManyArgs, Vec<notifications::SelectParam>),
            Include(notifications::ManyArgs, Vec<notifications::IncludeParam>),
            Fetch(notifications::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::NotificationsNotificationsFromTousers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(notifications::ManyArgs, Vec<notifications::SelectParam>),
            Include(notifications::ManyArgs, Vec<notifications::IncludeParam>),
            Fetch(notifications::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::NotificationsNotificationsFromTousers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod notifications_notifications_to_tousers {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "notifications_notifications_toTousers";
        pub struct Fetch(pub notifications::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<notifications::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: notifications::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: notifications::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::NotificationsNotificationsToTousers(v)
            }
        }
        pub fn fetch(params: Vec<notifications::WhereParam>) -> Fetch {
            Fetch(notifications::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<notifications::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectNotificationsNotificationsToTousers(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<notifications::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<notifications::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectNotificationsNotificationsToTousers(params)
        }
        pub fn set(params: Vec<notifications::UniqueWhereParam>) -> SetParam {
            SetParam::SetNotificationsNotificationsToTousers(params)
        }
        pub fn some(value: Vec<notifications::WhereParam>) -> WhereParam {
            WhereParam::NotificationsNotificationsToTousersSome(value)
        }
        pub fn every(value: Vec<notifications::WhereParam>) -> WhereParam {
            WhereParam::NotificationsNotificationsToTousersEvery(value)
        }
        pub fn none(value: Vec<notifications::WhereParam>) -> WhereParam {
            WhereParam::NotificationsNotificationsToTousersNone(value)
        }
        pub enum Include {
            Select(notifications::ManyArgs, Vec<notifications::SelectParam>),
            Include(notifications::ManyArgs, Vec<notifications::IncludeParam>),
            Fetch(notifications::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::NotificationsNotificationsToTousers(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(notifications::ManyArgs, Vec<notifications::SelectParam>),
            Include(notifications::ManyArgs, Vec<notifications::IncludeParam>),
            Fetch(notifications::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::NotificationsNotificationsToTousers(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: notifications::ManyArgs,
                nested_selections: Vec<notifications::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod rates_on_businesses {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "rates_on_businesses";
        pub struct Fetch(pub rates_on_businesses::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<rates_on_businesses::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: rates_on_businesses::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: rates_on_businesses::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::RatesOnBusinesses(v)
            }
        }
        pub fn fetch(params: Vec<rates_on_businesses::WhereParam>) -> Fetch {
            Fetch(rates_on_businesses::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<rates_on_businesses::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectRatesOnBusinesses(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<rates_on_businesses::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<rates_on_businesses::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectRatesOnBusinesses(params)
        }
        pub fn set(params: Vec<rates_on_businesses::UniqueWhereParam>) -> SetParam {
            SetParam::SetRatesOnBusinesses(params)
        }
        pub fn some(value: Vec<rates_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::RatesOnBusinessesSome(value)
        }
        pub fn every(value: Vec<rates_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::RatesOnBusinessesEvery(value)
        }
        pub fn none(value: Vec<rates_on_businesses::WhereParam>) -> WhereParam {
            WhereParam::RatesOnBusinessesNone(value)
        }
        pub enum Include {
            Select(
                rates_on_businesses::ManyArgs,
                Vec<rates_on_businesses::SelectParam>,
            ),
            Include(
                rates_on_businesses::ManyArgs,
                Vec<rates_on_businesses::IncludeParam>,
            ),
            Fetch(rates_on_businesses::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RatesOnBusinesses(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < rates_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < rates_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: rates_on_businesses::ManyArgs,
                nested_selections: Vec<rates_on_businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: rates_on_businesses::ManyArgs,
                nested_selections: Vec<rates_on_businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                rates_on_businesses::ManyArgs,
                Vec<rates_on_businesses::SelectParam>,
            ),
            Include(
                rates_on_businesses::ManyArgs,
                Vec<rates_on_businesses::IncludeParam>,
            ),
            Fetch(rates_on_businesses::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RatesOnBusinesses(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < rates_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: rates_on_businesses::ManyArgs,
                nested_selections: Vec<rates_on_businesses::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: rates_on_businesses::ManyArgs,
                nested_selections: Vec<rates_on_businesses::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod replies {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "replies";
        pub struct Fetch(pub replies::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<replies::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: replies::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: replies::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Replies(v)
            }
        }
        pub fn fetch(params: Vec<replies::WhereParam>) -> Fetch {
            Fetch(replies::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<replies::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectReplies(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<replies::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<replies::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectReplies(params)
        }
        pub fn set(params: Vec<replies::UniqueWhereParam>) -> SetParam {
            SetParam::SetReplies(params)
        }
        pub fn some(value: Vec<replies::WhereParam>) -> WhereParam {
            WhereParam::RepliesSome(value)
        }
        pub fn every(value: Vec<replies::WhereParam>) -> WhereParam {
            WhereParam::RepliesEvery(value)
        }
        pub fn none(value: Vec<replies::WhereParam>) -> WhereParam {
            WhereParam::RepliesNone(value)
        }
        pub enum Include {
            Select(replies::ManyArgs, Vec<replies::SelectParam>),
            Include(replies::ManyArgs, Vec<replies::IncludeParam>),
            Fetch(replies::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Replies(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <replies::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <replies::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: replies::ManyArgs,
                nested_selections: Vec<replies::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: replies::ManyArgs,
                nested_selections: Vec<replies::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(replies::ManyArgs, Vec<replies::SelectParam>),
            Include(replies::ManyArgs, Vec<replies::IncludeParam>),
            Fetch(replies::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Replies(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <replies::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: replies::ManyArgs,
                nested_selections: Vec<replies::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: replies::ManyArgs,
                nested_selections: Vec<replies::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod replies_on_feedbacks {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "replies_on_feedbacks";
        pub struct Fetch(pub replies_on_feedbacks::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<replies_on_feedbacks::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: replies_on_feedbacks::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: replies_on_feedbacks::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::RepliesOnFeedbacks(v)
            }
        }
        pub fn fetch(params: Vec<replies_on_feedbacks::WhereParam>) -> Fetch {
            Fetch(replies_on_feedbacks::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<replies_on_feedbacks::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectRepliesOnFeedbacks(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<replies_on_feedbacks::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<replies_on_feedbacks::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectRepliesOnFeedbacks(params)
        }
        pub fn set(params: Vec<replies_on_feedbacks::UniqueWhereParam>) -> SetParam {
            SetParam::SetRepliesOnFeedbacks(params)
        }
        pub fn some(value: Vec<replies_on_feedbacks::WhereParam>) -> WhereParam {
            WhereParam::RepliesOnFeedbacksSome(value)
        }
        pub fn every(value: Vec<replies_on_feedbacks::WhereParam>) -> WhereParam {
            WhereParam::RepliesOnFeedbacksEvery(value)
        }
        pub fn none(value: Vec<replies_on_feedbacks::WhereParam>) -> WhereParam {
            WhereParam::RepliesOnFeedbacksNone(value)
        }
        pub enum Include {
            Select(
                replies_on_feedbacks::ManyArgs,
                Vec<replies_on_feedbacks::SelectParam>,
            ),
            Include(
                replies_on_feedbacks::ManyArgs,
                Vec<replies_on_feedbacks::IncludeParam>,
            ),
            Fetch(replies_on_feedbacks::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::RepliesOnFeedbacks(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < replies_on_feedbacks :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < replies_on_feedbacks :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: replies_on_feedbacks::ManyArgs,
                nested_selections: Vec<replies_on_feedbacks::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: replies_on_feedbacks::ManyArgs,
                nested_selections: Vec<replies_on_feedbacks::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                replies_on_feedbacks::ManyArgs,
                Vec<replies_on_feedbacks::SelectParam>,
            ),
            Include(
                replies_on_feedbacks::ManyArgs,
                Vec<replies_on_feedbacks::IncludeParam>,
            ),
            Fetch(replies_on_feedbacks::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::RepliesOnFeedbacks(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < replies_on_feedbacks :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: replies_on_feedbacks::ManyArgs,
                nested_selections: Vec<replies_on_feedbacks::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: replies_on_feedbacks::ManyArgs,
                nested_selections: Vec<replies_on_feedbacks::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod reviews {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "reviews";
        pub struct Fetch(pub reviews::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<reviews::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: reviews::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: reviews::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Reviews(v)
            }
        }
        pub fn fetch(params: Vec<reviews::WhereParam>) -> Fetch {
            Fetch(reviews::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<reviews::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectReviews(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<reviews::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<reviews::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectReviews(params)
        }
        pub fn set(params: Vec<reviews::UniqueWhereParam>) -> SetParam {
            SetParam::SetReviews(params)
        }
        pub fn some(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsSome(value)
        }
        pub fn every(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsEvery(value)
        }
        pub fn none(value: Vec<reviews::WhereParam>) -> WhereParam {
            WhereParam::ReviewsNone(value)
        }
        pub enum Include {
            Select(reviews::ManyArgs, Vec<reviews::SelectParam>),
            Include(reviews::ManyArgs, Vec<reviews::IncludeParam>),
            Fetch(reviews::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Reviews(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections =
                            <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: reviews::ManyArgs,
                nested_selections: Vec<reviews::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: reviews::ManyArgs,
                nested_selections: Vec<reviews::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(reviews::ManyArgs, Vec<reviews::SelectParam>),
            Include(reviews::ManyArgs, Vec<reviews::IncludeParam>),
            Fetch(reviews::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Reviews(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args, selections) = match self {
                    Self::Select(args, selections) => (
                        args.to_graphql().0,
                        selections.into_iter().map(|s| s.to_selection()).collect(),
                    ),
                    Self::Include(args, selections) => (args.to_graphql().0, {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }),
                    Self::Fetch(args) => (
                        args.to_graphql().0,
                        <reviews::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
                    ),
                };
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: reviews::ManyArgs,
                nested_selections: Vec<reviews::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: reviews::ManyArgs,
                nested_selections: Vec<reviews::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub mod socials {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "socials";
        pub struct Fetch(pub socials::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<socials::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Socials(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(socials::UniqueArgs::new())
        }
        pub struct Connect(socials::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectSocials(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: socials::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectSocials
        }
        pub fn is_null() -> WhereParam {
            WhereParam::SocialsIsNull
        }
        pub fn is(value: Vec<socials::WhereParam>) -> WhereParam {
            WhereParam::SocialsIs(value)
        }
        pub fn is_not(value: Vec<socials::WhereParam>) -> WhereParam {
            WhereParam::SocialsIsNot(value)
        }
        pub enum Include {
            Select(Vec<socials::SelectParam>),
            Include(Vec<socials::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Socials(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <socials::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                            );
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <socials::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("socials", None, [], selections)
            }
            pub fn select(nested_selections: Vec<socials::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<socials::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<socials::SelectParam>),
            Include(Vec<socials::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Socials(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <socials::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("socials", None, [], selections)
            }
            pub fn select(nested_selections: Vec<socials::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<socials::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod dids {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "dids";
        pub struct Fetch(pub dids::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<dids::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Dids(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(dids::UniqueArgs::new())
        }
        pub struct Connect(dids::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectDids(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: dids::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn disconnect() -> SetParam {
            SetParam::DisconnectDids
        }
        pub fn is_null() -> WhereParam {
            WhereParam::DidsIsNull
        }
        pub fn is(value: Vec<dids::WhereParam>) -> WhereParam {
            WhereParam::DidsIs(value)
        }
        pub fn is_not(value: Vec<dids::WhereParam>) -> WhereParam {
            WhereParam::DidsIsNot(value)
        }
        pub enum Include {
            Select(Vec<dids::SelectParam>),
            Include(Vec<dids::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Dids(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <dids::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <dids::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("dids", None, [], selections)
            }
            pub fn select(nested_selections: Vec<dids::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<dids::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<dids::SelectParam>),
            Include(Vec<dids::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Dids(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <dids::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("dids", None, [], selections)
            }
            pub fn select(nested_selections: Vec<dids::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<dids::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users_on_campaigns {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users_on_campaigns";
        pub struct Fetch(pub users_on_campaigns::ManyArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users_on_campaigns::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
            pub fn order_by(mut self, param: users_on_campaigns::OrderByParam) -> Self {
                self.0 = self.0.order_by(param);
                self
            }
            pub fn skip(mut self, value: i64) -> Self {
                self.0 = self.0.skip(value);
                self
            }
            pub fn take(mut self, value: i64) -> Self {
                self.0 = self.0.take(value);
                self
            }
            pub fn cursor(mut self, value: users_on_campaigns::UniqueWhereParam) -> Self {
                self.0 = self.0.cursor(value.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::UsersOnCampaigns(v)
            }
        }
        pub fn fetch(params: Vec<users_on_campaigns::WhereParam>) -> Fetch {
            Fetch(users_on_campaigns::ManyArgs::new(params))
        }
        pub struct Connect(pub Vec<users_on_campaigns::UniqueWhereParam>);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsersOnCampaigns(v)
            }
        }
        pub fn connect<T: From<Connect>>(params: Vec<users_on_campaigns::UniqueWhereParam>) -> T {
            Connect(params).into()
        }
        pub fn disconnect(params: Vec<users_on_campaigns::UniqueWhereParam>) -> SetParam {
            SetParam::DisconnectUsersOnCampaigns(params)
        }
        pub fn set(params: Vec<users_on_campaigns::UniqueWhereParam>) -> SetParam {
            SetParam::SetUsersOnCampaigns(params)
        }
        pub fn some(value: Vec<users_on_campaigns::WhereParam>) -> WhereParam {
            WhereParam::UsersOnCampaignsSome(value)
        }
        pub fn every(value: Vec<users_on_campaigns::WhereParam>) -> WhereParam {
            WhereParam::UsersOnCampaignsEvery(value)
        }
        pub fn none(value: Vec<users_on_campaigns::WhereParam>) -> WhereParam {
            WhereParam::UsersOnCampaignsNone(value)
        }
        pub enum Include {
            Select(
                users_on_campaigns::ManyArgs,
                Vec<users_on_campaigns::SelectParam>,
            ),
            Include(
                users_on_campaigns::ManyArgs,
                Vec<users_on_campaigns::IncludeParam>,
            ),
            Fetch(users_on_campaigns::ManyArgs),
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UsersOnCampaigns(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < users_on_campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < users_on_campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: users_on_campaigns::ManyArgs,
                nested_selections: Vec<users_on_campaigns::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: users_on_campaigns::ManyArgs,
                nested_selections: Vec<users_on_campaigns::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
        pub enum Select {
            Select(
                users_on_campaigns::ManyArgs,
                Vec<users_on_campaigns::SelectParam>,
            ),
            Include(
                users_on_campaigns::ManyArgs,
                Vec<users_on_campaigns::IncludeParam>,
            ),
            Fetch(users_on_campaigns::ManyArgs),
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UsersOnCampaigns(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (| s | s . to_selection ()) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < users_on_campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
                ::prisma_client_rust::Selection::new(NAME, None, args, selections)
            }
            pub fn select(
                args: users_on_campaigns::ManyArgs,
                nested_selections: Vec<users_on_campaigns::SelectParam>,
            ) -> Self {
                Self::Select(args, nested_selections)
            }
            pub fn include(
                args: users_on_campaigns::ManyArgs,
                nested_selections: Vec<users_on_campaigns::IncludeParam>,
            ) -> Self {
                Self::Include(args, nested_selections)
            }
        }
    }
    pub fn create(wallet_address: String, _params: Vec<SetParam>) -> (String, Vec<SetParam>) {
        (wallet_address, _params)
    }
    pub fn create_unchecked(
        wallet_address: String,
        _params: Vec<SetParam>,
    ) -> (String, Vec<SetParam>) {
        (wallet_address, _params)
    }
    #[macro_export]
    macro_rules ! _select_users { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: users :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: users :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: users :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , created_at , wallet_address , noti_accepted , spam_accepted , email , nickname , avatar_url , refresh_token , is_admin , password , background_url , did_id , last_sync_ibt , last_update , activities_activities_from_user_id_tousers , activities_activities_user_id_tousers , feedbacks_on_businesses , followers_on_businesses , notifications_notifications_from_tousers , notifications_notifications_to_tousers , rates_on_businesses , replies , replies_on_feedbacks , reviews , socials , dids , users_on_campaigns } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: users :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: users :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: users :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: users :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "wallet_address" , "noti_accepted" , "spam_accepted" , "email" , "nickname" , "avatar_url" , "refresh_token" , "isAdmin" , "password" , "background_url" , "didId" , "last_sync_ibt" , "last_update" , "activities_activities_from_user_idTousers" , "activities_activities_user_idTousers" , "feedbacks_on_businesses" , "followers_on_businesses" , "notifications_notifications_fromTousers" , "notifications_notifications_toTousers" , "rates_on_businesses" , "replies" , "replies_on_feedbacks" , "reviews" , "socials" , "dids" , "users_on_campaigns"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: users :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; wallet_address) => { String } ; (@ field_type ; noti_accepted) => { bool } ; (@ field_type ; spam_accepted) => { bool } ; (@ field_type ; email) => { Option < String > } ; (@ field_type ; nickname) => { Option < String > } ; (@ field_type ; avatar_url) => { Option < String > } ; (@ field_type ; refresh_token) => { Option < String > } ; (@ field_type ; is_admin) => { bool } ; (@ field_type ; password) => { Option < String > } ; (@ field_type ; background_url) => { Option < String > } ; (@ field_type ; did_id) => { Option < i32 > } ; (@ field_type ; last_sync_ibt) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; last_update) => { Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } ; (@ field_type ; activities_activities_from_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < activities_activities_from_user_id_tousers :: Data > } ; (@ field_type ; activities_activities_from_user_id_tousers) => { Vec < crate :: prisma :: activities :: Data > } ; (@ field_type ; activities_activities_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < activities_activities_user_id_tousers :: Data > } ; (@ field_type ; activities_activities_user_id_tousers) => { Vec < crate :: prisma :: activities :: Data > } ; (@ field_type ; feedbacks_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < feedbacks_on_businesses :: Data > } ; (@ field_type ; feedbacks_on_businesses) => { Vec < crate :: prisma :: feedbacks_on_businesses :: Data > } ; (@ field_type ; followers_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < followers_on_businesses :: Data > } ; (@ field_type ; followers_on_businesses) => { Vec < crate :: prisma :: followers_on_businesses :: Data > } ; (@ field_type ; notifications_notifications_from_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < notifications_notifications_from_tousers :: Data > } ; (@ field_type ; notifications_notifications_from_tousers) => { Vec < crate :: prisma :: notifications :: Data > } ; (@ field_type ; notifications_notifications_to_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < notifications_notifications_to_tousers :: Data > } ; (@ field_type ; notifications_notifications_to_tousers) => { Vec < crate :: prisma :: notifications :: Data > } ; (@ field_type ; rates_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < rates_on_businesses :: Data > } ; (@ field_type ; rates_on_businesses) => { Vec < crate :: prisma :: rates_on_businesses :: Data > } ; (@ field_type ; replies : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < replies :: Data > } ; (@ field_type ; replies) => { Vec < crate :: prisma :: replies :: Data > } ; (@ field_type ; replies_on_feedbacks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < replies_on_feedbacks :: Data > } ; (@ field_type ; replies_on_feedbacks) => { Vec < crate :: prisma :: replies_on_feedbacks :: Data > } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < reviews :: Data > } ; (@ field_type ; reviews) => { Vec < crate :: prisma :: reviews :: Data > } ; (@ field_type ; socials : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < socials :: Data > } ; (@ field_type ; socials) => { Option < crate :: prisma :: socials :: Data > } ; (@ field_type ; dids : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < dids :: Data > } ; (@ field_type ; dids) => { Option < crate :: prisma :: dids :: Data > } ; (@ field_type ; users_on_campaigns : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < users_on_campaigns :: Data > } ; (@ field_type ; users_on_campaigns) => { Vec < crate :: prisma :: users_on_campaigns :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Users" , available relations are "id, created_at, wallet_address, noti_accepted, spam_accepted, email, nickname, avatar_url, refresh_token, is_admin, password, background_url, did_id, last_sync_ibt, last_update, activities_activities_from_user_id_tousers, activities_activities_user_id_tousers, feedbacks_on_businesses, followers_on_businesses, notifications_notifications_from_tousers, notifications_notifications_to_tousers, rates_on_businesses, replies, replies_on_feedbacks, reviews, socials, dids, users_on_campaigns")) } ; (@ field_module ; activities_activities_from_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: activities :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; activities_activities_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: activities :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; feedbacks_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: feedbacks_on_businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; followers_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: followers_on_businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; notifications_notifications_from_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: notifications :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; notifications_notifications_to_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: notifications :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; rates_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: rates_on_businesses :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; replies : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: replies :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; replies_on_feedbacks : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: replies_on_feedbacks :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; socials : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: socials :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; dids : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: dids :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_on_campaigns : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users_on_campaigns :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: id :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: created_at :: Select) } ; (@ selection_field_to_selection_param ; wallet_address) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: wallet_address :: Select) } ; (@ selection_field_to_selection_param ; noti_accepted) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: noti_accepted :: Select) } ; (@ selection_field_to_selection_param ; spam_accepted) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: spam_accepted :: Select) } ; (@ selection_field_to_selection_param ; email) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: email :: Select) } ; (@ selection_field_to_selection_param ; nickname) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: nickname :: Select) } ; (@ selection_field_to_selection_param ; avatar_url) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: avatar_url :: Select) } ; (@ selection_field_to_selection_param ; refresh_token) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: refresh_token :: Select) } ; (@ selection_field_to_selection_param ; is_admin) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: is_admin :: Select) } ; (@ selection_field_to_selection_param ; password) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: password :: Select) } ; (@ selection_field_to_selection_param ; background_url) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: background_url :: Select) } ; (@ selection_field_to_selection_param ; did_id) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: did_id :: Select) } ; (@ selection_field_to_selection_param ; last_sync_ibt) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: last_sync_ibt :: Select) } ; (@ selection_field_to_selection_param ; last_update) => { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: last_update :: Select) } ; (@ selection_field_to_selection_param ; activities_activities_from_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: activities_activities_from_user_id_tousers :: Select :: $ selection_mode (crate :: prisma :: activities :: ManyArgs :: new (crate :: prisma :: activities :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: activities :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; activities_activities_from_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: activities_activities_from_user_id_tousers :: Select :: Fetch (crate :: prisma :: activities :: ManyArgs :: new (crate :: prisma :: activities :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; activities_activities_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: activities_activities_user_id_tousers :: Select :: $ selection_mode (crate :: prisma :: activities :: ManyArgs :: new (crate :: prisma :: activities :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: activities :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; activities_activities_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: activities_activities_user_id_tousers :: Select :: Fetch (crate :: prisma :: activities :: ManyArgs :: new (crate :: prisma :: activities :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; feedbacks_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: feedbacks_on_businesses :: Select :: $ selection_mode (crate :: prisma :: feedbacks_on_businesses :: ManyArgs :: new (crate :: prisma :: feedbacks_on_businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: feedbacks_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; feedbacks_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: feedbacks_on_businesses :: Select :: Fetch (crate :: prisma :: feedbacks_on_businesses :: ManyArgs :: new (crate :: prisma :: feedbacks_on_businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; followers_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: followers_on_businesses :: Select :: $ selection_mode (crate :: prisma :: followers_on_businesses :: ManyArgs :: new (crate :: prisma :: followers_on_businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: followers_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; followers_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: followers_on_businesses :: Select :: Fetch (crate :: prisma :: followers_on_businesses :: ManyArgs :: new (crate :: prisma :: followers_on_businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; notifications_notifications_from_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: notifications_notifications_from_tousers :: Select :: $ selection_mode (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: notifications :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; notifications_notifications_from_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: notifications_notifications_from_tousers :: Select :: Fetch (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; notifications_notifications_to_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: notifications_notifications_to_tousers :: Select :: $ selection_mode (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: notifications :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; notifications_notifications_to_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: notifications_notifications_to_tousers :: Select :: Fetch (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; rates_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: rates_on_businesses :: Select :: $ selection_mode (crate :: prisma :: rates_on_businesses :: ManyArgs :: new (crate :: prisma :: rates_on_businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: rates_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; rates_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: rates_on_businesses :: Select :: Fetch (crate :: prisma :: rates_on_businesses :: ManyArgs :: new (crate :: prisma :: rates_on_businesses :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; replies $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: replies :: Select :: $ selection_mode (crate :: prisma :: replies :: ManyArgs :: new (crate :: prisma :: replies :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: replies :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; replies $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: replies :: Select :: Fetch (crate :: prisma :: replies :: ManyArgs :: new (crate :: prisma :: replies :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; replies_on_feedbacks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: replies_on_feedbacks :: Select :: $ selection_mode (crate :: prisma :: replies_on_feedbacks :: ManyArgs :: new (crate :: prisma :: replies_on_feedbacks :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: replies_on_feedbacks :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; replies_on_feedbacks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: replies_on_feedbacks :: Select :: Fetch (crate :: prisma :: replies_on_feedbacks :: ManyArgs :: new (crate :: prisma :: replies_on_feedbacks :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: reviews :: Select :: $ selection_mode (crate :: prisma :: reviews :: ManyArgs :: new (crate :: prisma :: reviews :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: reviews :: Select :: Fetch (crate :: prisma :: reviews :: ManyArgs :: new (crate :: prisma :: reviews :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; socials $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: socials :: Select :: $ selection_mode (crate :: prisma :: socials :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; socials $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: socials :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; dids $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: dids :: Select :: $ selection_mode (crate :: prisma :: dids :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; dids $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: dids :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users_on_campaigns $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: users_on_campaigns :: Select :: $ selection_mode (crate :: prisma :: users_on_campaigns :: ManyArgs :: new (crate :: prisma :: users_on_campaigns :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: users_on_campaigns :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_on_campaigns $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: SelectParam > :: into (crate :: prisma :: users :: users_on_campaigns :: Select :: Fetch (crate :: prisma :: users_on_campaigns :: ManyArgs :: new (crate :: prisma :: users_on_campaigns :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: users :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; wallet_address) => { "wallet_address" } ; (@ field_serde_name ; noti_accepted) => { "noti_accepted" } ; (@ field_serde_name ; spam_accepted) => { "spam_accepted" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; nickname) => { "nickname" } ; (@ field_serde_name ; avatar_url) => { "avatar_url" } ; (@ field_serde_name ; refresh_token) => { "refresh_token" } ; (@ field_serde_name ; is_admin) => { "isAdmin" } ; (@ field_serde_name ; password) => { "password" } ; (@ field_serde_name ; background_url) => { "background_url" } ; (@ field_serde_name ; did_id) => { "didId" } ; (@ field_serde_name ; last_sync_ibt) => { "last_sync_ibt" } ; (@ field_serde_name ; last_update) => { "last_update" } ; (@ field_serde_name ; activities_activities_from_user_id_tousers) => { "activities_activities_from_user_idTousers" } ; (@ field_serde_name ; activities_activities_user_id_tousers) => { "activities_activities_user_idTousers" } ; (@ field_serde_name ; feedbacks_on_businesses) => { "feedbacks_on_businesses" } ; (@ field_serde_name ; followers_on_businesses) => { "followers_on_businesses" } ; (@ field_serde_name ; notifications_notifications_from_tousers) => { "notifications_notifications_fromTousers" } ; (@ field_serde_name ; notifications_notifications_to_tousers) => { "notifications_notifications_toTousers" } ; (@ field_serde_name ; rates_on_businesses) => { "rates_on_businesses" } ; (@ field_serde_name ; replies) => { "replies" } ; (@ field_serde_name ; replies_on_feedbacks) => { "replies_on_feedbacks" } ; (@ field_serde_name ; reviews) => { "reviews" } ; (@ field_serde_name ; socials) => { "socials" } ; (@ field_serde_name ; dids) => { "dids" } ; (@ field_serde_name ; users_on_campaigns) => { "users_on_campaigns" } ; }
    pub use _select_users as select;
    pub enum SelectParam {
        Id(id::Select),
        CreatedAt(created_at::Select),
        WalletAddress(wallet_address::Select),
        NotiAccepted(noti_accepted::Select),
        SpamAccepted(spam_accepted::Select),
        Email(email::Select),
        Nickname(nickname::Select),
        AvatarUrl(avatar_url::Select),
        RefreshToken(refresh_token::Select),
        IsAdmin(is_admin::Select),
        Password(password::Select),
        BackgroundUrl(background_url::Select),
        DidId(did_id::Select),
        LastSyncIbt(last_sync_ibt::Select),
        LastUpdate(last_update::Select),
        ActivitiesActivitiesFromUserIdTousers(activities_activities_from_user_id_tousers::Select),
        ActivitiesActivitiesUserIdTousers(activities_activities_user_id_tousers::Select),
        FeedbacksOnBusinesses(feedbacks_on_businesses::Select),
        FollowersOnBusinesses(followers_on_businesses::Select),
        NotificationsNotificationsFromTousers(notifications_notifications_from_tousers::Select),
        NotificationsNotificationsToTousers(notifications_notifications_to_tousers::Select),
        RatesOnBusinesses(rates_on_businesses::Select),
        Replies(replies::Select),
        RepliesOnFeedbacks(replies_on_feedbacks::Select),
        Reviews(reviews::Select),
        Socials(socials::Select),
        Dids(dids::Select),
        UsersOnCampaigns(users_on_campaigns::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::WalletAddress(data) => data.to_selection(),
                Self::NotiAccepted(data) => data.to_selection(),
                Self::SpamAccepted(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::Nickname(data) => data.to_selection(),
                Self::AvatarUrl(data) => data.to_selection(),
                Self::RefreshToken(data) => data.to_selection(),
                Self::IsAdmin(data) => data.to_selection(),
                Self::Password(data) => data.to_selection(),
                Self::BackgroundUrl(data) => data.to_selection(),
                Self::DidId(data) => data.to_selection(),
                Self::LastSyncIbt(data) => data.to_selection(),
                Self::LastUpdate(data) => data.to_selection(),
                Self::ActivitiesActivitiesFromUserIdTousers(data) => data.to_selection(),
                Self::ActivitiesActivitiesUserIdTousers(data) => data.to_selection(),
                Self::FeedbacksOnBusinesses(data) => data.to_selection(),
                Self::FollowersOnBusinesses(data) => data.to_selection(),
                Self::NotificationsNotificationsFromTousers(data) => data.to_selection(),
                Self::NotificationsNotificationsToTousers(data) => data.to_selection(),
                Self::RatesOnBusinesses(data) => data.to_selection(),
                Self::Replies(data) => data.to_selection(),
                Self::RepliesOnFeedbacks(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
                Self::Socials(data) => data.to_selection(),
                Self::Dids(data) => data.to_selection(),
                Self::UsersOnCampaigns(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_users { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: users :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: users :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: users :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { activities_activities_from_user_id_tousers , activities_activities_user_id_tousers , feedbacks_on_businesses , followers_on_businesses , notifications_notifications_from_tousers , notifications_notifications_to_tousers , rates_on_businesses , replies , replies_on_feedbacks , reviews , socials , dids , users_on_campaigns } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub wallet_address : String , pub noti_accepted : bool , pub spam_accepted : bool , pub email : Option < String > , pub nickname : Option < String > , pub avatar_url : Option < String > , pub refresh_token : Option < String > , pub is_admin : bool , pub password : Option < String > , pub background_url : Option < String > , pub did_id : Option < i32 > , pub last_sync_ibt : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , pub last_update : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , $ (pub $ field : crate :: prisma :: users :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (created_at) , stringify ! (wallet_address) , stringify ! (noti_accepted) , stringify ! (spam_accepted) , stringify ! (email) , stringify ! (nickname) , stringify ! (avatar_url) , stringify ! (refresh_token) , stringify ! (is_admin) , stringify ! (password) , stringify ! (background_url) , stringify ! (did_id) , stringify ! (last_sync_ibt) , stringify ! (last_update)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: users :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: users :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: prisma :: users :: created_at :: NAME , & self . created_at) ? ; state . serialize_field (crate :: prisma :: users :: wallet_address :: NAME , & self . wallet_address) ? ; state . serialize_field (crate :: prisma :: users :: noti_accepted :: NAME , & self . noti_accepted) ? ; state . serialize_field (crate :: prisma :: users :: spam_accepted :: NAME , & self . spam_accepted) ? ; state . serialize_field (crate :: prisma :: users :: email :: NAME , & self . email) ? ; state . serialize_field (crate :: prisma :: users :: nickname :: NAME , & self . nickname) ? ; state . serialize_field (crate :: prisma :: users :: avatar_url :: NAME , & self . avatar_url) ? ; state . serialize_field (crate :: prisma :: users :: refresh_token :: NAME , & self . refresh_token) ? ; state . serialize_field (crate :: prisma :: users :: is_admin :: NAME , & self . is_admin) ? ; state . serialize_field (crate :: prisma :: users :: password :: NAME , & self . password) ? ; state . serialize_field (crate :: prisma :: users :: background_url :: NAME , & self . background_url) ? ; state . serialize_field (crate :: prisma :: users :: did_id :: NAME , & self . did_id) ? ; state . serialize_field (crate :: prisma :: users :: last_sync_ibt :: NAME , & self . last_sync_ibt) ? ; state . serialize_field (crate :: prisma :: users :: last_update :: NAME , & self . last_update) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , created_at , wallet_address , noti_accepted , spam_accepted , email , nickname , avatar_url , refresh_token , is_admin , password , background_url , did_id , last_sync_ibt , last_update } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: users :: $ field :: NAME) , + , crate :: prisma :: users :: id :: NAME , crate :: prisma :: users :: created_at :: NAME , crate :: prisma :: users :: wallet_address :: NAME , crate :: prisma :: users :: noti_accepted :: NAME , crate :: prisma :: users :: spam_accepted :: NAME , crate :: prisma :: users :: email :: NAME , crate :: prisma :: users :: nickname :: NAME , crate :: prisma :: users :: avatar_url :: NAME , crate :: prisma :: users :: refresh_token :: NAME , crate :: prisma :: users :: is_admin :: NAME , crate :: prisma :: users :: password :: NAME , crate :: prisma :: users :: background_url :: NAME , crate :: prisma :: users :: did_id :: NAME , crate :: prisma :: users :: last_sync_ibt :: NAME , crate :: prisma :: users :: last_update :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: users :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: users :: id :: NAME => Ok (Field :: id) , crate :: prisma :: users :: created_at :: NAME => Ok (Field :: created_at) , crate :: prisma :: users :: wallet_address :: NAME => Ok (Field :: wallet_address) , crate :: prisma :: users :: noti_accepted :: NAME => Ok (Field :: noti_accepted) , crate :: prisma :: users :: spam_accepted :: NAME => Ok (Field :: spam_accepted) , crate :: prisma :: users :: email :: NAME => Ok (Field :: email) , crate :: prisma :: users :: nickname :: NAME => Ok (Field :: nickname) , crate :: prisma :: users :: avatar_url :: NAME => Ok (Field :: avatar_url) , crate :: prisma :: users :: refresh_token :: NAME => Ok (Field :: refresh_token) , crate :: prisma :: users :: is_admin :: NAME => Ok (Field :: is_admin) , crate :: prisma :: users :: password :: NAME => Ok (Field :: password) , crate :: prisma :: users :: background_url :: NAME => Ok (Field :: background_url) , crate :: prisma :: users :: did_id :: NAME => Ok (Field :: did_id) , crate :: prisma :: users :: last_sync_ibt :: NAME => Ok (Field :: last_sync_ibt) , crate :: prisma :: users :: last_update :: NAME => Ok (Field :: last_update) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut created_at = None ; let mut wallet_address = None ; let mut noti_accepted = None ; let mut spam_accepted = None ; let mut email = None ; let mut nickname = None ; let mut avatar_url = None ; let mut refresh_token = None ; let mut is_admin = None ; let mut password = None ; let mut background_url = None ; let mut did_id = None ; let mut last_sync_ibt = None ; let mut last_update = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: created_at :: NAME)) ; } created_at = Some (map . next_value () ?) ; } Field :: wallet_address => { if wallet_address . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: wallet_address :: NAME)) ; } wallet_address = Some (map . next_value () ?) ; } Field :: noti_accepted => { if noti_accepted . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: noti_accepted :: NAME)) ; } noti_accepted = Some (map . next_value () ?) ; } Field :: spam_accepted => { if spam_accepted . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: spam_accepted :: NAME)) ; } spam_accepted = Some (map . next_value () ?) ; } Field :: email => { if email . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: email :: NAME)) ; } email = Some (map . next_value () ?) ; } Field :: nickname => { if nickname . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: nickname :: NAME)) ; } nickname = Some (map . next_value () ?) ; } Field :: avatar_url => { if avatar_url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: avatar_url :: NAME)) ; } avatar_url = Some (map . next_value () ?) ; } Field :: refresh_token => { if refresh_token . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: refresh_token :: NAME)) ; } refresh_token = Some (map . next_value () ?) ; } Field :: is_admin => { if is_admin . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: is_admin :: NAME)) ; } is_admin = Some (map . next_value () ?) ; } Field :: password => { if password . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: password :: NAME)) ; } password = Some (map . next_value () ?) ; } Field :: background_url => { if background_url . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: background_url :: NAME)) ; } background_url = Some (map . next_value () ?) ; } Field :: did_id => { if did_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: did_id :: NAME)) ; } did_id = Some (map . next_value () ?) ; } Field :: last_sync_ibt => { if last_sync_ibt . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: last_sync_ibt :: NAME)) ; } last_sync_ibt = Some (map . next_value () ?) ; } Field :: last_update => { if last_update . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: last_update :: NAME)) ; } last_update = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: id :: NAME)) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: created_at :: NAME)) ? ; let wallet_address = wallet_address . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: wallet_address :: NAME)) ? ; let noti_accepted = noti_accepted . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: noti_accepted :: NAME)) ? ; let spam_accepted = spam_accepted . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: spam_accepted :: NAME)) ? ; let email = email . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: email :: NAME)) ? ; let nickname = nickname . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: nickname :: NAME)) ? ; let avatar_url = avatar_url . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: avatar_url :: NAME)) ? ; let refresh_token = refresh_token . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: refresh_token :: NAME)) ? ; let is_admin = is_admin . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: is_admin :: NAME)) ? ; let password = password . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: password :: NAME)) ? ; let background_url = background_url . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: background_url :: NAME)) ? ; let did_id = did_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: did_id :: NAME)) ? ; let last_sync_ibt = last_sync_ibt . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: last_sync_ibt :: NAME)) ? ; let last_update = last_update . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users :: last_update :: NAME)) ? ; Ok (Data { id , created_at , wallet_address , noti_accepted , spam_accepted , email , nickname , avatar_url , refresh_token , is_admin , password , background_url , did_id , last_sync_ibt , last_update , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "created_at" , "wallet_address" , "noti_accepted" , "spam_accepted" , "email" , "nickname" , "avatar_url" , "refresh_token" , "isAdmin" , "password" , "background_url" , "didId" , "last_sync_ibt" , "last_update" , "activities_activities_from_user_idTousers" , "activities_activities_user_idTousers" , "feedbacks_on_businesses" , "followers_on_businesses" , "notifications_notifications_fromTousers" , "notifications_notifications_toTousers" , "rates_on_businesses" , "replies" , "replies_on_feedbacks" , "reviews" , "socials" , "dids" , "users_on_campaigns"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: users :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; activities_activities_from_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < activities_activities_from_user_id_tousers :: Data > } ; (@ field_type ; activities_activities_from_user_id_tousers) => { Vec < crate :: prisma :: activities :: Data > } ; (@ field_type ; activities_activities_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < activities_activities_user_id_tousers :: Data > } ; (@ field_type ; activities_activities_user_id_tousers) => { Vec < crate :: prisma :: activities :: Data > } ; (@ field_type ; feedbacks_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < feedbacks_on_businesses :: Data > } ; (@ field_type ; feedbacks_on_businesses) => { Vec < crate :: prisma :: feedbacks_on_businesses :: Data > } ; (@ field_type ; followers_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < followers_on_businesses :: Data > } ; (@ field_type ; followers_on_businesses) => { Vec < crate :: prisma :: followers_on_businesses :: Data > } ; (@ field_type ; notifications_notifications_from_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < notifications_notifications_from_tousers :: Data > } ; (@ field_type ; notifications_notifications_from_tousers) => { Vec < crate :: prisma :: notifications :: Data > } ; (@ field_type ; notifications_notifications_to_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < notifications_notifications_to_tousers :: Data > } ; (@ field_type ; notifications_notifications_to_tousers) => { Vec < crate :: prisma :: notifications :: Data > } ; (@ field_type ; rates_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < rates_on_businesses :: Data > } ; (@ field_type ; rates_on_businesses) => { Vec < crate :: prisma :: rates_on_businesses :: Data > } ; (@ field_type ; replies : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < replies :: Data > } ; (@ field_type ; replies) => { Vec < crate :: prisma :: replies :: Data > } ; (@ field_type ; replies_on_feedbacks : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < replies_on_feedbacks :: Data > } ; (@ field_type ; replies_on_feedbacks) => { Vec < crate :: prisma :: replies_on_feedbacks :: Data > } ; (@ field_type ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < reviews :: Data > } ; (@ field_type ; reviews) => { Vec < crate :: prisma :: reviews :: Data > } ; (@ field_type ; socials : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < socials :: Data > } ; (@ field_type ; socials) => { Option < crate :: prisma :: socials :: Data > } ; (@ field_type ; dids : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < dids :: Data > } ; (@ field_type ; dids) => { Option < crate :: prisma :: dids :: Data > } ; (@ field_type ; users_on_campaigns : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < users_on_campaigns :: Data > } ; (@ field_type ; users_on_campaigns) => { Vec < crate :: prisma :: users_on_campaigns :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Users" , available relations are "activities_activities_from_user_id_tousers, activities_activities_user_id_tousers, feedbacks_on_businesses, followers_on_businesses, notifications_notifications_from_tousers, notifications_notifications_to_tousers, rates_on_businesses, replies, replies_on_feedbacks, reviews, socials, dids, users_on_campaigns")) } ; (@ field_module ; activities_activities_from_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: activities :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; activities_activities_user_id_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: activities :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; feedbacks_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: feedbacks_on_businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; followers_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: followers_on_businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; notifications_notifications_from_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: notifications :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; notifications_notifications_to_tousers : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: notifications :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; rates_on_businesses : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: rates_on_businesses :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; replies : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: replies :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; replies_on_feedbacks : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: replies_on_feedbacks :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; reviews : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: reviews :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; socials : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: socials :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; dids : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: dids :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users_on_campaigns : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users_on_campaigns :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; activities_activities_from_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: activities_activities_from_user_id_tousers :: Include :: $ selection_mode (crate :: prisma :: activities :: ManyArgs :: new (crate :: prisma :: activities :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: activities :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; activities_activities_from_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: activities_activities_from_user_id_tousers :: Include :: Fetch (crate :: prisma :: activities :: ManyArgs :: new (crate :: prisma :: activities :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; activities_activities_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: activities_activities_user_id_tousers :: Include :: $ selection_mode (crate :: prisma :: activities :: ManyArgs :: new (crate :: prisma :: activities :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: activities :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; activities_activities_user_id_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: activities_activities_user_id_tousers :: Include :: Fetch (crate :: prisma :: activities :: ManyArgs :: new (crate :: prisma :: activities :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; feedbacks_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: feedbacks_on_businesses :: Include :: $ selection_mode (crate :: prisma :: feedbacks_on_businesses :: ManyArgs :: new (crate :: prisma :: feedbacks_on_businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: feedbacks_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; feedbacks_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: feedbacks_on_businesses :: Include :: Fetch (crate :: prisma :: feedbacks_on_businesses :: ManyArgs :: new (crate :: prisma :: feedbacks_on_businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; followers_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: followers_on_businesses :: Include :: $ selection_mode (crate :: prisma :: followers_on_businesses :: ManyArgs :: new (crate :: prisma :: followers_on_businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: followers_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; followers_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: followers_on_businesses :: Include :: Fetch (crate :: prisma :: followers_on_businesses :: ManyArgs :: new (crate :: prisma :: followers_on_businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; notifications_notifications_from_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: notifications_notifications_from_tousers :: Include :: $ selection_mode (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: notifications :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; notifications_notifications_from_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: notifications_notifications_from_tousers :: Include :: Fetch (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; notifications_notifications_to_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: notifications_notifications_to_tousers :: Include :: $ selection_mode (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: notifications :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; notifications_notifications_to_tousers $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: notifications_notifications_to_tousers :: Include :: Fetch (crate :: prisma :: notifications :: ManyArgs :: new (crate :: prisma :: notifications :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; rates_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: rates_on_businesses :: Include :: $ selection_mode (crate :: prisma :: rates_on_businesses :: ManyArgs :: new (crate :: prisma :: rates_on_businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: rates_on_businesses :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; rates_on_businesses $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: rates_on_businesses :: Include :: Fetch (crate :: prisma :: rates_on_businesses :: ManyArgs :: new (crate :: prisma :: rates_on_businesses :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; replies $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: replies :: Include :: $ selection_mode (crate :: prisma :: replies :: ManyArgs :: new (crate :: prisma :: replies :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: replies :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; replies $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: replies :: Include :: Fetch (crate :: prisma :: replies :: ManyArgs :: new (crate :: prisma :: replies :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; replies_on_feedbacks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: replies_on_feedbacks :: Include :: $ selection_mode (crate :: prisma :: replies_on_feedbacks :: ManyArgs :: new (crate :: prisma :: replies_on_feedbacks :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: replies_on_feedbacks :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; replies_on_feedbacks $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: replies_on_feedbacks :: Include :: Fetch (crate :: prisma :: replies_on_feedbacks :: ManyArgs :: new (crate :: prisma :: replies_on_feedbacks :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: reviews :: Include :: $ selection_mode (crate :: prisma :: reviews :: ManyArgs :: new (crate :: prisma :: reviews :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: reviews :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; reviews $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: reviews :: Include :: Fetch (crate :: prisma :: reviews :: ManyArgs :: new (crate :: prisma :: reviews :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; socials $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: socials :: Include :: $ selection_mode (crate :: prisma :: socials :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; socials $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: socials :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; dids $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: dids :: Include :: $ selection_mode (crate :: prisma :: dids :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; dids $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: dids :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users_on_campaigns $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: users_on_campaigns :: Include :: $ selection_mode (crate :: prisma :: users_on_campaigns :: ManyArgs :: new (crate :: prisma :: users_on_campaigns :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , crate :: prisma :: users_on_campaigns :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users_on_campaigns $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users :: IncludeParam > :: into (crate :: prisma :: users :: users_on_campaigns :: Include :: Fetch (crate :: prisma :: users_on_campaigns :: ManyArgs :: new (crate :: prisma :: users_on_campaigns :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: users :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; created_at) => { "created_at" } ; (@ field_serde_name ; wallet_address) => { "wallet_address" } ; (@ field_serde_name ; noti_accepted) => { "noti_accepted" } ; (@ field_serde_name ; spam_accepted) => { "spam_accepted" } ; (@ field_serde_name ; email) => { "email" } ; (@ field_serde_name ; nickname) => { "nickname" } ; (@ field_serde_name ; avatar_url) => { "avatar_url" } ; (@ field_serde_name ; refresh_token) => { "refresh_token" } ; (@ field_serde_name ; is_admin) => { "isAdmin" } ; (@ field_serde_name ; password) => { "password" } ; (@ field_serde_name ; background_url) => { "background_url" } ; (@ field_serde_name ; did_id) => { "didId" } ; (@ field_serde_name ; last_sync_ibt) => { "last_sync_ibt" } ; (@ field_serde_name ; last_update) => { "last_update" } ; (@ field_serde_name ; activities_activities_from_user_id_tousers) => { "activities_activities_from_user_idTousers" } ; (@ field_serde_name ; activities_activities_user_id_tousers) => { "activities_activities_user_idTousers" } ; (@ field_serde_name ; feedbacks_on_businesses) => { "feedbacks_on_businesses" } ; (@ field_serde_name ; followers_on_businesses) => { "followers_on_businesses" } ; (@ field_serde_name ; notifications_notifications_from_tousers) => { "notifications_notifications_fromTousers" } ; (@ field_serde_name ; notifications_notifications_to_tousers) => { "notifications_notifications_toTousers" } ; (@ field_serde_name ; rates_on_businesses) => { "rates_on_businesses" } ; (@ field_serde_name ; replies) => { "replies" } ; (@ field_serde_name ; replies_on_feedbacks) => { "replies_on_feedbacks" } ; (@ field_serde_name ; reviews) => { "reviews" } ; (@ field_serde_name ; socials) => { "socials" } ; (@ field_serde_name ; dids) => { "dids" } ; (@ field_serde_name ; users_on_campaigns) => { "users_on_campaigns" } ; }
    pub use _include_users as include;
    pub enum IncludeParam {
        Id(id::Include),
        CreatedAt(created_at::Include),
        WalletAddress(wallet_address::Include),
        NotiAccepted(noti_accepted::Include),
        SpamAccepted(spam_accepted::Include),
        Email(email::Include),
        Nickname(nickname::Include),
        AvatarUrl(avatar_url::Include),
        RefreshToken(refresh_token::Include),
        IsAdmin(is_admin::Include),
        Password(password::Include),
        BackgroundUrl(background_url::Include),
        DidId(did_id::Include),
        LastSyncIbt(last_sync_ibt::Include),
        LastUpdate(last_update::Include),
        ActivitiesActivitiesFromUserIdTousers(activities_activities_from_user_id_tousers::Include),
        ActivitiesActivitiesUserIdTousers(activities_activities_user_id_tousers::Include),
        FeedbacksOnBusinesses(feedbacks_on_businesses::Include),
        FollowersOnBusinesses(followers_on_businesses::Include),
        NotificationsNotificationsFromTousers(notifications_notifications_from_tousers::Include),
        NotificationsNotificationsToTousers(notifications_notifications_to_tousers::Include),
        RatesOnBusinesses(rates_on_businesses::Include),
        Replies(replies::Include),
        RepliesOnFeedbacks(replies_on_feedbacks::Include),
        Reviews(reviews::Include),
        Socials(socials::Include),
        Dids(dids::Include),
        UsersOnCampaigns(users_on_campaigns::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Id(data) => data.to_selection(),
                Self::CreatedAt(data) => data.to_selection(),
                Self::WalletAddress(data) => data.to_selection(),
                Self::NotiAccepted(data) => data.to_selection(),
                Self::SpamAccepted(data) => data.to_selection(),
                Self::Email(data) => data.to_selection(),
                Self::Nickname(data) => data.to_selection(),
                Self::AvatarUrl(data) => data.to_selection(),
                Self::RefreshToken(data) => data.to_selection(),
                Self::IsAdmin(data) => data.to_selection(),
                Self::Password(data) => data.to_selection(),
                Self::BackgroundUrl(data) => data.to_selection(),
                Self::DidId(data) => data.to_selection(),
                Self::LastSyncIbt(data) => data.to_selection(),
                Self::LastUpdate(data) => data.to_selection(),
                Self::ActivitiesActivitiesFromUserIdTousers(data) => data.to_selection(),
                Self::ActivitiesActivitiesUserIdTousers(data) => data.to_selection(),
                Self::FeedbacksOnBusinesses(data) => data.to_selection(),
                Self::FollowersOnBusinesses(data) => data.to_selection(),
                Self::NotificationsNotificationsFromTousers(data) => data.to_selection(),
                Self::NotificationsNotificationsToTousers(data) => data.to_selection(),
                Self::RatesOnBusinesses(data) => data.to_selection(),
                Self::Replies(data) => data.to_selection(),
                Self::RepliesOnFeedbacks(data) => data.to_selection(),
                Self::Reviews(data) => data.to_selection(),
                Self::Socials(data) => data.to_selection(),
                Self::Dids(data) => data.to_selection(),
                Self::UsersOnCampaigns(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_users { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: users struct $ struct_name { # [serde (rename = "id")] pub id : i32 , # [serde (rename = "created_at")] pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "wallet_address")] pub wallet_address : String , # [serde (rename = "noti_accepted")] pub noti_accepted : bool , # [serde (rename = "spam_accepted")] pub spam_accepted : bool , # [serde (rename = "email")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub email : Option < String > , # [serde (rename = "nickname")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub nickname : Option < String > , # [serde (rename = "avatar_url")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub avatar_url : Option < String > , # [serde (rename = "refresh_token")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub refresh_token : Option < String > , # [serde (rename = "isAdmin")] pub is_admin : bool , # [serde (rename = "password")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub password : Option < String > , # [serde (rename = "background_url")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub background_url : Option < String > , # [serde (rename = "didId")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub did_id : Option < i32 > , # [serde (rename = "last_sync_ibt")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub last_sync_ibt : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > , # [serde (rename = "last_update")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub last_update : Option < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_users as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "created_at")]
        pub created_at:
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        #[serde(rename = "wallet_address")]
        pub wallet_address: String,
        #[serde(rename = "noti_accepted")]
        pub noti_accepted: bool,
        #[serde(rename = "spam_accepted")]
        pub spam_accepted: bool,
        #[serde(rename = "email")]
        pub email: Option<String>,
        #[serde(rename = "nickname")]
        pub nickname: Option<String>,
        #[serde(rename = "avatar_url")]
        pub avatar_url: Option<String>,
        #[serde(rename = "refresh_token")]
        pub refresh_token: Option<String>,
        #[serde(rename = "isAdmin")]
        pub is_admin: bool,
        #[serde(rename = "password")]
        pub password: Option<String>,
        #[serde(rename = "background_url")]
        pub background_url: Option<String>,
        #[serde(rename = "didId")]
        pub did_id: Option<i32>,
        #[serde(rename = "last_sync_ibt")]
        pub last_sync_ibt: Option<
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        >,
        #[serde(rename = "last_update")]
        pub last_update: Option<
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        >,
        #[serde(rename = "activities_activities_from_user_idTousers")]
        pub activities_activities_from_user_id_tousers: Option<Vec<super::activities::Data>>,
        #[serde(rename = "activities_activities_user_idTousers")]
        pub activities_activities_user_id_tousers: Option<Vec<super::activities::Data>>,
        #[serde(rename = "feedbacks_on_businesses")]
        pub feedbacks_on_businesses: Option<Vec<super::feedbacks_on_businesses::Data>>,
        #[serde(rename = "followers_on_businesses")]
        pub followers_on_businesses: Option<Vec<super::followers_on_businesses::Data>>,
        #[serde(rename = "notifications_notifications_fromTousers")]
        pub notifications_notifications_from_tousers: Option<Vec<super::notifications::Data>>,
        #[serde(rename = "notifications_notifications_toTousers")]
        pub notifications_notifications_to_tousers: Option<Vec<super::notifications::Data>>,
        #[serde(rename = "rates_on_businesses")]
        pub rates_on_businesses: Option<Vec<super::rates_on_businesses::Data>>,
        #[serde(rename = "replies")]
        pub replies: Option<Vec<super::replies::Data>>,
        #[serde(rename = "replies_on_feedbacks")]
        pub replies_on_feedbacks: Option<Vec<super::replies_on_feedbacks::Data>>,
        #[serde(rename = "reviews")]
        pub reviews: Option<Vec<super::reviews::Data>>,
        #[serde(
            rename = "socials",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub socials: Option<Option<Box<super::socials::Data>>>,
        #[serde(
            rename = "dids",
            default,
            skip_serializing_if = "Option::is_none",
            with = "prisma_client_rust::serde::double_option"
        )]
        pub dids: Option<Option<Box<super::dids::Data>>>,
        #[serde(rename = "users_on_campaigns")]
        pub users_on_campaigns: Option<Vec<super::users_on_campaigns::Data>>,
    }
    impl Data {
        pub fn activities_activities_from_user_id_tousers(
            &self,
        ) -> Result<&Vec<super::activities::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.activities_activities_from_user_id_tousers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(activities_activities_from_user_id_tousers),
                ))
        }
        pub fn activities_activities_user_id_tousers(
            &self,
        ) -> Result<&Vec<super::activities::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.activities_activities_user_id_tousers.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    activities_activities_user_id_tousers
                )),
            )
        }
        pub fn feedbacks_on_businesses(
            &self,
        ) -> Result<
            &Vec<super::feedbacks_on_businesses::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.feedbacks_on_businesses.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    feedbacks_on_businesses
                )),
            )
        }
        pub fn followers_on_businesses(
            &self,
        ) -> Result<
            &Vec<super::followers_on_businesses::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.followers_on_businesses.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    followers_on_businesses
                )),
            )
        }
        pub fn notifications_notifications_from_tousers(
            &self,
        ) -> Result<&Vec<super::notifications::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.notifications_notifications_from_tousers
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(notifications_notifications_from_tousers),
                ))
        }
        pub fn notifications_notifications_to_tousers(
            &self,
        ) -> Result<&Vec<super::notifications::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.notifications_notifications_to_tousers.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    notifications_notifications_to_tousers
                )),
            )
        }
        pub fn rates_on_businesses(
            &self,
        ) -> Result<
            &Vec<super::rates_on_businesses::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.rates_on_businesses.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(rates_on_businesses)),
            )
        }
        pub fn replies(
            &self,
        ) -> Result<&Vec<super::replies::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.replies
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(replies),
                ))
        }
        pub fn replies_on_feedbacks(
            &self,
        ) -> Result<
            &Vec<super::replies_on_feedbacks::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.replies_on_feedbacks.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(
                    replies_on_feedbacks
                )),
            )
        }
        pub fn reviews(
            &self,
        ) -> Result<&Vec<super::reviews::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.reviews
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(reviews),
                ))
        }
        pub fn socials(
            &self,
        ) -> Result<Option<&super::socials::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.socials
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(socials),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn dids(
            &self,
        ) -> Result<Option<&super::dids::Data>, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.dids
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(dids),
                ))
                .map(|v| v.as_ref().map(|v| v.as_ref()))
        }
        pub fn users_on_campaigns(
            &self,
        ) -> Result<
            &Vec<super::users_on_campaigns::Data>,
            ::prisma_client_rust::RelationNotFetchedError,
        > {
            self.users_on_campaigns.as_ref().ok_or(
                ::prisma_client_rust::RelationNotFetchedError::new(stringify!(users_on_campaigns)),
            )
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        ActivitiesActivitiesFromUserIdTousers(super::activities::ManyArgs),
        ActivitiesActivitiesUserIdTousers(super::activities::ManyArgs),
        FeedbacksOnBusinesses(super::feedbacks_on_businesses::ManyArgs),
        FollowersOnBusinesses(super::followers_on_businesses::ManyArgs),
        NotificationsNotificationsFromTousers(super::notifications::ManyArgs),
        NotificationsNotificationsToTousers(super::notifications::ManyArgs),
        RatesOnBusinesses(super::rates_on_businesses::ManyArgs),
        Replies(super::replies::ManyArgs),
        RepliesOnFeedbacks(super::replies_on_feedbacks::ManyArgs),
        Reviews(super::reviews::ManyArgs),
        Socials(super::socials::UniqueArgs),
        Dids(super::dids::UniqueArgs),
        UsersOnCampaigns(super::users_on_campaigns::ManyArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::ActivitiesActivitiesFromUserIdTousers(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: activities :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        activities_activities_from_user_id_tousers::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::ActivitiesActivitiesUserIdTousers(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: activities :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        activities_activities_user_id_tousers::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::FeedbacksOnBusinesses(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: feedbacks_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        feedbacks_on_businesses::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::FollowersOnBusinesses(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: followers_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        followers_on_businesses::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::NotificationsNotificationsFromTousers(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        notifications_notifications_from_tousers::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::NotificationsNotificationsToTousers(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: notifications :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        notifications_notifications_to_tousers::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::RatesOnBusinesses(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: rates_on_businesses :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        rates_on_businesses::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Replies(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: replies :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        replies::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::RepliesOnFeedbacks(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: replies_on_feedbacks :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        replies_on_feedbacks::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Reviews(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: reviews :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        reviews::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
                Self::Socials(args) => {
                    let mut selections = < super :: socials :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(socials::NAME, None, [], selections)
                }
                Self::Dids(args) => {
                    let mut selections =
                        <super::dids::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
                        );
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(dids::NAME, None, [], selections)
                }
                Self::UsersOnCampaigns(args) => {
                    let (arguments, mut nested_selections) = args.to_graphql();
                    nested_selections . extend (< super :: users_on_campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
                    ::prisma_client_rust::Selection::new(
                        users_on_campaigns::NAME,
                        None,
                        arguments,
                        nested_selections,
                    )
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        SetWalletAddress(String),
        SetNotiAccepted(bool),
        SetSpamAccepted(bool),
        SetEmail(Option<String>),
        SetNickname(Option<String>),
        SetAvatarUrl(Option<String>),
        SetRefreshToken(Option<String>),
        SetIsAdmin(bool),
        SetPassword(Option<String>),
        SetBackgroundUrl(Option<String>),
        SetDidId(Option<i32>),
        IncrementDidId(i32),
        DecrementDidId(i32),
        MultiplyDidId(i32),
        DivideDidId(i32),
        SetLastSyncIbt(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        SetLastUpdate(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        ConnectActivitiesActivitiesFromUserIdTousers(Vec<super::activities::UniqueWhereParam>),
        DisconnectActivitiesActivitiesFromUserIdTousers(Vec<super::activities::UniqueWhereParam>),
        SetActivitiesActivitiesFromUserIdTousers(Vec<super::activities::UniqueWhereParam>),
        ConnectActivitiesActivitiesUserIdTousers(Vec<super::activities::UniqueWhereParam>),
        DisconnectActivitiesActivitiesUserIdTousers(Vec<super::activities::UniqueWhereParam>),
        SetActivitiesActivitiesUserIdTousers(Vec<super::activities::UniqueWhereParam>),
        ConnectFeedbacksOnBusinesses(Vec<super::feedbacks_on_businesses::UniqueWhereParam>),
        DisconnectFeedbacksOnBusinesses(Vec<super::feedbacks_on_businesses::UniqueWhereParam>),
        SetFeedbacksOnBusinesses(Vec<super::feedbacks_on_businesses::UniqueWhereParam>),
        ConnectFollowersOnBusinesses(Vec<super::followers_on_businesses::UniqueWhereParam>),
        DisconnectFollowersOnBusinesses(Vec<super::followers_on_businesses::UniqueWhereParam>),
        SetFollowersOnBusinesses(Vec<super::followers_on_businesses::UniqueWhereParam>),
        ConnectNotificationsNotificationsFromTousers(Vec<super::notifications::UniqueWhereParam>),
        DisconnectNotificationsNotificationsFromTousers(
            Vec<super::notifications::UniqueWhereParam>,
        ),
        SetNotificationsNotificationsFromTousers(Vec<super::notifications::UniqueWhereParam>),
        ConnectNotificationsNotificationsToTousers(Vec<super::notifications::UniqueWhereParam>),
        DisconnectNotificationsNotificationsToTousers(Vec<super::notifications::UniqueWhereParam>),
        SetNotificationsNotificationsToTousers(Vec<super::notifications::UniqueWhereParam>),
        ConnectRatesOnBusinesses(Vec<super::rates_on_businesses::UniqueWhereParam>),
        DisconnectRatesOnBusinesses(Vec<super::rates_on_businesses::UniqueWhereParam>),
        SetRatesOnBusinesses(Vec<super::rates_on_businesses::UniqueWhereParam>),
        ConnectReplies(Vec<super::replies::UniqueWhereParam>),
        DisconnectReplies(Vec<super::replies::UniqueWhereParam>),
        SetReplies(Vec<super::replies::UniqueWhereParam>),
        ConnectRepliesOnFeedbacks(Vec<super::replies_on_feedbacks::UniqueWhereParam>),
        DisconnectRepliesOnFeedbacks(Vec<super::replies_on_feedbacks::UniqueWhereParam>),
        SetRepliesOnFeedbacks(Vec<super::replies_on_feedbacks::UniqueWhereParam>),
        ConnectReviews(Vec<super::reviews::UniqueWhereParam>),
        DisconnectReviews(Vec<super::reviews::UniqueWhereParam>),
        SetReviews(Vec<super::reviews::UniqueWhereParam>),
        ConnectSocials(super::socials::UniqueWhereParam),
        DisconnectSocials,
        ConnectDids(super::dids::UniqueWhereParam),
        DisconnectDids,
        ConnectUsersOnCampaigns(Vec<super::users_on_campaigns::UniqueWhereParam>),
        DisconnectUsersOnCampaigns(Vec<super::users_on_campaigns::UniqueWhereParam>),
        SetUsersOnCampaigns(Vec<super::users_on_campaigns::UniqueWhereParam>),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideId(value) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCreatedAt(value) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::DateTime(value),
                ),
                SetParam::SetWalletAddress(value) => (
                    wallet_address::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(value),
                ),
                SetParam::SetNotiAccepted(value) => (
                    noti_accepted::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetSpamAccepted(value) => (
                    spam_accepted::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetEmail(value) => (
                    email::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetNickname(value) => (
                    nickname::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetAvatarUrl(value) => (
                    avatar_url::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetRefreshToken(value) => (
                    refresh_token::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetIsAdmin(value) => (
                    is_admin::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetPassword(value) => (
                    password::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetBackgroundUrl(value) => (
                    background_url::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetDidId(value) => (
                    did_id::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::IncrementDidId(value) => (
                    did_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementDidId(value) => (
                    did_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyDidId(value) => (
                    did_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideDidId(value) => (
                    did_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetLastSyncIbt(value) => (
                    last_sync_ibt::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::SetLastUpdate(value) => (
                    last_update::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectActivitiesActivitiesFromUserIdTousers(where_params) => (
                    activities_activities_from_user_id_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::activities::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectActivitiesActivitiesFromUserIdTousers(where_params) => (
                    activities_activities_from_user_id_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::activities::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetActivitiesActivitiesFromUserIdTousers(where_params) => (
                    activities_activities_from_user_id_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::activities::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectActivitiesActivitiesUserIdTousers(where_params) => (
                    activities_activities_user_id_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::activities::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectActivitiesActivitiesUserIdTousers(where_params) => (
                    activities_activities_user_id_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::activities::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetActivitiesActivitiesUserIdTousers(where_params) => (
                    activities_activities_user_id_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::activities::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectFeedbacksOnBusinesses(where_params) => (
                    feedbacks_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::feedbacks_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectFeedbacksOnBusinesses(where_params) => (
                    feedbacks_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::feedbacks_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetFeedbacksOnBusinesses(where_params) => (
                    feedbacks_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::feedbacks_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectFollowersOnBusinesses(where_params) => (
                    followers_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::followers_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectFollowersOnBusinesses(where_params) => (
                    followers_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::followers_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetFollowersOnBusinesses(where_params) => (
                    followers_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::followers_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectNotificationsNotificationsFromTousers(where_params) => (
                    notifications_notifications_from_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::notifications::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectNotificationsNotificationsFromTousers(where_params) => (
                    notifications_notifications_from_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::notifications::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetNotificationsNotificationsFromTousers(where_params) => (
                    notifications_notifications_from_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::notifications::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectNotificationsNotificationsToTousers(where_params) => (
                    notifications_notifications_to_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::notifications::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectNotificationsNotificationsToTousers(where_params) => (
                    notifications_notifications_to_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::notifications::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetNotificationsNotificationsToTousers(where_params) => (
                    notifications_notifications_to_tousers::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::notifications::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectRatesOnBusinesses(where_params) => (
                    rates_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::rates_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectRatesOnBusinesses(where_params) => (
                    rates_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::rates_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetRatesOnBusinesses(where_params) => (
                    rates_on_businesses::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::rates_on_businesses::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectReplies(where_params) => (
                    replies::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::replies::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectReplies(where_params) => (
                    replies::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::replies::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetReplies(where_params) => (
                    replies::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::replies::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectRepliesOnFeedbacks(where_params) => (
                    replies_on_feedbacks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::replies_on_feedbacks::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectRepliesOnFeedbacks(where_params) => (
                    replies_on_feedbacks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::replies_on_feedbacks::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetRepliesOnFeedbacks(where_params) => (
                    replies_on_feedbacks::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::replies_on_feedbacks::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectReviews(where_params) => (
                    reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectReviews(where_params) => (
                    reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetReviews(where_params) => (
                    reviews::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::reviews::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectSocials(where_param) => (
                    socials::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::socials::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectSocials => (
                    socials::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectDids(where_param) => (
                    dids::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::dids::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectDids => (
                    dids::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(true),
                    )]),
                ),
                SetParam::ConnectUsersOnCampaigns(where_params) => (
                    users_on_campaigns::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users_on_campaigns::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::DisconnectUsersOnCampaigns(where_params) => (
                    users_on_campaigns::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "disconnect".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users_on_campaigns::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::SetUsersOnCampaigns(where_params) => (
                    users_on_campaigns::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "set".to_string(),
                        ::prisma_client_rust::PrismaValue::List(
                            where_params
                                .into_iter()
                                .map(Into::<super::users_on_campaigns::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        Id(i32),
        CreatedAt(
            ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
        ),
        WalletAddress(String),
        NotiAccepted(bool),
        SpamAccepted(bool),
        Email(Option<String>),
        Nickname(Option<String>),
        AvatarUrl(Option<String>),
        RefreshToken(Option<String>),
        IsAdmin(bool),
        Password(Option<String>),
        BackgroundUrl(Option<String>),
        DidId(Option<i32>),
        LastSyncIbt(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
        LastUpdate(
            Option<
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            >,
        ),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::Id(value) => Self::SetId(value),
                UncheckedSetParam::CreatedAt(value) => Self::SetCreatedAt(value),
                UncheckedSetParam::WalletAddress(value) => Self::SetWalletAddress(value),
                UncheckedSetParam::NotiAccepted(value) => Self::SetNotiAccepted(value),
                UncheckedSetParam::SpamAccepted(value) => Self::SetSpamAccepted(value),
                UncheckedSetParam::Email(value) => Self::SetEmail(value),
                UncheckedSetParam::Nickname(value) => Self::SetNickname(value),
                UncheckedSetParam::AvatarUrl(value) => Self::SetAvatarUrl(value),
                UncheckedSetParam::RefreshToken(value) => Self::SetRefreshToken(value),
                UncheckedSetParam::IsAdmin(value) => Self::SetIsAdmin(value),
                UncheckedSetParam::Password(value) => Self::SetPassword(value),
                UncheckedSetParam::BackgroundUrl(value) => Self::SetBackgroundUrl(value),
                UncheckedSetParam::DidId(value) => Self::SetDidId(value),
                UncheckedSetParam::LastSyncIbt(value) => Self::SetLastSyncIbt(value),
                UncheckedSetParam::LastUpdate(value) => Self::SetLastUpdate(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        Id(::prisma_client_rust::Direction),
        CreatedAt(::prisma_client_rust::Direction),
        WalletAddress(::prisma_client_rust::Direction),
        NotiAccepted(::prisma_client_rust::Direction),
        SpamAccepted(::prisma_client_rust::Direction),
        Email(::prisma_client_rust::Direction),
        Nickname(::prisma_client_rust::Direction),
        AvatarUrl(::prisma_client_rust::Direction),
        RefreshToken(::prisma_client_rust::Direction),
        IsAdmin(::prisma_client_rust::Direction),
        Password(::prisma_client_rust::Direction),
        BackgroundUrl(::prisma_client_rust::Direction),
        DidId(::prisma_client_rust::Direction),
        LastSyncIbt(::prisma_client_rust::Direction),
        LastUpdate(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::Id(direction) => (
                    id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CreatedAt(direction) => (
                    created_at::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::WalletAddress(direction) => (
                    wallet_address::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::NotiAccepted(direction) => (
                    noti_accepted::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::SpamAccepted(direction) => (
                    spam_accepted::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Email(direction) => (
                    email::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Nickname(direction) => (
                    nickname::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::AvatarUrl(direction) => (
                    avatar_url::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::RefreshToken(direction) => (
                    refresh_token::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::IsAdmin(direction) => (
                    is_admin::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Password(direction) => (
                    password::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::BackgroundUrl(direction) => (
                    background_url::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::DidId(direction) => (
                    did_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::LastSyncIbt(direction) => (
                    last_sync_ibt::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::LastUpdate(direction) => (
                    last_update::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        Id(_prisma::read_filters::IntFilter),
        CreatedAt(_prisma::read_filters::DateTimeFilter),
        WalletAddress(_prisma::read_filters::StringFilter),
        NotiAccepted(_prisma::read_filters::BoolFilter),
        SpamAccepted(_prisma::read_filters::BoolFilter),
        Email(_prisma::read_filters::StringNullableFilter),
        Nickname(_prisma::read_filters::StringNullableFilter),
        AvatarUrl(_prisma::read_filters::StringNullableFilter),
        RefreshToken(_prisma::read_filters::StringNullableFilter),
        IsAdmin(_prisma::read_filters::BoolFilter),
        Password(_prisma::read_filters::StringNullableFilter),
        BackgroundUrl(_prisma::read_filters::StringNullableFilter),
        DidId(_prisma::read_filters::IntNullableFilter),
        LastSyncIbt(_prisma::read_filters::DateTimeNullableFilter),
        LastUpdate(_prisma::read_filters::DateTimeNullableFilter),
        ActivitiesActivitiesFromUserIdTousersSome(Vec<super::activities::WhereParam>),
        ActivitiesActivitiesFromUserIdTousersEvery(Vec<super::activities::WhereParam>),
        ActivitiesActivitiesFromUserIdTousersNone(Vec<super::activities::WhereParam>),
        ActivitiesActivitiesUserIdTousersSome(Vec<super::activities::WhereParam>),
        ActivitiesActivitiesUserIdTousersEvery(Vec<super::activities::WhereParam>),
        ActivitiesActivitiesUserIdTousersNone(Vec<super::activities::WhereParam>),
        FeedbacksOnBusinessesSome(Vec<super::feedbacks_on_businesses::WhereParam>),
        FeedbacksOnBusinessesEvery(Vec<super::feedbacks_on_businesses::WhereParam>),
        FeedbacksOnBusinessesNone(Vec<super::feedbacks_on_businesses::WhereParam>),
        FollowersOnBusinessesSome(Vec<super::followers_on_businesses::WhereParam>),
        FollowersOnBusinessesEvery(Vec<super::followers_on_businesses::WhereParam>),
        FollowersOnBusinessesNone(Vec<super::followers_on_businesses::WhereParam>),
        NotificationsNotificationsFromTousersSome(Vec<super::notifications::WhereParam>),
        NotificationsNotificationsFromTousersEvery(Vec<super::notifications::WhereParam>),
        NotificationsNotificationsFromTousersNone(Vec<super::notifications::WhereParam>),
        NotificationsNotificationsToTousersSome(Vec<super::notifications::WhereParam>),
        NotificationsNotificationsToTousersEvery(Vec<super::notifications::WhereParam>),
        NotificationsNotificationsToTousersNone(Vec<super::notifications::WhereParam>),
        RatesOnBusinessesSome(Vec<super::rates_on_businesses::WhereParam>),
        RatesOnBusinessesEvery(Vec<super::rates_on_businesses::WhereParam>),
        RatesOnBusinessesNone(Vec<super::rates_on_businesses::WhereParam>),
        RepliesSome(Vec<super::replies::WhereParam>),
        RepliesEvery(Vec<super::replies::WhereParam>),
        RepliesNone(Vec<super::replies::WhereParam>),
        RepliesOnFeedbacksSome(Vec<super::replies_on_feedbacks::WhereParam>),
        RepliesOnFeedbacksEvery(Vec<super::replies_on_feedbacks::WhereParam>),
        RepliesOnFeedbacksNone(Vec<super::replies_on_feedbacks::WhereParam>),
        ReviewsSome(Vec<super::reviews::WhereParam>),
        ReviewsEvery(Vec<super::reviews::WhereParam>),
        ReviewsNone(Vec<super::reviews::WhereParam>),
        SocialsIsNull,
        SocialsIs(Vec<super::socials::WhereParam>),
        SocialsIsNot(Vec<super::socials::WhereParam>),
        DidsIsNull,
        DidsIs(Vec<super::dids::WhereParam>),
        DidsIsNot(Vec<super::dids::WhereParam>),
        UsersOnCampaignsSome(Vec<super::users_on_campaigns::WhereParam>),
        UsersOnCampaignsEvery(Vec<super::users_on_campaigns::WhereParam>),
        UsersOnCampaignsNone(Vec<super::users_on_campaigns::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Id(value) => (id::NAME, value.into()),
                Self::CreatedAt(value) => (created_at::NAME, value.into()),
                Self::WalletAddress(value) => (wallet_address::NAME, value.into()),
                Self::NotiAccepted(value) => (noti_accepted::NAME, value.into()),
                Self::SpamAccepted(value) => (spam_accepted::NAME, value.into()),
                Self::Email(value) => (email::NAME, value.into()),
                Self::Nickname(value) => (nickname::NAME, value.into()),
                Self::AvatarUrl(value) => (avatar_url::NAME, value.into()),
                Self::RefreshToken(value) => (refresh_token::NAME, value.into()),
                Self::IsAdmin(value) => (is_admin::NAME, value.into()),
                Self::Password(value) => (password::NAME, value.into()),
                Self::BackgroundUrl(value) => (background_url::NAME, value.into()),
                Self::DidId(value) => (did_id::NAME, value.into()),
                Self::LastSyncIbt(value) => (last_sync_ibt::NAME, value.into()),
                Self::LastUpdate(value) => (last_update::NAME, value.into()),
                Self::ActivitiesActivitiesFromUserIdTousersSome(where_params) => (
                    activities_activities_from_user_id_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActivitiesActivitiesFromUserIdTousersEvery(where_params) => (
                    activities_activities_from_user_id_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActivitiesActivitiesFromUserIdTousersNone(where_params) => (
                    activities_activities_from_user_id_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActivitiesActivitiesUserIdTousersSome(where_params) => (
                    activities_activities_user_id_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActivitiesActivitiesUserIdTousersEvery(where_params) => (
                    activities_activities_user_id_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActivitiesActivitiesUserIdTousersNone(where_params) => (
                    activities_activities_user_id_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FeedbacksOnBusinessesSome(where_params) => (
                    feedbacks_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FeedbacksOnBusinessesEvery(where_params) => (
                    feedbacks_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FeedbacksOnBusinessesNone(where_params) => (
                    feedbacks_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FollowersOnBusinessesSome(where_params) => (
                    followers_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FollowersOnBusinessesEvery(where_params) => (
                    followers_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::FollowersOnBusinessesNone(where_params) => (
                    followers_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotificationsNotificationsFromTousersSome(where_params) => (
                    notifications_notifications_from_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotificationsNotificationsFromTousersEvery(where_params) => (
                    notifications_notifications_from_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotificationsNotificationsFromTousersNone(where_params) => (
                    notifications_notifications_from_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotificationsNotificationsToTousersSome(where_params) => (
                    notifications_notifications_to_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotificationsNotificationsToTousersEvery(where_params) => (
                    notifications_notifications_to_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::NotificationsNotificationsToTousersNone(where_params) => (
                    notifications_notifications_to_tousers::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RatesOnBusinessesSome(where_params) => (
                    rates_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RatesOnBusinessesEvery(where_params) => (
                    rates_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RatesOnBusinessesNone(where_params) => (
                    rates_on_businesses::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepliesSome(where_params) => (
                    replies::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepliesEvery(where_params) => (
                    replies::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepliesNone(where_params) => (
                    replies::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepliesOnFeedbacksSome(where_params) => (
                    replies_on_feedbacks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepliesOnFeedbacksEvery(where_params) => (
                    replies_on_feedbacks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::RepliesOnFeedbacksNone(where_params) => (
                    replies_on_feedbacks::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewsSome(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewsEvery(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::ReviewsNone(where_params) => (
                    reviews::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SocialsIsNull => (
                    socials::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::SocialsIs(where_params) => (
                    socials::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::SocialsIsNot(where_params) => (
                    socials::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DidsIsNull => (
                    dids::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Value(
                        ::prisma_client_rust::PrismaValue::Null,
                    ),
                ),
                Self::DidsIs(where_params) => (
                    dids::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::DidsIsNot(where_params) => (
                    dids::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersOnCampaignsSome(where_params) => (
                    users_on_campaigns::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersOnCampaignsEvery(where_params) => (
                    users_on_campaigns::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersOnCampaignsNone(where_params) => (
                    users_on_campaigns::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        WalletAddressEquals(String),
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::WalletAddressEquals(value) => {
                    Self::WalletAddress(_prisma::read_filters::StringFilter::Equals(value))
                }
                UniqueWhereParam::IdEquals(value) => {
                    Self::Id(_prisma::read_filters::IntFilter::Equals(value))
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(id::NAME),
                ::prisma_client_rust::sel(created_at::NAME),
                ::prisma_client_rust::sel(wallet_address::NAME),
                ::prisma_client_rust::sel(noti_accepted::NAME),
                ::prisma_client_rust::sel(spam_accepted::NAME),
                ::prisma_client_rust::sel(email::NAME),
                ::prisma_client_rust::sel(nickname::NAME),
                ::prisma_client_rust::sel(avatar_url::NAME),
                ::prisma_client_rust::sel(refresh_token::NAME),
                ::prisma_client_rust::sel(is_admin::NAME),
                ::prisma_client_rust::sel(password::NAME),
                ::prisma_client_rust::sel(background_url::NAME),
                ::prisma_client_rust::sel(did_id::NAME),
                ::prisma_client_rust::sel(last_sync_ibt::NAME),
                ::prisma_client_rust::sel(last_update::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(self, wallet_address: String, mut _params: Vec<SetParam>) -> Create<'a> {
            _params.extend([wallet_address::set(wallet_address)]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            wallet_address: String,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([wallet_address::set(wallet_address)]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(String, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(wallet_address, mut _params)| {
                    _params.extend([wallet_address::set(wallet_address)]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (wallet_address, mut _params): (String, Vec<SetParam>),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([wallet_address::set(wallet_address)]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod users_on_campaigns {
    use super::_prisma::*;
    use super::*;
    pub const NAME: &str = "users_on_campaigns";
    pub mod user_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "user_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetUserId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::UserId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::UserId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, UserId, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::UserId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::UserId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod campaign_id {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "campaign_id";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetCampaignId(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::CampaignId(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::CampaignId(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::CampaignId(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::IntFilter,
            CampaignId,
            {
                fn in_vec(_: Vec<i32>) -> InVec;
                fn not_in_vec(_: Vec<i32>) -> NotInVec;
                fn lt(_: i32) -> Lt;
                fn lte(_: i32) -> Lte;
                fn gt(_: i32) -> Gt;
                fn gte(_: i32) -> Gte;
                fn not(_: i32) -> Not;
            }
        );
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementCampaignId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementCampaignId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyCampaignId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideCampaignId(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::CampaignId(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::CampaignId(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod claimed {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "claimed";
        pub struct Set(pub bool);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetClaimed(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Claimed(v)
            }
        }
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Claimed(direction)
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::Claimed(_prisma::read_filters::BoolFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::BoolFilter,
            Claimed,
            {
                fn not(_: bool) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Claimed(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Claimed(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod amount {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "amount";
        pub struct Set(pub i32);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetAmount(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::Amount(v)
            }
        }
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::Amount(direction)
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::Amount(_prisma::read_filters::IntFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(_prisma::read_filters::IntFilter, Amount, {
            fn in_vec(_: Vec<i32>) -> InVec;
            fn not_in_vec(_: Vec<i32>) -> NotInVec;
            fn lt(_: i32) -> Lt;
            fn lte(_: i32) -> Lte;
            fn gt(_: i32) -> Gt;
            fn gte(_: i32) -> Gte;
            fn not(_: i32) -> Not;
        });
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementAmount(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementAmount(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyAmount(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideAmount(value)
        }
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Amount(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Amount(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod txn_hash {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "txnHash";
        pub struct Set(pub Option<String>);
        impl From<Set> for SetParam {
            fn from(Set(v): Set) -> Self {
                Self::SetTxnHash(v)
            }
        }
        impl From<Set> for UncheckedSetParam {
            fn from(Set(v): Set) -> Self {
                Self::TxnHash(v)
            }
        }
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
            OrderByParam::TxnHash(direction)
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::TxnHash(_prisma::read_filters::StringNullableFilter::Equals(value))
        }
        ::prisma_client_rust::scalar_where_param_fns!(
            _prisma::read_filters::StringNullableFilter,
            TxnHash,
            {
                fn in_vec(_: Vec<String>) -> InVec;
                fn not_in_vec(_: Vec<String>) -> NotInVec;
                fn lt(_: String) -> Lt;
                fn lte(_: String) -> Lte;
                fn gt(_: String) -> Gt;
                fn gte(_: String) -> Gte;
                fn contains(_: String) -> Contains;
                fn starts_with(_: String) -> StartsWith;
                fn ends_with(_: String) -> EndsWith;
                fn mode(_: super::super::QueryMode) -> Mode;
                fn not(_: Option<String>) -> Not;
            }
        );
        pub struct Include;
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::TxnHash(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
        pub struct Select;
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::TxnHash(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                ::prisma_client_rust::sel(NAME)
            }
        }
    }
    pub mod campaigns {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "campaigns";
        pub struct Fetch(pub campaigns::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<campaigns::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Campaigns(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(campaigns::UniqueArgs::new())
        }
        pub struct Connect(campaigns::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectCampaigns(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: campaigns::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<campaigns::WhereParam>) -> WhereParam {
            WhereParam::CampaignsIs(value)
        }
        pub fn is_not(value: Vec<campaigns::WhereParam>) -> WhereParam {
            WhereParam::CampaignsIsNot(value)
        }
        pub enum Include {
            Select(Vec<campaigns::SelectParam>),
            Include(Vec<campaigns::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Campaigns(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = < campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <campaigns::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("campaigns", None, [], selections)
            }
            pub fn select(nested_selections: Vec<campaigns::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<campaigns::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<campaigns::SelectParam>),
            Include(Vec<campaigns::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Campaigns(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <campaigns::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("campaigns", None, [], selections)
            }
            pub fn select(nested_selections: Vec<campaigns::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<campaigns::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub mod users {
        use super::super::*;
        use super::_prisma::*;
        use super::{
            OrderByParam, SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam,
        };
        pub const NAME: &str = "users";
        pub struct Fetch(pub users::UniqueArgs);
        impl Fetch {
            pub fn with(mut self, params: impl Into<users::WithParam>) -> Self {
                self.0 = self.0.with(params.into());
                self
            }
        }
        impl From<Fetch> for WithParam {
            fn from(Fetch(v): Fetch) -> Self {
                WithParam::Users(v)
            }
        }
        pub fn fetch() -> Fetch {
            Fetch(users::UniqueArgs::new())
        }
        pub struct Connect(users::UniqueWhereParam);
        impl From<Connect> for SetParam {
            fn from(Connect(v): Connect) -> Self {
                Self::ConnectUsers(v)
            }
        }
        pub fn connect<T: From<Connect>>(value: users::UniqueWhereParam) -> T {
            Connect(value).into()
        }
        pub fn is(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIs(value)
        }
        pub fn is_not(value: Vec<users::WhereParam>) -> WhereParam {
            WhereParam::UsersIsNot(value)
        }
        pub enum Include {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::IncludeParam> for Include {
            fn into(self) -> super::IncludeParam {
                super::IncludeParam::Users(self)
            }
        }
        impl Include {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections =
                            <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
        pub enum Select {
            Select(Vec<users::SelectParam>),
            Include(Vec<users::IncludeParam>),
            Fetch,
        }
        impl Into<super::SelectParam> for Select {
            fn into(self) -> super::SelectParam {
                super::SelectParam::Users(self)
            }
        }
        impl Select {
            pub fn to_selection(self) -> ::prisma_client_rust::Selection {
                let selections = match self {
                    Self::Select(selections) => {
                        selections.into_iter().map(|s| s.to_selection()).collect()
                    }
                    Self::Include(selections) => {
                        let mut nested_selections = vec![];
                        nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
                        nested_selections
                    }
                    Self::Fetch => {
                        <users::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
                    }
                };
                ::prisma_client_rust::Selection::new("users", None, [], selections)
            }
            pub fn select(nested_selections: Vec<users::SelectParam>) -> Self {
                Self::Select(nested_selections)
            }
            pub fn include(nested_selections: Vec<users::IncludeParam>) -> Self {
                Self::Include(nested_selections)
            }
        }
    }
    pub fn user_id_campaign_id<T: From<UniqueWhereParam>>(user_id: i32, campaign_id: i32) -> T {
        UniqueWhereParam::UserIdCampaignIdEquals(user_id, campaign_id).into()
    }
    pub fn create(
        amount: i32,
        campaigns: super::campaigns::UniqueWhereParam,
        users: super::users::UniqueWhereParam,
        _params: Vec<SetParam>,
    ) -> (
        i32,
        super::campaigns::UniqueWhereParam,
        super::users::UniqueWhereParam,
        Vec<SetParam>,
    ) {
        (amount, campaigns, users, _params)
    }
    pub fn create_unchecked(
        user_id: i32,
        campaign_id: i32,
        amount: i32,
        _params: Vec<SetParam>,
    ) -> (i32, i32, i32, Vec<SetParam>) {
        (user_id, campaign_id, amount, _params)
    }
    #[macro_export]
    macro_rules ! _select_users_on_campaigns { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: users_on_campaigns :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users_on_campaigns :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: users_on_campaigns :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: users_on_campaigns :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users_on_campaigns :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: users_on_campaigns :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { user_id , campaign_id , claimed , amount , txn_hash , campaigns , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: prisma :: users_on_campaigns :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: users_on_campaigns :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: users_on_campaigns :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: users_on_campaigns :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_on_campaigns :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_on_campaigns :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["user_id" , "campaign_id" , "claimed" , "amount" , "txnHash" , "campaigns" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: users_on_campaigns :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; user_id) => { i32 } ; (@ field_type ; campaign_id) => { i32 } ; (@ field_type ; claimed) => { bool } ; (@ field_type ; amount) => { i32 } ; (@ field_type ; txn_hash) => { Option < String > } ; (@ field_type ; campaigns : $ selection_mode : ident { $ ($ selections : tt) + }) => { campaigns :: Data } ; (@ field_type ; campaigns) => { crate :: prisma :: campaigns :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "UsersOnCampaigns" , available relations are "user_id, campaign_id, claimed, amount, txn_hash, campaigns, users")) } ; (@ field_module ; campaigns : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: campaigns :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < crate :: prisma :: users_on_campaigns :: SelectParam > :: into (crate :: prisma :: users_on_campaigns :: user_id :: Select) } ; (@ selection_field_to_selection_param ; campaign_id) => { Into :: < crate :: prisma :: users_on_campaigns :: SelectParam > :: into (crate :: prisma :: users_on_campaigns :: campaign_id :: Select) } ; (@ selection_field_to_selection_param ; claimed) => { Into :: < crate :: prisma :: users_on_campaigns :: SelectParam > :: into (crate :: prisma :: users_on_campaigns :: claimed :: Select) } ; (@ selection_field_to_selection_param ; amount) => { Into :: < crate :: prisma :: users_on_campaigns :: SelectParam > :: into (crate :: prisma :: users_on_campaigns :: amount :: Select) } ; (@ selection_field_to_selection_param ; txn_hash) => { Into :: < crate :: prisma :: users_on_campaigns :: SelectParam > :: into (crate :: prisma :: users_on_campaigns :: txn_hash :: Select) } ; (@ selection_field_to_selection_param ; campaigns $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users_on_campaigns :: SelectParam > :: into (crate :: prisma :: users_on_campaigns :: campaigns :: Select :: $ selection_mode (crate :: prisma :: campaigns :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; campaigns $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users_on_campaigns :: SelectParam > :: into (crate :: prisma :: users_on_campaigns :: campaigns :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users_on_campaigns :: SelectParam > :: into (crate :: prisma :: users_on_campaigns :: users :: Select :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users_on_campaigns :: SelectParam > :: into (crate :: prisma :: users_on_campaigns :: users :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: users_on_campaigns :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; campaign_id) => { "campaign_id" } ; (@ field_serde_name ; claimed) => { "claimed" } ; (@ field_serde_name ; amount) => { "amount" } ; (@ field_serde_name ; txn_hash) => { "txnHash" } ; (@ field_serde_name ; campaigns) => { "campaigns" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _select_users_on_campaigns as select;
    pub enum SelectParam {
        UserId(user_id::Select),
        CampaignId(campaign_id::Select),
        Claimed(claimed::Select),
        Amount(amount::Select),
        TxnHash(txn_hash::Select),
        Campaigns(campaigns::Select),
        Users(users::Select),
    }
    impl SelectParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserId(data) => data.to_selection(),
                Self::CampaignId(data) => data.to_selection(),
                Self::Claimed(data) => data.to_selection(),
                Self::Amount(data) => data.to_selection(),
                Self::TxnHash(data) => data.to_selection(),
                Self::Campaigns(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _include_users_on_campaigns { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: prisma :: users_on_campaigns :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users_on_campaigns :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: prisma :: users_on_campaigns :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: users_on_campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: prisma :: users_on_campaigns :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: prisma :: users_on_campaigns :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: prisma :: users_on_campaigns :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: prisma :: users_on_campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { campaigns , users } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub user_id : i32 , pub campaign_id : i32 , pub claimed : bool , pub amount : i32 , pub txn_hash : Option < String > , $ (pub $ field : crate :: prisma :: users_on_campaigns :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (user_id) , stringify ! (campaign_id) , stringify ! (claimed) , stringify ! (amount) , stringify ! (txn_hash)] . len ()) ? ; $ (state . serialize_field (crate :: prisma :: users_on_campaigns :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: prisma :: users_on_campaigns :: user_id :: NAME , & self . user_id) ? ; state . serialize_field (crate :: prisma :: users_on_campaigns :: campaign_id :: NAME , & self . campaign_id) ? ; state . serialize_field (crate :: prisma :: users_on_campaigns :: claimed :: NAME , & self . claimed) ? ; state . serialize_field (crate :: prisma :: users_on_campaigns :: amount :: NAME , & self . amount) ? ; state . serialize_field (crate :: prisma :: users_on_campaigns :: txn_hash :: NAME , & self . txn_hash) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , user_id , campaign_id , claimed , amount , txn_hash } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: prisma :: users_on_campaigns :: $ field :: NAME) , + , crate :: prisma :: users_on_campaigns :: user_id :: NAME , crate :: prisma :: users_on_campaigns :: campaign_id :: NAME , crate :: prisma :: users_on_campaigns :: claimed :: NAME , crate :: prisma :: users_on_campaigns :: amount :: NAME , crate :: prisma :: users_on_campaigns :: txn_hash :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: prisma :: users_on_campaigns :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: prisma :: users_on_campaigns :: user_id :: NAME => Ok (Field :: user_id) , crate :: prisma :: users_on_campaigns :: campaign_id :: NAME => Ok (Field :: campaign_id) , crate :: prisma :: users_on_campaigns :: claimed :: NAME => Ok (Field :: claimed) , crate :: prisma :: users_on_campaigns :: amount :: NAME => Ok (Field :: amount) , crate :: prisma :: users_on_campaigns :: txn_hash :: NAME => Ok (Field :: txn_hash) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut user_id = None ; let mut campaign_id = None ; let mut claimed = None ; let mut amount = None ; let mut txn_hash = None ; while let Some (key) = map . next_key () ? { match key { Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_on_campaigns :: user_id :: NAME)) ; } user_id = Some (map . next_value () ?) ; } Field :: campaign_id => { if campaign_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_on_campaigns :: campaign_id :: NAME)) ; } campaign_id = Some (map . next_value () ?) ; } Field :: claimed => { if claimed . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_on_campaigns :: claimed :: NAME)) ; } claimed = Some (map . next_value () ?) ; } Field :: amount => { if amount . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_on_campaigns :: amount :: NAME)) ; } amount = Some (map . next_value () ?) ; } Field :: txn_hash => { if txn_hash . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_on_campaigns :: txn_hash :: NAME)) ; } txn_hash = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: prisma :: users_on_campaigns :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_on_campaigns :: $ field :: NAME)) ? ;) * let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_on_campaigns :: user_id :: NAME)) ? ; let campaign_id = campaign_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_on_campaigns :: campaign_id :: NAME)) ? ; let claimed = claimed . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_on_campaigns :: claimed :: NAME)) ? ; let amount = amount . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_on_campaigns :: amount :: NAME)) ? ; let txn_hash = txn_hash . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: prisma :: users_on_campaigns :: txn_hash :: NAME)) ? ; Ok (Data { user_id , campaign_id , claimed , amount , txn_hash , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["user_id" , "campaign_id" , "claimed" , "amount" , "txnHash" , "campaigns" , "users"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: prisma :: users_on_campaigns :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; campaigns : $ selection_mode : ident { $ ($ selections : tt) + }) => { campaigns :: Data } ; (@ field_type ; campaigns) => { crate :: prisma :: campaigns :: Data } ; (@ field_type ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { users :: Data } ; (@ field_type ; users) => { crate :: prisma :: users :: Data } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "UsersOnCampaigns" , available relations are "campaigns, users")) } ; (@ field_module ; campaigns : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: campaigns :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; users : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: prisma :: users :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; campaigns $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users_on_campaigns :: IncludeParam > :: into (crate :: prisma :: users_on_campaigns :: campaigns :: Include :: $ selection_mode (crate :: prisma :: campaigns :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; campaigns $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users_on_campaigns :: IncludeParam > :: into (crate :: prisma :: users_on_campaigns :: campaigns :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: prisma :: users_on_campaigns :: IncludeParam > :: into (crate :: prisma :: users_on_campaigns :: users :: Include :: $ selection_mode (crate :: prisma :: users :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; users $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: prisma :: users_on_campaigns :: IncludeParam > :: into (crate :: prisma :: users_on_campaigns :: users :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: prisma :: users_on_campaigns :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; user_id) => { "user_id" } ; (@ field_serde_name ; campaign_id) => { "campaign_id" } ; (@ field_serde_name ; claimed) => { "claimed" } ; (@ field_serde_name ; amount) => { "amount" } ; (@ field_serde_name ; txn_hash) => { "txnHash" } ; (@ field_serde_name ; campaigns) => { "campaigns" } ; (@ field_serde_name ; users) => { "users" } ; }
    pub use _include_users_on_campaigns as include;
    pub enum IncludeParam {
        UserId(user_id::Include),
        CampaignId(campaign_id::Include),
        Claimed(claimed::Include),
        Amount(amount::Include),
        TxnHash(txn_hash::Include),
        Campaigns(campaigns::Include),
        Users(users::Include),
    }
    impl IncludeParam {
        pub fn to_selection(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::UserId(data) => data.to_selection(),
                Self::CampaignId(data) => data.to_selection(),
                Self::Claimed(data) => data.to_selection(),
                Self::Amount(data) => data.to_selection(),
                Self::TxnHash(data) => data.to_selection(),
                Self::Campaigns(data) => data.to_selection(),
                Self::Users(data) => data.to_selection(),
            }
        }
    }
    #[macro_export]
    macro_rules ! _partial_unchecked_users_on_campaigns { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: prisma :: users_on_campaigns struct $ struct_name { # [serde (rename = "user_id")] pub user_id : i32 , # [serde (rename = "campaign_id")] pub campaign_id : i32 , # [serde (rename = "claimed")] pub claimed : bool , # [serde (rename = "amount")] pub amount : i32 , # [serde (rename = "txnHash")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub txn_hash : Option < String > } [$ ($ scalar_field) , +] } } ; }
    pub use _partial_unchecked_users_on_campaigns as partial_unchecked;
    #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
    pub struct Data {
        #[serde(rename = "user_id")]
        pub user_id: i32,
        #[serde(rename = "campaign_id")]
        pub campaign_id: i32,
        #[serde(rename = "claimed")]
        pub claimed: bool,
        #[serde(rename = "amount")]
        pub amount: i32,
        #[serde(rename = "txnHash")]
        pub txn_hash: Option<String>,
        #[serde(rename = "campaigns")]
        pub campaigns: Option<Box<super::campaigns::Data>>,
        #[serde(rename = "users")]
        pub users: Option<Box<super::users::Data>>,
    }
    impl Data {
        pub fn campaigns(
            &self,
        ) -> Result<&super::campaigns::Data, ::prisma_client_rust::RelationNotFetchedError>
        {
            self.campaigns
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(campaigns),
                ))
                .map(|v| v.as_ref())
        }
        pub fn users(
            &self,
        ) -> Result<&super::users::Data, ::prisma_client_rust::RelationNotFetchedError> {
            self.users
                .as_ref()
                .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
                    stringify!(users),
                ))
                .map(|v| v.as_ref())
        }
    }
    #[derive(Clone)]
    pub enum WithParam {
        Campaigns(super::campaigns::UniqueArgs),
        Users(super::users::UniqueArgs),
    }
    impl Into<::prisma_client_rust::Selection> for WithParam {
        fn into(self) -> ::prisma_client_rust::Selection {
            match self {
                Self::Campaigns(args) => {
                    let mut selections = < super :: campaigns :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(campaigns::NAME, None, [], selections)
                }
                Self::Users(args) => {
                    let mut selections = < super :: users :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
                    selections.extend(
                        args.with_params
                            .into_iter()
                            .map(Into::<::prisma_client_rust::Selection>::into),
                    );
                    ::prisma_client_rust::Selection::new(users::NAME, None, [], selections)
                }
            }
        }
    }
    #[derive(Clone)]
    pub enum SetParam {
        SetUserId(i32),
        IncrementUserId(i32),
        DecrementUserId(i32),
        MultiplyUserId(i32),
        DivideUserId(i32),
        SetCampaignId(i32),
        IncrementCampaignId(i32),
        DecrementCampaignId(i32),
        MultiplyCampaignId(i32),
        DivideCampaignId(i32),
        SetClaimed(bool),
        SetAmount(i32),
        IncrementAmount(i32),
        DecrementAmount(i32),
        MultiplyAmount(i32),
        DivideAmount(i32),
        SetTxnHash(Option<String>),
        ConnectCampaigns(super::campaigns::UniqueWhereParam),
        ConnectUsers(super::users::UniqueWhereParam),
    }
    impl From<SetParam> for (String, ::prisma_client_rust::PrismaValue) {
        fn from(param: SetParam) -> Self {
            match param {
                SetParam::SetUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideUserId(value) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetCampaignId(value) => (
                    campaign_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementCampaignId(value) => (
                    campaign_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementCampaignId(value) => (
                    campaign_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyCampaignId(value) => (
                    campaign_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideCampaignId(value) => (
                    campaign_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetClaimed(value) => (
                    claimed::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Boolean(value),
                ),
                SetParam::SetAmount(value) => (
                    amount::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Int(value as i64),
                ),
                SetParam::IncrementAmount(value) => (
                    amount::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "increment".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DecrementAmount(value) => (
                    amount::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "decrement".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::MultiplyAmount(value) => (
                    amount::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "multiply".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::DivideAmount(value) => (
                    amount::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "divide".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                ),
                SetParam::SetTxnHash(value) => (
                    txn_hash::NAME.to_string(),
                    value
                        .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                        .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                ),
                SetParam::ConnectCampaigns(where_param) => (
                    campaigns::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::campaigns::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                SetParam::ConnectUsers(where_param) => (
                    users::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::Object(vec![(
                        "connect".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            [where_param]
                                .into_iter()
                                .map(Into::<super::users::WhereParam>::into)
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum UncheckedSetParam {
        UserId(i32),
        CampaignId(i32),
        Claimed(bool),
        Amount(i32),
        TxnHash(Option<String>),
    }
    impl From<UncheckedSetParam> for SetParam {
        fn from(param: UncheckedSetParam) -> Self {
            match param {
                UncheckedSetParam::UserId(value) => Self::SetUserId(value),
                UncheckedSetParam::CampaignId(value) => Self::SetCampaignId(value),
                UncheckedSetParam::Claimed(value) => Self::SetClaimed(value),
                UncheckedSetParam::Amount(value) => Self::SetAmount(value),
                UncheckedSetParam::TxnHash(value) => Self::SetTxnHash(value),
            }
        }
    }
    #[derive(Clone)]
    pub enum OrderByParam {
        UserId(::prisma_client_rust::Direction),
        CampaignId(::prisma_client_rust::Direction),
        Claimed(::prisma_client_rust::Direction),
        Amount(::prisma_client_rust::Direction),
        TxnHash(::prisma_client_rust::Direction),
    }
    impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
        fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
            match self {
                Self::UserId(direction) => (
                    user_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::CampaignId(direction) => (
                    campaign_id::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Claimed(direction) => (
                    claimed::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::Amount(direction) => (
                    amount::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
                Self::TxnHash(direction) => (
                    txn_hash::NAME.to_string(),
                    ::prisma_client_rust::PrismaValue::String(direction.to_string()),
                ),
            }
        }
    }
    #[derive(Clone)]
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        UserIdCampaignIdEquals(i32, i32),
        UserId(_prisma::read_filters::IntFilter),
        CampaignId(_prisma::read_filters::IntFilter),
        Claimed(_prisma::read_filters::BoolFilter),
        Amount(_prisma::read_filters::IntFilter),
        TxnHash(_prisma::read_filters::StringNullableFilter),
        CampaignsIs(Vec<super::campaigns::WhereParam>),
        CampaignsIsNot(Vec<super::campaigns::WhereParam>),
        UsersIs(Vec<super::users::WhereParam>),
        UsersIsNot(Vec<super::users::WhereParam>),
    }
    impl ::prisma_client_rust::WhereInput for WhereParam {
        fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
            let (name, value) = match self {
                Self::Not(value) => (
                    "NOT",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::Or(value) => (
                    "OR",
                    ::prisma_client_rust::SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(::prisma_client_rust::WhereInput::serialize)
                            .map(Into::into)
                            .map(|v| vec![v])
                            .map(::prisma_client_rust::PrismaValue::Object)
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND",
                    ::prisma_client_rust::SerializedWhereValue::Object(
                        ::prisma_client_rust::merge_fields(
                            value
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(Into::into)
                                .collect(),
                        ),
                    ),
                ),
                Self::UserIdCampaignIdEquals(user_id, campaign_id) => (
                    "user_id_campaign_id",
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![
                        (
                            user_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(user_id as i64),
                        ),
                        (
                            campaign_id::NAME.to_string(),
                            ::prisma_client_rust::PrismaValue::Int(campaign_id as i64),
                        ),
                    ]),
                ),
                Self::UserId(value) => (user_id::NAME, value.into()),
                Self::CampaignId(value) => (campaign_id::NAME, value.into()),
                Self::Claimed(value) => (claimed::NAME, value.into()),
                Self::Amount(value) => (amount::NAME, value.into()),
                Self::TxnHash(value) => (txn_hash::NAME, value.into()),
                Self::CampaignsIs(where_params) => (
                    campaigns::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::CampaignsIsNot(where_params) => (
                    campaigns::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIs(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsersIsNot(where_params) => (
                    users::NAME,
                    ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        ::prisma_client_rust::PrismaValue::Object(
                            where_params
                                .into_iter()
                                .map(::prisma_client_rust::WhereInput::serialize)
                                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                                .collect(),
                        ),
                    )]),
                ),
            };
            ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
        }
    }
    #[derive(Clone)]
    pub enum UniqueWhereParam {
        UserIdCampaignIdEquals(i32, i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::UserIdCampaignIdEquals(user_id, campaign_id) => {
                    Self::UserIdCampaignIdEquals(user_id, campaign_id)
                }
            }
        }
    }
    impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
        fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
            match op {
                ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
                ::prisma_client_rust::Operator::And(value) => Self::And(value),
                ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
            }
        }
    }
    #[derive(Clone)]
    pub struct Types;
    impl ::prisma_client_rust::ModelTypes for Types {
        type Data = Data;
        type Where = WhereParam;
        type UncheckedSet = UncheckedSetParam;
        type Set = SetParam;
        type With = WithParam;
        type OrderBy = OrderByParam;
        type Cursor = UniqueWhereParam;
        const MODEL: &'static str = NAME;
        fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
            vec![
                ::prisma_client_rust::sel(user_id::NAME),
                ::prisma_client_rust::sel(campaign_id::NAME),
                ::prisma_client_rust::sel(claimed::NAME),
                ::prisma_client_rust::sel(amount::NAME),
                ::prisma_client_rust::sel(txn_hash::NAME),
            ]
        }
    }
    pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
    pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
    pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
    pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
    pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
    pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
    pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
    pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
    pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
    pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
    pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
    pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
    pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
    #[derive(Clone)]
    pub struct Actions<'a> {
        pub client: &'a ::prisma_client_rust::PrismaClientInternals,
    }
    impl<'a> Actions<'a> {
        pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
            FindUnique::new(self.client, _where.into())
        }
        pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
            FindFirst::new(self.client, _where)
        }
        pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
            FindMany::new(self.client, _where)
        }
        pub fn create(
            self,
            amount: i32,
            campaigns: super::campaigns::UniqueWhereParam,
            users: super::users::UniqueWhereParam,
            mut _params: Vec<SetParam>,
        ) -> Create<'a> {
            _params.extend([
                amount::set(amount),
                campaigns::connect(campaigns),
                users::connect(users),
            ]);
            Create::new(self.client, _params)
        }
        pub fn create_unchecked(
            self,
            user_id: i32,
            campaign_id: i32,
            amount: i32,
            mut _params: Vec<UncheckedSetParam>,
        ) -> Create<'a> {
            _params.extend([
                user_id::set(user_id),
                campaign_id::set(campaign_id),
                amount::set(amount),
            ]);
            Create::new(self.client, _params.into_iter().map(Into::into).collect())
        }
        pub fn create_many(self, data: Vec<(i32, i32, i32, Vec<SetParam>)>) -> CreateMany<'a> {
            let data = data
                .into_iter()
                .map(|(user_id, campaign_id, amount, mut _params)| {
                    _params.extend([
                        user_id::set(user_id),
                        campaign_id::set(campaign_id),
                        amount::set(amount),
                    ]);
                    _params
                })
                .collect();
            CreateMany::new(self.client, data)
        }
        pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
            Update::new(self.client, _where.into(), _params, vec![])
        }
        pub fn update_unchecked(
            self,
            _where: UniqueWhereParam,
            _params: Vec<UncheckedSetParam>,
        ) -> Update<'a> {
            Update::new(
                self.client,
                _where.into(),
                _params.into_iter().map(Into::into).collect(),
                vec![],
            )
        }
        pub fn update_many(
            self,
            _where: Vec<WhereParam>,
            _params: Vec<SetParam>,
        ) -> UpdateMany<'a> {
            UpdateMany::new(self.client, _where, _params)
        }
        pub fn upsert(
            self,
            _where: UniqueWhereParam,
            (amount, campaigns, users, mut _params): (
                i32,
                super::campaigns::UniqueWhereParam,
                super::users::UniqueWhereParam,
                Vec<SetParam>,
            ),
            _update: Vec<SetParam>,
        ) -> Upsert<'a> {
            _params.extend([
                amount::set(amount),
                campaigns::connect(campaigns),
                users::connect(users),
            ]);
            Upsert::new(self.client, _where.into(), _params, _update)
        }
        pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
            Delete::new(self.client, _where.into(), vec![])
        }
        pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
            DeleteMany::new(self.client, _where)
        }
        pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
            Count::new(self.client, _where)
        }
    }
}
pub mod _prisma {
    pub struct PrismaClientBuilder {
        url: Option<String>,
        action_notifier: ::prisma_client_rust::ActionNotifier,
    }
    impl PrismaClientBuilder {
        fn new() -> Self {
            Self {
                url: None,
                action_notifier: ::prisma_client_rust::ActionNotifier::new(),
            }
        }
        pub fn with_url(mut self, url: String) -> Self {
            self.url = Some(url);
            self
        }
        pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
            let internals = ::prisma_client_rust::PrismaClientInternals::new(
                self.url,
                self.action_notifier,
                super::DATAMODEL_STR,
            )
            .await?;
            Ok(PrismaClient(internals))
        }
    }
    pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
    impl ::std::fmt::Debug for PrismaClient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            f.debug_struct("PrismaClient").finish()
        }
    }
    impl PrismaClient {
        pub fn _builder() -> PrismaClientBuilder {
            PrismaClientBuilder::new()
        }
        pub fn _query_raw<T: ::prisma_client_rust::Data>(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::QueryRaw<T> {
            ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub fn _execute_raw(
            &self,
            query: ::prisma_client_rust::Raw,
        ) -> ::prisma_client_rust::ExecuteRaw {
            ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
        }
        pub async fn _batch<
            'batch,
            T: ::prisma_client_rust::BatchContainer<'batch, Marker>,
            Marker,
        >(
            &self,
            queries: T,
        ) -> ::prisma_client_rust::Result<
            <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
        > {
            ::prisma_client_rust::batch(queries, &self.0).await
        }
        pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
            ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
        }
        pub fn activities(&self) -> super::activities::Actions {
            super::activities::Actions { client: &self.0 }
        }
        pub fn banners(&self) -> super::banners::Actions {
            super::banners::Actions { client: &self.0 }
        }
        pub fn businesses(&self) -> super::businesses::Actions {
            super::businesses::Actions { client: &self.0 }
        }
        pub fn campaigns(&self) -> super::campaigns::Actions {
            super::campaigns::Actions { client: &self.0 }
        }
        pub fn criteria_reviews(&self) -> super::criteria_reviews::Actions {
            super::criteria_reviews::Actions { client: &self.0 }
        }
        pub fn dids(&self) -> super::dids::Actions {
            super::dids::Actions { client: &self.0 }
        }
        pub fn emails(&self) -> super::emails::Actions {
            super::emails::Actions { client: &self.0 }
        }
        pub fn feedbacks_on_businesses(&self) -> super::feedbacks_on_businesses::Actions {
            super::feedbacks_on_businesses::Actions { client: &self.0 }
        }
        pub fn followers_on_businesses(&self) -> super::followers_on_businesses::Actions {
            super::followers_on_businesses::Actions { client: &self.0 }
        }
        pub fn medias(&self) -> super::medias::Actions {
            super::medias::Actions { client: &self.0 }
        }
        pub fn notifications(&self) -> super::notifications::Actions {
            super::notifications::Actions { client: &self.0 }
        }
        pub fn rates_on_businesses(&self) -> super::rates_on_businesses::Actions {
            super::rates_on_businesses::Actions { client: &self.0 }
        }
        pub fn replies(&self) -> super::replies::Actions {
            super::replies::Actions { client: &self.0 }
        }
        pub fn replies_on_feedbacks(&self) -> super::replies_on_feedbacks::Actions {
            super::replies_on_feedbacks::Actions { client: &self.0 }
        }
        pub fn review_histories(&self) -> super::review_histories::Actions {
            super::review_histories::Actions { client: &self.0 }
        }
        pub fn reviews(&self) -> super::reviews::Actions {
            super::reviews::Actions { client: &self.0 }
        }
        pub fn search_params(&self) -> super::search_params::Actions {
            super::search_params::Actions { client: &self.0 }
        }
        pub fn socials(&self) -> super::socials::Actions {
            super::socials::Actions { client: &self.0 }
        }
        pub fn storages(&self) -> super::storages::Actions {
            super::storages::Actions { client: &self.0 }
        }
        pub fn super_users(&self) -> super::super_users::Actions {
            super::super_users::Actions { client: &self.0 }
        }
        pub fn users(&self) -> super::users::Actions {
            super::users::Actions { client: &self.0 }
        }
        pub fn users_on_campaigns(&self) -> super::users_on_campaigns::Actions {
            super::users_on_campaigns::Actions { client: &self.0 }
        }
    }
    impl ::prisma_client_rust::PrismaClient for PrismaClient {
        fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
            &self.0
        }
        fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
            &mut self.0
        }
        fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
            Self(self.0.with_tx_id(tx_id))
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ActivitiesScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "kind")]
        Kind,
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "review_id")]
        ReviewId,
        #[serde(rename = "point")]
        Point,
        #[serde(rename = "from_user_id")]
        FromUserId,
    }
    impl ToString for ActivitiesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::Kind => "kind".to_string(),
                Self::UserId => "user_id".to_string(),
                Self::ReviewId => "review_id".to_string(),
                Self::Point => "point".to_string(),
                Self::FromUserId => "from_user_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum BannersScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "expried_time")]
        ExpriedTime,
        #[serde(rename = "source_id")]
        SourceId,
    }
    impl ToString for BannersScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::ExpriedTime => "expried_time".to_string(),
                Self::SourceId => "source_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum BusinessesScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "overview")]
        Overview,
        #[serde(rename = "token")]
        Token,
        #[serde(rename = "logo")]
        Logo,
        #[serde(rename = "founder_name")]
        FounderName,
        #[serde(rename = "start_date")]
        StartDate,
        #[serde(rename = "address")]
        Address,
        #[serde(rename = "whitepaper_url")]
        WhitepaperUrl,
        #[serde(rename = "contract_address")]
        ContractAddress,
        #[serde(rename = "website")]
        Website,
        #[serde(rename = "type")]
        Type,
        #[serde(rename = "main_category")]
        MainCategory,
        #[serde(rename = "chains")]
        Chains,
        #[serde(rename = "cmc_id")]
        CmcId,
        #[serde(rename = "contract_chain")]
        ContractChain,
        #[serde(rename = "status")]
        Status,
        #[serde(rename = "tags")]
        Tags,
        #[serde(rename = "creator_id")]
        CreatorId,
    }
    impl ToString for BusinessesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::Name => "name".to_string(),
                Self::Overview => "overview".to_string(),
                Self::Token => "token".to_string(),
                Self::Logo => "logo".to_string(),
                Self::FounderName => "founder_name".to_string(),
                Self::StartDate => "start_date".to_string(),
                Self::Address => "address".to_string(),
                Self::WhitepaperUrl => "whitepaper_url".to_string(),
                Self::ContractAddress => "contract_address".to_string(),
                Self::Website => "website".to_string(),
                Self::Type => "type".to_string(),
                Self::MainCategory => "main_category".to_string(),
                Self::Chains => "chains".to_string(),
                Self::CmcId => "cmc_id".to_string(),
                Self::ContractChain => "contract_chain".to_string(),
                Self::Status => "status".to_string(),
                Self::Tags => "tags".to_string(),
                Self::CreatorId => "creator_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum CampaignsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "title")]
        Title,
        #[serde(rename = "description")]
        Description,
        #[serde(rename = "metadata")]
        Metadata,
    }
    impl ToString for CampaignsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::Title => "title".to_string(),
                Self::Description => "description".to_string(),
                Self::Metadata => "metadata".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum CriteriaReviewsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "name")]
        Name,
        #[serde(rename = "value")]
        Value,
        #[serde(rename = "review_id")]
        ReviewId,
    }
    impl ToString for CriteriaReviewsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Name => "name".to_string(),
                Self::Value => "value".to_string(),
                Self::ReviewId => "review_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum DidsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "controller")]
        Controller,
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "username")]
        Username,
    }
    impl ToString for DidsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Controller => "controller".to_string(),
                Self::Email => "email".to_string(),
                Self::Username => "username".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum EmailsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "email")]
        Email,
    }
    impl ToString for EmailsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::Email => "email".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum FeedbacksOnBusinessesScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "business_id")]
        BusinessId,
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "text")]
        Text,
        #[serde(rename = "urls")]
        Urls,
        #[serde(rename = "dislikes")]
        Dislikes,
        #[serde(rename = "likes")]
        Likes,
    }
    impl ToString for FeedbacksOnBusinessesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::BusinessId => "business_id".to_string(),
                Self::UserId => "user_id".to_string(),
                Self::Text => "text".to_string(),
                Self::Urls => "urls".to_string(),
                Self::Dislikes => "dislikes".to_string(),
                Self::Likes => "likes".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum FollowersOnBusinessesScalarFieldEnum {
        #[serde(rename = "follower_id")]
        FollowerId,
        #[serde(rename = "business_id")]
        BusinessId,
    }
    impl ToString for FollowersOnBusinessesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::FollowerId => "follower_id".to_string(),
                Self::BusinessId => "business_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum MediasScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "url")]
        Url,
        #[serde(rename = "business_id")]
        BusinessId,
        #[serde(rename = "path")]
        Path,
        #[serde(rename = "source")]
        Source,
    }
    impl ToString for MediasScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::Url => "url".to_string(),
                Self::BusinessId => "business_id".to_string(),
                Self::Path => "path".to_string(),
                Self::Source => "source".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum NotificationsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "business_id")]
        BusinessId,
        #[serde(rename = "review_id")]
        ReviewId,
        #[serde(rename = "seen")]
        Seen,
        #[serde(rename = "to")]
        To,
        #[serde(rename = "from")]
        From,
        #[serde(rename = "meta_data")]
        MetaData,
        #[serde(rename = "type")]
        Type,
    }
    impl ToString for NotificationsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::BusinessId => "business_id".to_string(),
                Self::ReviewId => "review_id".to_string(),
                Self::Seen => "seen".to_string(),
                Self::To => "to".to_string(),
                Self::From => "from".to_string(),
                Self::MetaData => "meta_data".to_string(),
                Self::Type => "type".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum QueryMode {
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "insensitive")]
        Insensitive,
    }
    impl ToString for QueryMode {
        fn to_string(&self) -> String {
            match self {
                Self::Default => "default".to_string(),
                Self::Insensitive => "insensitive".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum RatesOnBusinessesScalarFieldEnum {
        #[serde(rename = "valuer_id")]
        ValuerId,
        #[serde(rename = "business_id")]
        BusinessId,
        #[serde(rename = "rating")]
        Rating,
    }
    impl ToString for RatesOnBusinessesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::ValuerId => "valuer_id".to_string(),
                Self::BusinessId => "business_id".to_string(),
                Self::Rating => "rating".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum RepliesScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "desc")]
        Desc,
        #[serde(rename = "review_id")]
        ReviewId,
        #[serde(rename = "likes")]
        Likes,
        #[serde(rename = "dislikes")]
        Dislikes,
        #[serde(rename = "user_id")]
        UserId,
    }
    impl ToString for RepliesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::Desc => "desc".to_string(),
                Self::ReviewId => "review_id".to_string(),
                Self::Likes => "likes".to_string(),
                Self::Dislikes => "dislikes".to_string(),
                Self::UserId => "user_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum RepliesOnFeedbacksScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "feedback_id")]
        FeedbackId,
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for RepliesOnFeedbacksScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::FeedbackId => "feedback_id".to_string(),
                Self::UserId => "user_id".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ReviewHistoriesScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "rate")]
        Rate,
        #[serde(rename = "review_id")]
        ReviewId,
        #[serde(rename = "txn_hash")]
        TxnHash,
        #[serde(rename = "headline")]
        Headline,
        #[serde(rename = "comment")]
        Comment,
    }
    impl ToString for ReviewHistoriesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::Rate => "rate".to_string(),
                Self::ReviewId => "review_id".to_string(),
                Self::TxnHash => "txn_hash".to_string(),
                Self::Headline => "headline".to_string(),
                Self::Comment => "comment".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum ReviewsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "rate")]
        Rate,
        #[serde(rename = "business_id")]
        BusinessId,
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "status")]
        Status,
        #[serde(rename = "likes")]
        Likes,
        #[serde(rename = "dislikes")]
        Dislikes,
        #[serde(rename = "headline")]
        Headline,
        #[serde(rename = "comment")]
        Comment,
        #[serde(rename = "txn_hash")]
        TxnHash,
        #[serde(rename = "sharings")]
        Sharings,
    }
    impl ToString for ReviewsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::Rate => "rate".to_string(),
                Self::BusinessId => "business_id".to_string(),
                Self::UserId => "user_id".to_string(),
                Self::Status => "status".to_string(),
                Self::Likes => "likes".to_string(),
                Self::Dislikes => "dislikes".to_string(),
                Self::Headline => "headline".to_string(),
                Self::Comment => "comment".to_string(),
                Self::TxnHash => "txn_hash".to_string(),
                Self::Sharings => "sharings".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SearchParamsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "business_name")]
        BusinessName,
        #[serde(rename = "times")]
        Times,
    }
    impl ToString for SearchParamsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::BusinessName => "business_name".to_string(),
                Self::Times => "times".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SocialsScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "last_update")]
        LastUpdate,
        #[serde(rename = "twitterId")]
        TwitterId,
        #[serde(rename = "twitter")]
        Twitter,
        #[serde(rename = "discordId")]
        DiscordId,
        #[serde(rename = "discord")]
        Discord,
        #[serde(rename = "telegramId")]
        TelegramId,
        #[serde(rename = "telegram")]
        Telegram,
        #[serde(rename = "user_id")]
        UserId,
    }
    impl ToString for SocialsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::LastUpdate => "last_update".to_string(),
                Self::TwitterId => "twitterId".to_string(),
                Self::Twitter => "twitter".to_string(),
                Self::DiscordId => "discordId".to_string(),
                Self::Discord => "discord".to_string(),
                Self::TelegramId => "telegramId".to_string(),
                Self::Telegram => "telegram".to_string(),
                Self::UserId => "user_id".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SortOrder {
        #[serde(rename = "asc")]
        Asc,
        #[serde(rename = "desc")]
        Desc,
    }
    impl ToString for SortOrder {
        fn to_string(&self) -> String {
            match self {
                Self::Asc => "asc".to_string(),
                Self::Desc => "desc".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum StoragesScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "url")]
        Url,
        #[serde(rename = "tag")]
        Tag,
    }
    impl ToString for StoragesScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::Url => "url".to_string(),
                Self::Tag => "tag".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum SuperUsersScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "role")]
        Role,
        #[serde(rename = "refresh_token")]
        RefreshToken,
        #[serde(rename = "username")]
        Username,
        #[serde(rename = "password")]
        Password,
        #[serde(rename = "avatar")]
        Avatar,
    }
    impl ToString for SuperUsersScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::Role => "role".to_string(),
                Self::RefreshToken => "refresh_token".to_string(),
                Self::Username => "username".to_string(),
                Self::Password => "password".to_string(),
                Self::Avatar => "avatar".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum TransactionIsolationLevel {
        #[serde(rename = "ReadUncommitted")]
        ReadUncommitted,
        #[serde(rename = "ReadCommitted")]
        ReadCommitted,
        #[serde(rename = "RepeatableRead")]
        RepeatableRead,
        #[serde(rename = "Serializable")]
        Serializable,
    }
    impl ToString for TransactionIsolationLevel {
        fn to_string(&self) -> String {
            match self {
                Self::ReadUncommitted => "ReadUncommitted".to_string(),
                Self::ReadCommitted => "ReadCommitted".to_string(),
                Self::RepeatableRead => "RepeatableRead".to_string(),
                Self::Serializable => "Serializable".to_string(),
            }
        }
    }
    impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum UsersScalarFieldEnum {
        #[serde(rename = "id")]
        Id,
        #[serde(rename = "created_at")]
        CreatedAt,
        #[serde(rename = "wallet_address")]
        WalletAddress,
        #[serde(rename = "noti_accepted")]
        NotiAccepted,
        #[serde(rename = "spam_accepted")]
        SpamAccepted,
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "nickname")]
        Nickname,
        #[serde(rename = "avatar_url")]
        AvatarUrl,
        #[serde(rename = "refresh_token")]
        RefreshToken,
        #[serde(rename = "isAdmin")]
        IsAdmin,
        #[serde(rename = "password")]
        Password,
        #[serde(rename = "background_url")]
        BackgroundUrl,
        #[serde(rename = "didId")]
        DidId,
        #[serde(rename = "last_sync_ibt")]
        LastSyncIbt,
        #[serde(rename = "last_update")]
        LastUpdate,
    }
    impl ToString for UsersScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::Id => "id".to_string(),
                Self::CreatedAt => "created_at".to_string(),
                Self::WalletAddress => "wallet_address".to_string(),
                Self::NotiAccepted => "noti_accepted".to_string(),
                Self::SpamAccepted => "spam_accepted".to_string(),
                Self::Email => "email".to_string(),
                Self::Nickname => "nickname".to_string(),
                Self::AvatarUrl => "avatar_url".to_string(),
                Self::RefreshToken => "refresh_token".to_string(),
                Self::IsAdmin => "isAdmin".to_string(),
                Self::Password => "password".to_string(),
                Self::BackgroundUrl => "background_url".to_string(),
                Self::DidId => "didId".to_string(),
                Self::LastSyncIbt => "last_sync_ibt".to_string(),
                Self::LastUpdate => "last_update".to_string(),
            }
        }
    }
    #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
    pub enum UsersOnCampaignsScalarFieldEnum {
        #[serde(rename = "user_id")]
        UserId,
        #[serde(rename = "campaign_id")]
        CampaignId,
        #[serde(rename = "claimed")]
        Claimed,
        #[serde(rename = "amount")]
        Amount,
        #[serde(rename = "txnHash")]
        TxnHash,
    }
    impl ToString for UsersOnCampaignsScalarFieldEnum {
        fn to_string(&self) -> String {
            match self {
                Self::UserId => "user_id".to_string(),
                Self::CampaignId => "campaign_id".to_string(),
                Self::Claimed => "claimed".to_string(),
                Self::Amount => "amount".to_string(),
                Self::TxnHash => "txnHash".to_string(),
            }
        }
    }
    pub mod read_filters {
        #[derive(Clone)]
        pub enum IntListFilter {
            Equals(Vec<i32>),
            Has(Option<i32>),
            HasEvery(Vec<i32>),
            HasSome(Vec<i32>),
            IsEmpty(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntListFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Has(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "has".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                    Self::HasEvery(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "hasEvery".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::HasSome(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "hasSome".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::IsEmpty(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isEmpty".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                }
            }
        }
        #[derive(Clone)]
        pub enum IntFilter {
            Equals(i32),
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(i32),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Int(value as i64),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum IntNullableFilter {
            Equals(Option<i32>),
            InVec(Vec<i32>),
            NotInVec(Vec<i32>),
            Lt(i32),
            Lte(i32),
            Gt(i32),
            Gte(i32),
            Not(Option<i32>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for IntNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Int(value as i64)
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::Int(value as i64),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::Int(value as i64))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum DateTimeFilter {
            Equals(
                ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
            ),
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::DateTime(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum DateTimeNullableFilter {
            Equals(
                Option<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            InVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            NotInVec(
                Vec<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
            Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
            Not(
                Option<
                    ::prisma_client_rust::chrono::DateTime<
                        ::prisma_client_rust::chrono::FixedOffset,
                    >,
                >,
            ),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::DateTime(value),
                    )]),
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum StringListFilter {
            Equals(Vec<String>),
            Has(Option<String>),
            HasEvery(Vec<String>),
            HasSome(Vec<String>),
            IsEmpty(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringListFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Has(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "has".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                    Self::HasEvery(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "hasEvery".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::HasSome(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "hasSome".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::IsEmpty(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "isEmpty".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                }
            }
        }
        #[derive(Clone)]
        pub enum StringFilter {
            Equals(String),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(String),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum StringNullableFilter {
            Equals(Option<String>),
            InVec(Vec<String>),
            NotInVec(Vec<String>),
            Lt(String),
            Lte(String),
            Gt(String),
            Gte(String),
            Contains(String),
            StartsWith(String),
            EndsWith(String),
            Mode(super::super::QueryMode),
            Not(Option<String>),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            value
                                .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        ::prisma_client_rust::PrismaValue::String(value),
                    )]),
                    Self::Contains(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "contains".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::StartsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "startsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::EndsWith(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "endsWith".to_string(),
                            ::prisma_client_rust::PrismaValue::String(value),
                        )])
                    }
                    Self::Mode(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "mode".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        value
                            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
                            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum BoolFilter {
            Equals(bool),
            Not(bool),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BoolFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Boolean(value),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Boolean(value),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum ActivityKindFilter {
            Equals(super::super::ActivityKind),
            InVec(Vec<super::super::ActivityKind>),
            NotInVec(Vec<super::super::ActivityKind>),
            Not(super::super::ActivityKind),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for ActivityKindFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum BusinessStatusFilter {
            Equals(super::super::BusinessStatus),
            InVec(Vec<super::super::BusinessStatus>),
            NotInVec(Vec<super::super::BusinessStatus>),
            Not(super::super::BusinessStatus),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for BusinessStatusFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum MediaSoucresFilter {
            Equals(super::super::MediaSoucres),
            InVec(Vec<super::super::MediaSoucres>),
            NotInVec(Vec<super::super::MediaSoucres>),
            Not(super::super::MediaSoucres),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for MediaSoucresFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum ReviewStatusesFilter {
            Equals(super::super::ReviewStatuses),
            InVec(Vec<super::super::ReviewStatuses>),
            NotInVec(Vec<super::super::ReviewStatuses>),
            Not(super::super::ReviewStatuses),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for ReviewStatusesFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
        #[derive(Clone)]
        pub enum SuperUserRolesFilter {
            Equals(super::super::SuperUserRoles),
            InVec(Vec<super::super::SuperUserRoles>),
            NotInVec(Vec<super::super::SuperUserRoles>),
            Not(super::super::SuperUserRoles),
        }
        impl Into<::prisma_client_rust::SerializedWhereValue> for SuperUserRolesFilter {
            fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
                match self {
                    Self::Equals(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "equals".to_string(),
                            ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                        )])
                    }
                    Self::InVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "in".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::NotInVec(value) => {
                        ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                            "notIn".to_string(),
                            ::prisma_client_rust::PrismaValue::List(
                                value
                                    .into_iter()
                                    .map(|value| {
                                        ::prisma_client_rust::PrismaValue::Enum(value.to_string())
                                    })
                                    .collect(),
                            ),
                        )])
                    }
                    Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        ::prisma_client_rust::PrismaValue::Enum(value.to_string()),
                    )]),
                }
            }
        }
    }
}
pub use _prisma::*;
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum ActivityKind {
    #[serde(rename = "reviewapproved")]
    Reviewapproved,
    #[serde(rename = "reacthelpful")]
    Reacthelpful,
    #[serde(rename = "reactdownful")]
    Reactdownful,
    #[serde(rename = "reply")]
    Reply,
    #[serde(rename = "share")]
    Share,
}
impl ToString for ActivityKind {
    fn to_string(&self) -> String {
        match self {
            Self::Reviewapproved => "reviewapproved".to_string(),
            Self::Reacthelpful => "reacthelpful".to_string(),
            Self::Reactdownful => "reactdownful".to_string(),
            Self::Reply => "reply".to_string(),
            Self::Share => "share".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum BusinessStatus {
    #[serde(rename = "approved")]
    Approved,
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "rejected")]
    Rejected,
}
impl ToString for BusinessStatus {
    fn to_string(&self) -> String {
        match self {
            Self::Approved => "approved".to_string(),
            Self::Pending => "pending".to_string(),
            Self::Rejected => "rejected".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum MediaSoucres {
    #[serde(rename = "Photo")]
    Photo,
    #[serde(rename = "Telegram")]
    Telegram,
    #[serde(rename = "Discord")]
    Discord,
    #[serde(rename = "Twitter")]
    Twitter,
    #[serde(rename = "Blog")]
    Blog,
}
impl ToString for MediaSoucres {
    fn to_string(&self) -> String {
        match self {
            Self::Photo => "Photo".to_string(),
            Self::Telegram => "Telegram".to_string(),
            Self::Discord => "Discord".to_string(),
            Self::Twitter => "Twitter".to_string(),
            Self::Blog => "Blog".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum ReviewStatuses {
    #[serde(rename = "approved")]
    Approved,
    #[serde(rename = "pending")]
    Pending,
    #[serde(rename = "rejected")]
    Rejected,
}
impl ToString for ReviewStatuses {
    fn to_string(&self) -> String {
        match self {
            Self::Approved => "approved".to_string(),
            Self::Pending => "pending".to_string(),
            Self::Rejected => "rejected".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum SuperUserRoles {
    #[serde(rename = "admin")]
    Admin,
    #[serde(rename = "editor")]
    Editor,
}
impl ToString for SuperUserRoles {
    fn to_string(&self) -> String {
        match self {
            Self::Admin => "admin".to_string(),
            Self::Editor => "editor".to_string(),
        }
    }
}
